<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d63366ad7e03b16a2afb56bc4b08668c45a7354cdf196c050ee003b01771d1ae366f4a08e3f3c365e7a51dd8ba2141672674bf25f5f6fc56eb72c155f6c223f9085403f0459de542dda8fe0bac3f87787551de187194453f698eb24ede3575011636d19b9011c5341debda2d93807938897d71c630b22bae9dcc4e6e7c82c33a5db3d0760d96e6b5f61648e663b62e3338fa2be203bdcdea1a65c37fd61a0297a4664aae114e82c3af7dcbf6b02d03f68435307de5d66ecebbdd154ed4fccd4774b7acdeeda9952736c3fd4c280934fc130535997c5b04444bf60553eb15a175fa7779371c9c2c22a6813376285f92d335957dc6a8d1521a7c7346fa337d3302cd45f98e42c318fdd9a423b9e8ddf5ea661070ff63ccdca6d6c6ca967964afe918a4a277898d7dcedcb18cb4ff303247a479b1ee484cf78787f1135df6dfaf4a80c2b78ccaeeedb63694d08c5c9072bacf61f1b36d76b985a69561e534b3cefa258d24c8f62dcacb9f3de9fc1b0b1fdf8d347ea7243b4ed8a03b3c6c45f3efbec6bbbf929b2160b734d29f47a4d9023fca0bac78fcffcbb24c3a49cbbdc61d46109a0554205dafab7dd3245213eece50931c59df0bbe598619933cc32017b10cfb75b2e5ac05e86da7e8f2b2af80eb3a28571e0b391ea708c4cb3c695fdaaa63cad77104f0af4f7507847c7f6bf17082bc71aac43f16bcdb9b39f560af877d8ec2c26098fdccbc48ad7edd67f30b7bbe48064f8382529c6dc8616e9e0d728165f8d134b6005dfb08e634bc4bc91bbbe3513ac0021dfa6c64873e2b1edaf50a064e322b926796c4fe1203592703a623c16b3ededbbab344d96890fb8c29a3a2c19fb6bc82b757821eb9aa45a4ad8c479cccfffe3f4413ca1955f9bb98398414ac6e9662e73155c63829b79fa4f663f352656406cb0d2349d2e65c19ff1300c26c5fd4616b61f5574d781a70e936ae52f5650e200111c25b6cf27e3cbba50d137e3f75fea4773ef4af8bdb5ba38c7a578e75a9d014c8e885d6ccd629083ca1c82b6d7324d9e77870db9e08eb2aa52702bbff8ee20427b99f973614ea4e6fd52f27a9047999fbc4c8eb0e8e3a1203e54f7de545b8a26dc5d2d3cf0dba5f778abdf12103d3362eb57e4c7fbc9976976d3944a6bb99176fa5348149d91a781849b4b7b5de5219430db980a775294174ce290e82422172e164f530e3e4ca07e28ee6fdb796a0f1b66b63cd18494d65330a2a9cc2bbc122630dc2c944adbcee8e4d32ff3c87b42e159e5366e4b574d25a4d39da08e05616c5639a6896801593c276c50402b6d3e405f15722a8a1092a10a15e0be78b78aa86e38d3cae384ac2d9675c821a350bc3e746fb4a5d618c7e612ad230abd54806041ba8ef8cbb3ed99d1e3dab71b2764945f40a5121193f1242d1be0e1b9922fbb0ef5482be00952078aa441d8f47cf115c55c09ab1418a3c6cc18bfdb548ba10a646f6376e605efb89abc4f01b61f86482e71b45ec19d7a95d12456bbd95dfbd155d74d024699e28b61a9f9cd11b879b0c58597bdf635d6aa5cbbd769bc6a82ee57b0a7cb1018a5e5a3245f80f086b97899f17c9b14ef1cc5bc3fdd327d7d548f985c338b8cec3012d19d8cebf0cfdf27e99695d23278cd8ff5edb1f1498a5332a05966f731dd40b294931e92612e9ad519ec4af637ae1f3c161d36d23af5a765de0020186d56862848e3d2570b2b7fc7bd85fa897202fa8ba5ae3fb36b8f35b348166b8e44898285ce7a093e06f161f8b88d2d10d1ab4b13c0012eaf262d2fadd44b637c874ba8ffae77a8236113fc534689ef2a06c54b80b6480cccb06c400a4d8ef6deb51c3d3abb9fb105161707a3c26ba3cd6df20aea83846ecb07e3432cdb0b907e02b5cbc10ac0134f39f133253c68b5cb3ab61279a8e83ff3ab1d697a70369bfed4eac37cc7f6b25defba7392ef7e06fb9d18e41c96cd89f49880f5ba38cbc0f42cf47fb25e2afc30172976c79f7d3cbeb2be7641961415991bce2dea3557630deb8050f318014f0cf3e9fb20898e3f8f5f8b7c062427ed1f660dcf0d7fc6b1cad95ca9b62eb0544f8feec16a044eb1b81c295dd6903ef1f0f5d00625b44cc7828b98ae2e22bc458511940ae4d1a742f25aa52697f41fbf79a996ead5fc84c9d271985a409e16f8310e9bbb7f4889c303cf1ee177c5e8e3382b4634cf6a044972286eceb5c6ad08cfb7677bbfa5551978cae3d238b7a670980e0be4558efdf89a399b75ca49ced25b4ae4b007e06a2dba347194367891e25c973779ec9490700b7d6ba1dc4b9ddaa2b4e511e2cd188d229dc749bf251d106e722bfc7c56c484c5556c1e4caed11bc51e28f7785dc6bd8e59db48bd486548ff37618774608fd464c5cd52bfb5feff8ab58f84a5dcb9db6ef64d3b11e885a09800dc1abf744b7d6253d923104c08e9641ef3e020e8644f45dd9ebce4021196eae5bdbb8beaa41be41f25138714a3940cd4fb5489a11be3d500ff264807025369a0fa147b926798d7eb9db71703c62a979b318ed40ec3259b6aa1cb888cc2126fba8d26d6f4fc3728d811951251951056bc66f164fb51738578d67dc5a137c13a144ed7a312001c8b747b59fccfa4b623d561672336dbf2f6d224b2d76c4e10ccfa72d48868c1cdfd790d390df6884b2ba73522a9f5fc70b2634a4687c6e3a6725561a5268009414ff659c4931288d5a75ca1dac3e47fb45a853ce23c3523ce0643df7fd3618731c693f76d46a942f8b1d562a96d599990a19e53fed80cb8f34bd5fb6f5f75789540e1d6c2f6f20964463954e1d052d92e56efaf903ac399c8f16d9e34d271d85155f6a88a3aca9fc6b847bad7fbe099355e30f38d5f6e18b8e4e6cb016b0b0531c7e7552f9f66f73d2bbd75317ce5841d6f4d111f01ff5cdb63f719c84e7e50e3838acae09abf13fab76f6960ab089976f181ec5041bddfa3297225faa8eb6414c67ba759eb19b72c3014d11fb42da1b3770160ff430ab040d35e05f3c52851fb29fcafd403cd788233a7e51f886787189dbda861fdf73c40aac7897439d2be102d68a72f3a1bae15c5a96ee1789f0dc6d5bcac620270dad62502c63044ff8e436a825d4e6353819fb5137030e55af319741a844d752dea266d318af5b189528b69657ae8a6a74d1f32d4d3f5ffe0cfaa552caad0fc437b3254a1118a4bc1d7f739c9e1af6976b39245bd27e0c4653720a93f2b9870a7489e34323c53b94573a52f324d7bec237fb420acf03b92f56afae39e62bdfd659ece1492a2a3781de7050c862cf3d5057326faf8c119dabe17ca30571bfb0fb333de768f2449518834571c2ffab9274c4b6038aa0f48b846c1f5e24cdf975d66abb1c3d2b3e9506ce06da46a32022bcc3a2cca1a9a1ba33680ed2ad06eed72cc8c62bad48b665e3d0024a4320b86a1212bb9ad491cdee15bbb280af5c188c94c03ec0d7f8d44b8e27e27f6d79141c68fab8fdbbe13db93e19b332828a05a293cd30b06c732a3a1513ec0231f5c72909fcbb67fbc4dc47ea666f651af5daecc5cc60f8080dc3a9ddb5878b9b2747041d5cd9999ac118b756bf45b8c91e39580820b57569a761a2034b9028b8183a1c8a9caacb73723e3af026587e5407bd6d052c176fcb6659c38674bbbb1f80fb1ca18ccc1370cbfd726fda3c3b78103a357d3c2b3bb61e7c58224dd73a81971770bf4ef0e537115e510772c54e2d9acf274659728bf17d5711f2258b29361d350dbc83ed9012e4ff47f2ab2d96f60dc20dc4a7519f26242cf98f70ba3db4087526de9d84ee9c8b3d882c9b7f387436fa06b5c41b3642b32a2a3f14d7039d2de0efa47c91078867cc0e3981514b85e51eb4fb98acbf20f93d3697cdca46262025e4052fa66bfa12cb4c39b68ab82c8c00adc084d77c906f57f87ebd118bc9da1ac8340764b0823189c784cd4b43769aa30cb480a8cc01bb1420811d2e827d017f97ab7fb144f650c92013ca64332474835d21b3bcdd5b9c7ad7da79a8cee55e92f2e27be98787f8003e884c6524ae2daae95a4fd04cc0bbf42d4fc4e3894434021e8f237226bf7ca03120fad7fc993fea14edcc1dfa57fda74fd12931b4dce0731a17028d82d013b2c671af8c9c54b3846d97d94f7fc77f878764036dd3ed62a7b382206bb3d65b64052bd71c0cdc185ee80688f2922e432a8b1182714359c01451edbef7332b977b1af9bf68aae9751f473e35e26f4bede1d3f50ec561fca0442112e2e88d4436d70080df920d3d36ec149f37521f31e1a1dbe10124c4729a8e2568a310b45ea603bd40bacf29c142db0a3ed373cee75b889b95a56ac306f64f75a5436d11465f571bd46ff7eeae403efd0fdc7c6fb27e86ca2f6d2a2947104b2a966f425c94112ef5a588e33f7ad0c2e6f5dbd342c006650ce8159dce57892f0df52806464cb448a57d78d01e358ab34ad60f08f9da552fa4bc45ae44f65f052be7a41fac5d30f7cad18344937032ac7cdc8d938ad788f25a6c89f9a8ec00d15175185cd2da2e01fb6d069de064dfbe7006e9bbd07ab1bf1beedadea4dcca114adbefdef62586d78d6f020649d534b274868a3219ba1b774a4329bdb000e91fdc3b997857e5635ef110a7af355b3541b9e0fb8a2735223978f522b58d2e97ff4a3322832b078e598bc4236304e3f029ee73c162fe0761c426471ec6dbd94a37a917ee2770bc58bf3d8994027fb0079b348a01ecf877f37f738389c4aae352bc71e37ae7f245c43e932aeced36935816ff77dd4bdab8379b372900a04662d36d842c11b6323784e5fb60ba3a6ca706307270d4994592c71bd0d2bd96fc7b4bf509426fdb1f9c8a3079d856c1061e8406ed2dbe0f0209c613fbd44d900904222cf72ad5bc7d148629c9d74c8628e1458b4b39d9bfe6a823027626f7517238b58fa3c4a02125459c59ab375add4234524c10860a128e0079f81c47f4c207a2426e13ac2eb3a88239cb4a7e7c407802607373558991e62e3130476750723482fdcf30c01268a61b78d7347646777fde675717dd785d9a570b395ffcee0f22039a04d767aa4cde994662def9488a058dd8469b1acc848c09ad177c762d26eedb7a967c4652755095b09e9b1124ef3c04adde725dd8596a9a96902776d3845b6f2aed69b60461fd388c38d5d868c45f4876bed03b95db3f0e03cfd8e3575096b3c98d5b87a1c217eee2ff93749c193ec010ff96ef358b1576e3919c1c29bf2a075876a1ddf7ece827a0234368fd17c87deca5d7b5e891f18a2033499caab11314dd6ebe331275d581ac6d9d5154dc7427a1273813f15b48fa463badfca5b4b89c1766250f1740d200291e27240a1134b6e92c118bee3c46a39f5721e150448c4c9f962caabe6656100d37198c231013c0d2c47d972ce0784a88653abbc7bc61eb35a4b2e47f94b2b22c510017c3de5e8c7d64f3290582559b11545ec04584374b17a5280e7203590243960fc068993bbee526dd183e6f0e53d9d6d4a937821085a6d35cde25b5bd5e9bf3ca442fad4800b0ab1c30ac447a1d5e186b6c8102cf6d4c0e1886fe606114f180e30b32975dab91af8579360546a4c391a877009efba1cb46d5e710c0535852f1c362c71c3ddfd684c0d90d2d28dbd60823d25a4044320da1c64d6c3323e7ae1d5916468de6420cde7f827471d68463ef97bdd22d224bd2f9e99f791a07ecf1a7149cf58c40fe0340b9e3faedc65a2b791109fb97ba975f881bf3ad01633008facf45bf06bdafb8ecc74de9a50675580dc7981a8b68aae266aa578ad028ab5c4ab2b00ff7f51f707372b392edf938085e8e4b9d4cee4264a7a686f09a9f621467de79f9983635527612bba013a085413132fc6bf65557a571c41c0bf90799e48ff2a38b659b028be142f88915105f270858049f3933e02580ccc6918a5c89f96d1f4b49da3fb1d68c58cfd47232cafe579a4211c04103f878d2730c07a6288fff8e3cb9508a1cd9b63236c80c57db7d8afedecd82b395e3723fbfd213181e1d80341532d7055b389775cd7f83340d597bc390c26ab3e948b428eba703f0312cd3b1365674656ac55a518bd52e7338b3cfa587e69eb01b4d23f3da6bf68d75342d0980075c7b2cc5bbae91aba45cc5c74eb32f5052c57da098aa66c05a97828680d760a884c795c501c35e364be0116cbb597fbd13dae889b767a3f2b4a39bd0621e0546096cf143370e50859de7f4d63627a90432199c78319e9bcaf102aa884fbc1a57c55c01b7f0273a4a7b05607b176eb779c41e03a95891cdd1cecdae20346970eea85a6ec1e4c97510a2c403b4e7ba51340ee2b09c1d90250667a2295c938009e6528621bfd9b03e56b3a59ea04c988bf8d0e0661ebccd6ffe3fa76575ebf37227b232eba1fa0ad906a6809d4a58361c7d7e65d290c195f47f8a9246b4fa3162df8df8fe9dc4ff3d5ce828396ae6abe9c16e055cffd2e49b55acc267407f3c3782e7383e31bfde7098ff2426a9fb9f827c834569621cdcbf5706ffab8fed2adc344762d832115d1d11ad958fc2429aa604b66524c7cc437e58cecbc50822144893034fa163a1ad2f9fa627233d53c0ae07e34cce76ee56d99e6d791f0c2a4cf179871c77f658dc8c731004238e6671b8c646b255fd16fc5f86635f1aa9b44bd3897db7a39dcc7122d1e7bdc2deba3e9c39364a5bde0b1d83923829ec75844fb2b9bf3d0cb0085ca9da10ac326c47c24c1a170b4a7e5afca95aaf759b66dba0c570dd0d4e1be18db98e20412e788b5b006470acf522ecff6b756345097f9c731f369941fec245500572ec908c62873b6b2c254435f82c89d9877b65fddacf01214f5279e3fea0c3a7379403cd6d968ea290072afe0feada88a76d5fe2a2da4360cc528d3c1afab83893f37846653888f8df65da54a65e754d4fdb53bbb5ecd0f2d5e973256b897744dc8e698678dbfba315b34942ffaa7e201836c7b3e3d2040f43f62f0cd7677af9ad49d61e8cc3cd608a917feb2afb73ad4875adba0ab0d96b129c967893d7f2f3660631147d66a982ef473bc108caa4582d9048601c6b77b40a85ee2b133b340b9ad4cf3ac87daccfc7f89d843037c13220fa1a6e552f3bfa1b596b76d3bba748fbafd2e83d2d5719a796655d996546d7a86e613d5a923a54ec3c6d2ec378d64a6ee8ddf89d7ff13310244a5441aeec7b3c193bbbefbc650a839cd70165aaf9d18b71b8bdb813cbb8a45fd7f20426516b5ac683c504647c808a73f663bfa22b5a1fa13f98f16cf57402645a97ccdb13b7bbd74815f25873e386dbd5b08a6d08cfaa1ea811aa95506dd33b8b10379b680d88a953684296c68407b21e9d70f5957f87d7383c744ee6c9b356d9d0dc12f056a7caed40bbde53e6e6787628e8f7b696ecb2e626817043ff95c8e7fa6db3690eda157968e293a808bc9234934cf411e5881f5041d3ceae771065c84268541046d897851947bed6261389f56575bd5331ce41b98976d264c2a714124976ecd58d053b21a2d430a7a549e01f79c85dc508f1baac73eaa974f16692ade3f8d066243e88681a22b9e7f0cb7e777c5a52db16fa82c1434ff9d41d7c056d56c4ded5912de3f63a64df41cef80142ce2c9b46e0eb94664052afe8726c190369a24317318e25dfa14922add62581ec3841150e6e6e75aeb8e5ae92230c18762c61293c2c483dd0d784ee9d1a7e4b8eb7169f36379815830c7ab48ad191098a2aaca0f02f62d93d2f115757ab61fea9f4a80cf38462d00fb902c124f2684fd802ea9bbe67d8229912c639e38bc4593c75d2076cff897c207a0be68bd7a3a6bb924c20270683de7e003ea8465cb20b02d0685899e7cabffd54ddce41597e468ed043f6d355a7d5177c8dfa370a38d13dfc052f67c0ea5036ae3b2b287d04e73f0f5f46ce8ce9595fb6eccdf0c8497ce74fd7764576bee3702019ded87c0f69be96c685554af0b0e59d8ad1fc9166e6b3f2254ad15f4089aceb092239ddef87187a6df349b5c1312f55b6f9477538c7c3c1b9c85b9eb974a490aa8053e09f80a7f6d41d1f02699e9e5952960ec73a55165eeaf3be43308f39cbddfe4147669be0ba92a2485765f471127ecb17dcb2ba2cdc33edb26475e34a1aa6d809236192f1a4caa0cc988a014c7b99761518618e174aa55345dc1afe122a48af73c2b805303b1e3ba68ae0b0fa0fda02a3915d0387c775f52aa3b8407a16602d1f7d0bfb3552bfb9a529c328e5559844b5d2844a2dcf9a3a8a90833819ebdc8f5baad9e53f899c5906369d153b1901c4021cfcb140ce31b5fbf16bc86eea7ee63eb4786529efc827bfad2d0eaca51289d2999caf4697f8971eac34186c47a588a0538cd84f313532c618dfd287c4761e69a93e9d68a74ec27b03544071233586e313eedd93715e2cbe8d8ba7e2c4acea6fd0d7b0b37f03e35757514e5032434d8815164e79201b0232bc93ae7af49dd0b1d595832e24c9f5bb57fb3203880669ea85f75ec6d7729c683699b8606ed0cef0fd90c428576c103673c34517a6012584bea871b8cf5f0daf1c14e6fcdee4e5f9362ec06da36da9375b5ab9e76308bc03207665d9f0fd0cc2c7b25d6ee44d4008390c8adf5fdb7d1ac508fb380211573077c41cf255d578946220ef872b46e79be775a6625589e5bff4d5d0a140f342c3942269c8ea54815da3e64f5cba0fddc32346493ec73dfa5bc72d081f196240acf5c75ae74b92aca7d5bfac94dc0b3a48ff23d54ed953ddfb219b95a1883b1c078e21c21f5a6b3f3745f1b9b648875e194c59431c30b9a3031182e5554ccce4736dc7e8002352c64b0d651be1fe3dce319fa45b4cb98014663d19084b9072b1596302c4043bef615ffad300abf4f04e514c4d0aee275f789705975b0755af1dd6876d2cf2c11cbaa79dbe22f4e3579374ad626e6ca635657e382f7de7dd1899e132007716f3139464ca8e493f109eb844947f8661667bbe44218f19c607d7145505e021c4d282a017928d53eafc46453e30e3ff8aefe4bc3905e5e5776862ac73a7e24ea2f0f4a43d06a2a155196d682dc3cd623d761b1de9785c5b4e2602b9598abb1409644715d42bad6cd965d18cc08ec5c5ed2c40e6ceeb58f7fa25405a28bc416b9215f7a94caa58eb270a485b9b17352ebe5751ba3cd5e5c1dbaa7626cd75bc4404ec521d50abcd45abb420b38a7e54874345d09933f42b03e6c92f3107250f0112572e7fb808f41563167a8fd21026e7c8296dfeb13b167cf1e319f1f58e5f1497a823ee20bd391cc293ca0befaef6193b63d6e95a01e57d143765144d9605a4b394ae14f33dff49677dc7e0f252878e92b42bdf2580c75d8ac58227038b9defaae76e91068e5beb2a89e5344e864d063beabf0deeaf53e77513898f5f912f7eae1c1ec6606928035d466e9379513f422cc63b52bb8faf049eab2ded4b5faf11da05f09cee7d33888b850540e0458f86139cc9c05fe25a8a739e21a34c360279382a7215c3adf4d53ed0e5349ccbbe2b1ea5b9cf19ab202e4c4184999e07a65a6f898239f1b790d4757b7956da250747afac1bc821728a10a6fe710397ad34d0cac8d70a1829a6b52b30d856c88a0e58b13ed93a8e23d93f1c729968cfd0df0cc6e71c64e732ffe7600626be4b21e1a53755bd243237da84f3fe9c060e0b7acdc72a60fd1e1d2c2a439fcf9aaf441d4c9abc326a3b7eaa35f7c9d93d3cb4cc36137d4d3de807056b19295a67d43e3dea28857f3dd3246b205c82001f30bfd66c9993157bfe7bdf77174c28c90698e1d8a00048bf04ccc190a6438875b0b10c44e55bcaa75efaf7a16cf795f2d91dcc65407aa91aa9b3936c5184a726a5a9ada953f404b0b3321a409d160191d01d3b26736d581143b4e1e99f6816adcf004cd2c25e6eda441d9cdd6c693593f2144d5d156a6e2fb599cc6b938fe94e0387ce30544d33cb02f275280ad37732d9057d2e64a055ee69f69865e12a58e19516a5873570bb3a0a0ef8cecfe951cfc278f8bb92e9d4827774eb0a8eef9fc92eb2646473ad53df30cfe74d879c67d8dcd267554f7136939e6738ac6cd5349a426dab7222b8cc9936e1e4b0a47065831ad2419d1fa83b93b0726271c99f49e1e9316386c9e0f45000568aecc197ce1a09eda5eeaeb4c0abfda260e94d3fad80113afc5dded052f265aff3947bde755bec6c6bf89db66ba4eaf3a93941e2150bde4eabb9e35b7fb2f5c2759f02d2f65d605cd6641c0187adc774ce203eaf89d9de9216ab313515ce8319355103e0591636016c1b9747c1e25f891f901e0e4d1dde761c0898c856ee07c62f960b6b6802982e7b08f5275fd89970daaa3de0cd663a89d2cb3b299e0604e0ab621581dc05b23ee2107d604852718e0c4f7e1932aca6509c67dda515087a185512078ff44d093b209fd22354723e9b8a5460cbebc55454b73bb7bf588c2b24ab5efaab982952674f340826142f68847afe22ea062aa0b9954376b97454fd91ecee1908db75b2626d0149ce9973b3df0ee1f7093de7bb776c710c62ab0662f828bacfec429b9e6bc16bcaceba0134e35520ab97e5704cd866865f585d36ad9934caf9d3f2c8210839447efdd46c236532cfa1434a7626405a0d39f32f26b25e4786027bc9517a0484e49816596d3d8d619246b437f873a050aaefd172f366ea3a574334c37adbe3f2b4bdbed3c62dd5bd7c43dd22f2df7b98519d4ff965c1b7bf63eae5315c9bbd0cf82eea690e2c3d9b6970ad02f5f5cd6646bc50461c75f21acf775d4bb1e8973390278c4d41b0909e1b725b0c5c8bd4d936c0542d3dc0dee8aaeae8d6c4e3a7f630a4ef44fea78b9fdb61506fc0bff4e4572e9911c5a5cb04b1ac5a3a4b6c0e1e5690046d3d2182ac5751c1975dd3ff940b5299e8efe51f49a99142df96821c98d9a401f41029a28c37294b919e8df647ad4d5491b76ec28ec367f8926a868ec7b3af46adfa311e4c73ae3b85eced4ec1a9a3f8f1a63cbf89234a473784586b965920088e8eb9c5928084b6016fdbc2e1d1006e6593f5682e09485de4092e91f3c8ba555f6f65b19f8189f3a0f080f883546977c2c569a3f842708746d6df6aabe96cbefe15ba8f04e5d5cb36e6d0a8086ad2db0d811ce8af537cab965fe93db697e801f179985d54722e442bee08f483a00dff8a0dddec1be3e9c6c626eb456edfd807db77e1ad498268d48421cfab3860e10b81ca8cffd1cdad9d92c1d5e00c4125688cdef32a57a16cdd0e4755993e723a982cee08c9c208a7fb2c5c6ccef7e89e8b2260e817fd6bc303c0048ce1894127c20a95f8d962ad2ca2beae942c96a2dfe0e61c4a1f4f9ca4a78e2f6991bb68d4bb8301224e127bcc731623d1384d104acd34e4e30911ca8de6ca8fe9991515451a83590267a7c982a17a4715421374950a2914c10335f22c1da03b7069d7d311b8d56a85847f8a9e45f80b1b6bb01ee1d1a581880d5d4ca0a4bca94cb47de0ad45a9af6e4bb35440a56e68b6e3a8484faafc8f88d7b3a974740c96d0b6c0ed163afea83fd9b55910d03d7f3e15caed9a8ccd9ae20310d2c5c3480f2fd6f9327f350ff5bcc56eb8dd2ce8a734b5f9012c4a82bad63916ef2de37a66e6951e7627c9d87f4ab2d98fa86830c0a89419b2527d3b79b6f9812b50d61fe0612de3335a6ec98f32a6b9eb4dc96251dbd18c16f4222ce00429b47797c025a42a710341ea3c608a60b91bf8f7def67f1790bcbe9f19633a27fd86511a836269bf1cc7e9d6aaf320c115ebe0695af849766336322f0790a583c86750c56fdd1939601bc924256df1eb6ab63eafae581ce8044891d422ebfcec372e4ba3a514a65538e34725f2f87622ca449a7fd36293484ad740822a1cd00dad5c0f05231bd8dc3193e972eae0d9a2a975dec4d859abef34c4a68afe3bcc4bfa2395d395dc2f701fd7a6ea59d3021f29530e792f2224fc64220f4f96d01602a384d226076d34d206f42e1b360a44381bff49d9555282849f71ebf51ade4721c7325110fada402013834e77658d377d29ecc72e794ff50b7db63f576022bb6e6113108860416c97c9624062b4c1edf6ce15084a7422ae578567433854ea64e41fa2db87c112dd18b084dd228a5ffd5b1c3f075c06d0508f26fc9a6ff3824a4e04abfd116c4d099144bc2cd26e5b36ec8d7292409679ff073f2320a795fec3d412e5cd64892cdfdc6e4ca7a64110291462a0e94024f76589d37808c45f12e6e7bfffa6bd7c26634b4def2f5d09daadc6d981c0be6c91f2d3848d58c3d33ea9e8551efe17e93af6de7bc445473e1d873a7a6b45ac7b23d88dff30ffbc3bea346532e4e66ea04ff3c70ed1c2429c2aba51e8c146e8d9d6f81bee4e763a66e783c316f15153cf9c996e2a23c965e18e8183c13c8ced00c9b003895c8b547447f2561f739dd7d4312bf24aff29b6f746badfde4b5fa355236ce228d8cf74c5d33a7a5a1fd719225a6c8274e9b485565d7d2ab839f87b24c7f79b6f630674f4431fbf868d4a542077fa561950ef286f87eb482307dce0a865f9677a26ad1b914c55c9a37336420880837464ec02eb258fd2bbeb6ba3c1702753348a70f5db1a2afa7c06719213ff86aa0fc9dafcd3f791a918edfdb6539b2a7c17144e04a2679a54ea0e7e8dddb5d785ab6ea0347e4f504df51f4b4e6d6e9c8be85a23f4a6ae3ae917d6005d9647054f9e4763e082593296c9bfb254edc086eea7200183d27aed0bb119eabf88d9335407717eff6f4e41ca47ef0176f52c61bce6922edbe85ecdb6ea1e63d1659251f13a4dff681484d34b71a2670179bef48b35be64bcd2ddbc1e01e9c6310b3b66874395f6bb7ca339442e6a201715855ceab662b7dabcabd9a9ce626ab9c0b8ccaf90d9e5a7b8f7e39b4de107abd1b46f374008c2043109c62c3158dd0893dd152dde23abd7753107060471c400a8e01555b39b335269c487fbe5a02f8c5712aae937d2e6dd65756f728c745915bbc0b22679e1c54ee6de63eaa57225a48edfa8196592ff672343693ba5a67be619b9f99d7d61df437c342bacc8b52573f3f8d308030fdfdafc0c51b25213f0b4fcc31c9e91bc49454e75feebf433fa1331fe59da1481978f205a48f492c57f2137f3b383c17a2caf8ad0d3f15a4814e45b5565e15d9f867940b881881fae23b67507f444244b0751de9b2ada15b3f636a2a72f4d22c6adf19ef41d3b76b71cebe0a309be5d3b3eda3368bcbb93b3ee2f83490487382834364665c2e301b913fc3723d5bf9c6411e41819ab5f7d22fae19bf81c67485270298ed64b4e13da363e1cbb64db849a6f0f39dd1c2fe063cd6cffb38f6f16636f10e6b178c5cf601e966174dfe8bf1d51ccbcc3defad4474d8699478f4d64db3cbbc44107cd0d8aea714dc4ec06f87c1de21865f6d93790c17779d0bbbe2f1123a5216b523af902bef2d6a4ca5ffc9c3d944da483b77aee5439bebef4fbf3084439ec8ff948e0346e6ae65a9e597c2b3c1870637ca46f7ee6b2288c2b477f4e32e09db1dd6185a88d9d84120972265e08c4299c5680acec8b6516b92db701b2ab36ed18a6891dfc543780ff45a81ec191437718202f97c66f3ae51fe18b4b881c5aec179d32fb7159106935ebd7e3dc39cd5e6584dab36da4e8562fbf1df1e71538bc995d5e7cd1fbcf40adaa01db5f30cee0b4ab91c8e579f70a84625bb96c4558701a63206b566f256c44a6dc22847bdec6582dcebc5284d16f6a36d92273fb739db7e56837178ae1d8393a6daa0c8f2a956580b5b0e587627ae516f51a5c7e2401bb6674daf63126c1243550e0e6a5958903dd6aa0aa862eeae780edff95a179b5e05bd7b3d9c74b5574ad4bfd6af5106b4f9aeb647f293d4cf0a999c1ff2952217e8f4ef6dfefd0f268204024a8c945e0e45c6243f48a22d1d51ad49f9d9f3994155be73e0a4cf683727b96afeaf7617559525469dbfb7c083117b5d13888cc416180da8ca1039a357663fce5b54f242a3bb8c98fdef4bc203dc205d3cbf265e4dcf805063f13a5286b404bd436f8196afe677085084140649298f8cf012d968eae54524516af04df515bacd2ee74ce37ca008c42221ac35f1bc9c4a2d12f6cc67f8ae18fec4b9d3c098e9ea5d311a68f940abf45ce0ad5e6c325096ff1eb5db933d556b5b6b3293630cbfd6d15766d3217bccbb539020a3b78a01ab4fac31aae702067101806376ce0ef2f887f04b5a2e4f52e17f22c940a6f65827b983fc90ec852ee2b34e6b171ead7373c0755a26b198f1a4529085564760896926115af82e3f3e90f14f076b0bb2a2b04a204fbd141e98d08b5377c4ca60d13c25df8a0794b6e4954adbcb02b98495fca5a2abd1cb13ab4e5aafc1ef11cfab9551fa5e36eb7a158770214983033e49884ebb0d95cb0228650e11fcb7a6d1831ec7a065c313a8d994c71a1fe5b0d4215f786c1ca96c310b44460d4071c404f71ce8fa26ffe1921f56d9ef0248b38f4677451dc22168d645df98c90fb97606176d770c06e534ecfcd21514375fe49bdf07d4eff372035a9852f4f1b0987162d4f4ffcb730b0d22591300c047460","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
