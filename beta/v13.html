<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e3f958334086eee69a37b3b2bf0f34fed92574df929369a1646ceb154f32bbe1e6f31a657e6bfd7945b5073fb37eac52b711fc524d83190f0842ad8ba2ba7a139c8c09ff4640952e9f23e8a3d06f414f98440983e58ab91ce1f99dfd82e0c8f2dec77442848290f0e4c1e795601e6f901aba177b7bb0072be210f5fae883f51940bc09edd2d3aae346545a6df256125d895436d5aba445b9839a06f0f333631937ee1803ed1873a3a089881ab5fb242e693715afe15afc0a3656f55277fb41ea0d44e50f49b4a0a93a214110a6882639c8097994823e31f63b92bf9de1d7f6c602ad6013a831299dffaa61bf1a4b7b179ee49a3994f90705015af5a7b10e40b4ab1ac21d447eb1dde0c77191ef49f5bda49fd59e49b3cb0266e12a37916b63b220bba0658241e8664d417da31c01d8b30426ba523021da673972158ba41494de46c6a6de66ee7feec262b14831e5d154aaa83afe2403f9993e7bc1e0b54c0089259b2bfd508e8a03d98b45da4d8bc788f3f716d668ad961ba0c26fa4d5274b884979bbb5b900aae762558b6472f4bf31a80fc27a50198dafe8ccfe44e1208f1314c29904d99e8bc13796b389584d83d46ee477135215b47f05fe6f5fb2f5a414aa0da2547d10dddcc29ebaadf6a468e97b3ef029f9a7f2f9bfc97b924c46a50c53605ab6a5437cae478d777a8f4df18572a967b584411e5da58889b4550984950d9352bebf05d2ed16815fafc4a768d8d2c591b914690d43fd9f4909c5e74047164f01cbc47b621d9cdd46716fd656755d74ee5c6a4fc98d670635fc5ccdd66fcc3c2748315920ead348235405a328937c3e40b5fa7b2e1c2e4bb566883889ac703c2b55d4df2a8ab61497c10c6501ec4c6f4d6f5e77ffc221715fa0b108b8a5762c47bd99cd5871c434eb3ff51feb973f8a7b554426b57a09562fa11c639478a662c18eabc2bc6bea8aaa11e75ca84141fe77db0707e33fa6e6ea0c544fc0153dff14ef7ae3012d2472aab0e5b9b7cf0d4418ba164f65ffbfd77b47489e49878a55623fa3b5eaa31cf8af45d0ee671944708815e43ca5c89d167f32364cb0d12651918428bc95387805c474627e3869c45f965d01089a1e2a0317edf9c3756d7748425a26716767429093739b664790d05d290beaef3c257bb2329dd5e806ae1a1edde81e4d0ec1d6cf4eb30726d224c5610c50b979e80be5d806189368aff0af6961fc1dc6ba95136accf6a96c8b30380a7fd5a69e0792e38c75411381a08cf1d3f362c1ee303cde6a964622436dcc80103da8d94b1c58af01a56ff0071dd5871fe11d159f7820a1251c34cbb29c3f9c4bf3199dfacdebd947eebabbcb8ee9c32d514a31141ea5916ebc336bdb64e0bdc2d82bad8e335ae33028a74fd026f6c4e2f9f673ab3c6c6915f969bad428dc15798e5d50c7912088c598e1d0a408fdda42dc4f848b09c999d7d161ee01447f209cc7e56979a1130fa20fd80ab0f34c2fb6b1cee0602be4ad28b8339dbf01fe7fad4eefbd83e0b3d7e873c7d1dcb7d6f09b64a85ee9c2731262f632fcd53a2686e486b8d79d3664290230aab85e7a696572a13c9c903317f670569758d57aab66c018020f32856ddbc7eddac2be5bdc075318e756957c5884029785e5217eb342847cc33909f5fc0c1cadd174954c43ffcdb2fe22e491c5ebdc9891be41edcc14964d1d550fa419123508eae94a108c1a97171d1dc54c7f23faf99d83949a9beffd1d2cb67f470f46d40a3f3a94026790e7a94a2ffe66df3973eb813a0d487ab6a838645532fa1768cbcc1592bd60a5ba518680b3ceae052454b08346a585eb640a32a71fd8d226ab606cb5385f85f61115736cb63a7fc97adccbec60c839cfc59840ceb735f95acb74787ba67152be7f933ca0cf3820c41e98bfd732c17cf5b241a047e272f715a5701060dbae3dd015cfa6951c9b451bd6498d4c480ac2e458a2e731e47e961d0bd3b14612d78f98e2a85eced3a7bbb5f42fcfc66840b6e6504eb460659e398b458cc666fc7bada67ed530fcff1611f76cea5722aeb1a4666eadfd88a4d59f96d0a3ce17910a44a35a93b37aa8fd5b3507628ef3db9d2054788f4f903c7a2d134aa962e952bbf132e44695c6b3b79aa9937804f169130bb41b7c15e96c5f6b80615c7d628e42d8e73722b5e5f1259874207ae4e0273a2a080cf87fcd5c2223f9061f0e366efc92ae1be72158b066014beba4f2e3c68ffafaaecb902d355c0252cfbad2ce9414c6284b0c38824b17c7c3a909a4dcb8eb90edd5faa2ff369d1f5fbf7df420b77863f6f0a26b48957195111e4333889370ee3ebb561d1ae272a9458c78ba2c99418be0b73dfcb47b332f6eebf428353f5af6dc5e91edd78c29cdee895f0c3508b63124cdc06d48e3fba3c8d8b46b77ba867e4ee6b1abe67cb0c06080141794eb073d33863c1154c48fc3ef5cf2fe51728bd8ca279176c0f779ba7bc8697bdfd5feb5fd58c4efd807f6020a8b66e4983956a189bc2079e6bf5d1383e0dd1ab12b966526b8de0ede5092c9fce9280b88c5d6ff7e64ba384e760db855687227ee9c71d7ff4237a816b89d88858d8492ea2c58391d35dca1e0ad9013ab0b0748eab33991039462e936a894d4e78d2f10bed3c3410dec6bf185309b79933a266c60609b63db2ce1013151dbf14ddc20c35f43d07981040de6d8dd2daa01a756af64c77fd6b9def2e41078c72adae80b32aebe37bb796a2c624e94ba539f5431876f6bc64906a1e964d75e42e8ed882b7400de975e28f64184d8920dcd9a19182bff31dba603224ee69f7892e4272a1b01abb058da32485e85fa5bc1ddf26354d332f263d5dca342d1ed4e5d31f1c19ebc3963742e61693bc0e239d32d3a4a7869e791b1605020c1af85a572f0950883b24b9121350384cc9cdb3429595e63e73c3754337a0ddcb3704956cd185e5709ed05e6608d2952b4d588e477c902afbe52422f52e6b7b45993cfad206888893251d14ef4105fd29877aeaa0401cf475bf0c3d1a5b84c8080cca9e457115ff701b2756408ceadc6a9441a698dfed8f97cb82f9aea978cfdaffd011c728421c9f7bb38747af00bc20b7e45266f09f050beda289e36eccdf079e6da10f8b944b5495f19b31e65a52e9ce2082811361835e65b2fd1a798e6b88a9b6d11830872ad06538dbf44288460f53c2de7bc6e9449fc4520bad4f6a01e69d1b46d8ce336295d9409e918569f331086e9e6b7719b70405f6c40d482a6baa3ce150d7110bfa32c6cb24747596a9ea62fd0caab5284f3fa0d7ead75059b9874b636d3a5d3135ce79171057478f4bdfe904de3963bd2e3009292e02503c5fdb70987a850979b18f1d2d01e21f2b4eef9fc1ac8011f94df930c792799dac97905c3d6c1f96853343b2835546d9115fe5a60414d913fadbaa2e31280167061d486fb813be96c87f58991cf7f2568e0b7b5bbe392b2f3cc41163867777af4889487f2cfcde4070835ebeed98e719a6c8cfa09b72da31bb65ba05b8fae0a6c6263c77a5a12836935ab0141e86f0a49b5b023388f84c60aabcc9257ffac9d3b6e6eaade3b57ed3300e949a192065f6955d7e4f04b5b196308bb8ba23d9f27ce3be2eb63a9bafef0ffe67609a59a3e7b23138095dcf5dde62b4272a0db5ea65c177b00beecb626d7c3183dffb57b0b4e051c04d48f54d76be1b9c4e8ee2986a2fa48529a48ca705c512def9a1d0dcc62823aa5249a60e76bc879c54b99892e54601908559f50ef53e00a115ab23476c7012d04e219fb614b2804799bb5cec4eab697480492ff4a7de26e6563bee9ef2e8eff3d6d8baa4563c5c8bd33761f94e37904b82d1872a1d04e31ecf03815331650a41dc3ac9985a2214d55950b4ecbf658ef5e9a58a7ed616aab241bc21f36f07b704a55afd5fa4e0a3805c0f950e8f95f9e35370bc67436c92159859d686ee48d8c949e33654b01c3074dfdc3d0ac2bed45de71b15995c0c14ba1c1afb19f5d89317321b1b25123fd3731311777bb33ccd31ff3a50770c964198dadcab59b701b046cf4a7ba91f5f9d0e36c8a8931902c5fcceba3911b71f64f699bd1ab0cd298efe2f19a1f9214d3e9849087345dc04832989c7cb2ec182c669d97dd4987ad5cc07f524fe18178b2917e85f9054872ab11e3bdc9e50fed0aa51e7ed5f581b57e8be171898ff31ba254229e079b073be0a30ab288e1d64b375999a279a2c4ba33cfd7c92483a46458a317ec082766678ab8e679a06f0db949b5676d49bcfde8b2bd7460c038f87095a686e758b217db091cc6ff8ba364915e52871bef71fac6e0cab31b042d8ccb68cf8f50f6659a399436279c8e2f08d7b986a76826e3f3906dae436fc8602de59dcf0a05e2359814c88d4e523d32b613f98f82d337a0640ea31ba93de7b745ab95a82a958a682fe5999c696ff9b474d957f550cd948109d5e29ee4e460ff312251fd59f7bcd77347a01f0d03c7bfc583af97865dea14b93ceb8929494773a8bcd2fa72c5c029b0dd948630415f8ae219082963dc7627302f19dfee2274fdffae2ba6bb89728b54040f4d03a14b549bfd1a635a46b188c687cd22d2661e357e54c746bc5fd561d399e049d8e2ddc6b241bbb30582bc2df2a719c9351822e573a48def3ef59e6bd9305cfad6337abfb80fa99fef4d6af07cb45d1363c0b9d63107978b7a6e3a6d93a5356d80a6bc7c5af5ece153f345b826bbc41519482c8f3155f73a40563a85479b5994e572dd26622d975d22b9fb94cb9357a756c0f378bb3c2a8915d9b47522910d705d3f6ce40af7e71f0ac7f4d7320b4c1e38a38027909aa8ebb5286bfd889f156e5489f74d05183e2bf50a4d23a4994f38aacce21b77a0eca5bfad9d979351d4856dcb8cf904ce2c98e6f290106f5452118af1c8dfcf08fd055d6af853f9c4ee2a59399564f018a7482f11bf47b7b36fe3f51b74f672d9a1687213b2216d7d724dad36d466919b1edbf102bc0712dea9c4f1f5d6440c1480cc56026dc6da94faf144ea54dac64f8c496ffd49722a4c5eae9d20c34a906b24c8d649dbfd797b6c94525744e41eb5fc56cd4c1b4d60378077a17f39e0ddcb36d8d8e8de7a4699951f3fbedbfa6748d4c1aa3c9d5a02c74ef5aba9059b4da6d9fb8221895b16662bfe4e632786eca4b7d179198b639441c57ba93e5a4881cd4006a2f4e1323c9c807223f247c79cf443cd73e3edc66049fca9f07145df969c9cc06ad454a6e5fff318e0ebdaeb5f5d41a809937f9186e8799fda479851be01c7771b9a59d101760430c2e236087f8101900243f654422257d8de1b7359076bb674008c2f4a3434a0c25eb331c076e9dae7220fad073b3218cd03e4f75abc5cac795a6d39bf99cd1489ea16b0d482b10ae45d1c7672144d56d676c28eaedbad1c30ad040cd59a967640fca826cb7a2217c29193044e1a231d2f45ba3d72ed7543dde435efea291cb4769285f18fc23bd031cbd131a9c21544ea9b48b51faeb87eba1a7d3c10405cb97d81f05712a4e20619497573bc0184e7173d503836f384a0c204c2ddadccf276d67e398c6e2e4ab49e7076d99128c5f29b31ab49fd82f5badff8643f5d00073941fa94d36652f49c2c36984435bbde1d89d5b73ab776dd677efed88ede23925dcd6a9a3d22fc466d0c53074cbc02ccef447c88c5c3ca4ea15bb840bcc5d3c94ac7e26e450e40a9b3e2feeb0fcd843c800deff67acbcbce039183f3369be44b7a15af3f7fde81fd4c3d42e60f3e655f126ba19daa1483a32880fee31ec96b929d54f63a79ddaeddf4b023cbfd5ac760a4ce16791b12d463f22d4d91b8a28e2fe0cf452a7ef3db132815f2d422b8a1920964c876ce2959cbcf26a1e10b30d2429c4b832dc4a26e369f359f5012ab9776fef0851a1b31d435740a9677ca151c7c1393ab631ea3cf129f92ddcf5e723e0256c63aeb3d27623d6254e89e50c797f04549ee34508177f567f9651e6f99ab6b9ff63fa4af1383d8d8bd5f718aa0e6f7a754724cee35f3cb78ac46a73c3d2ad705e0b8d198af93a6e6b00ac50fc37a95cbb7d221491e7cbe815e9ea43958af6ee6f97baf6e540a9435dbbcfe0908a9c9a35a5f26b8926323caf5846de8791f3d4da549bea0732553624d80e20cb415837a80d86d073e38c9c41926230808d05e54c7214b28c48fe5b974abc3bc64ffcb579569c62eda3fb9da1372e9b94c782261381f8c7ec0e98dbcafaa6e2484bb72c3ca1c258d8e093826ddf293de7f4d52ee01d48c673a974968431870159f85f8c35858473e7a471b3213861dc417afe7084f8aa082ccd9080bb5aed406346a4bbdd6e063d3f4f3206466909148188b45c9a3fa205926d4ed93a520894d69153156302f04613ea9d09971dfee238af822842c6f739ce8ef47b361518aa79d82edc2c068868951a933faf5dca7f0bd7d35d45b35188b2f81b0da1019715d78080dd437f5ee529feade4995c3cb1c07e2cbab6220cc176af06e6bac3237ce67f1230cde0d3977925f09b3e91349b0ca35df50e76fc9355e15b9b5aad608136fe51cab9bd8191cf5d297b0aceeb183801c081d68029b3725023dbdf28d97b7acae70fa3249e4242fc902be594b36ca9d89f831adb6ff921f35ba6aec3bfbb2be9ec18ac448cd3e0d93402554522ad83737ef9a640d7c8f718d5d889d893fda2763d7b9c1af1291f78decaa747e7f51c23a243c7aecc8a4853b9be94a20ceb3e255e65bb557713adbc91b5948a8f04eece836aee60499a8e9cafeb82faa503aa71016d8b2ec9172b893a828f18aecf02a84f798decd9e3d097946a633eb3d60d8a8a64a1689559af0d8e1195822dfc3ebdee1adbea496d57a9716eb8ffeec0419368c7bad3f885abc4306812fb40c12bfe593451955049f595e7a27564755f397fdf2823197e1a7e035c65b7ec4666b8fb28d25cfd5a232653c6ae3de8ae2fa4a2f5a0aba4fc2dfea24b7ea0ea651632b3432cdc14794edea7e2c10cb493e9be5c91811473782245ef0b00067e0cd2af6d97e3cc5fcddeeabcb7a6c97dfcbfb21f249c7965cf10e95b88c0ad49b909c9ff51701ad885a83859d9823d136b680d0e3f64109168e42b63e8ee490f660a7f67a7b6614dfab74f22e1aefd62c53fd185e1578b7b8268363b4bf88e9b633314e0da126df219f55b567c1c7f8a7bcc32c734b4ad3bc22d6aad434edab13207049d2d6f1dc017278a79600dac0f41a8b6e79ec2179b92c06a47caea402dcb6e57456c29c4962830e0c6289abe8a45824889aa927547a0b8065e65126f38d423a901a16988cdb70781fd4c51a2c1e48b4e8de1d602fb9a85a4e06be9996b866deb29b4d019f7414073e74acfd8c92beea3736f39e42f7c2caf29799ceb406b49bbfde4772c740005c5f7b4711538331338dc6ebc84db34117899b3913394b42b261417d9e2181909fcad23cf26222f0a85c7894fcfa37d585f7dff39d396b53123fc13f3e1787cd57b106aa2b53938f7417123e83aa1d54742b60b2359938849ac2b71d9641095236a935121a4e3e7819e7781288011228cdb450e005cd1a71865fc719c724945f1966de10ed4a0a4decc23d04b935436cd70e17d48e6bfd32a454bcdfa867e9e812ed02a7035ebe98a2efd3edf484c32a858bac29598a75cda004b31bf11e3f16b89ac159f238ee1e7710ec1eeb802e1e63e9ed6c215738174aed0e07f84c9476b01ae5cdf1b980dcf0a5513c6671cb12d1f504d25e8e5d10d587ba88ee10b037e7cdf8d7e7e73e824d985967ca47d32a3027a0790ec95ec129fb2c32a566b44a7eb445642a5f5d39713b7e989e75eb8868e1609a26cec928a49d9fdadca80cd55b98fcf063bf3b2b615a44f8809ace96d712c91292119dddb706de6e17ac46ab9b9def45b492f5050425a00f4c24292d3fd8e6e2413e0325bd195acc2090fe126fe3fb7df27577f9bbe11e06d5e5a99f9f432d15febe19d3984d1d780ba70cc1af708ad9dcc86162acea79d9391ebaec65309d588015221ef56483e081d5f379fa79f19f93ea99fe5068ec5a62af3c92ec26a2dc3976759e10d8893f39c1a78b71b131349be7d6d6f4d8414aac0b94923c3a8e004db4ed1818c4756b1b8b97ccc2d16389ca4cae6925a77d185a52ca65bfae1e832ad526fdddc2cbd7c40b8cf5dde7ea66c6626ea6dd07d6d813609214fe468b6df00e39fcb214107471e4e7704bdd842a74629855e512f946d7aaff27380de6512cd10a7a9115d4108178f4f9b20a79ba41a01f190e65c4ae9f04f9ef2401e5db3e2ad343012c6bfda7e739089e79ccd9baf57f6bccdf3058d4736497f1796f0481f2f7d6d120fb16be839369eb74dd8788a95356036b9cba2d5255bd7e7e73061c3760bd6feaf315b199cc3c0ab37957a57127beab962604cd71c0d44e1e7e04c768b27f33a4a043d5934dff37e6116835e9aa14edcc705486ce95e38a309b5fbf2ac6bb5577b76c9f05287ee44d4ca20947f79b65ffd5dcdb50ffd036e0383865c10a0701f7afc3794f20e677fab310c73dab66dc07b1ae2e3cc80a98543659f57dca7ad62e5e630483f312462732c57e4f87a90faae6eb81bb875cc016f2f6e18786b4883347824c8111635cdf2369c42aaabf01c91bdee54165a0bf15519848064cd030c04560b6a21c7854ac38278d1ba4ade4760c14cacfbb3adab18de2b3ee6d446963ad4df4b4523a6ad654eb70c579b25b1a2d285de3259efc4511e077c6e848f4986917caac8db8092791e3009b44a4139f4a1b6ba0001b03b7b6e77beaf0bc0a295b7e8f6391f7bd3cb6332b7af5b598c3bd747f464d210da7911ab7486f5a04c2d85cb4799e1eaafdfc59658b4c3cf18147798c4d2e254dc1a4e2279092755261cf0925ed660bb44b7b144fedf31e364e2643153a7bbf9ea06568bec4b2cd5e8888afc49456ff6a2fb5e8b2402b5725e151a7c49ee0423b8614a46b03e69a36c6f6816a31224f80ed5944161e4d9c7ea72668d196d987855043c612ec671242d11e5ac6801792a596fbf7e5aac4b6c54ffd322388ceec51bad2e9385aea545c2575befc90d20ec2a4731af955a3850914d601d9179ecfe5557685645e7c7b5da4092e1c44480beb00971f18f8bd5434e2408c38217c84f1185ba9cac98ceecc50ea7415e23a8e3f140a2a3598ce89b5d6f97311f3bf5e4ec4440719dd606051667e7bfce5c231e99fea9ee91d1667e641a25e9dd6f643d0208627891c16789f7b4d76d369d0107b4f613c82d30520d891cf7a2dd14afae741177acd589e37ae722b853b00667f502fd243e7778bde391401ae014f7a06c0b2c1c13f42ba26c96c3433da3f95ff4b0598754381b63513f2aa1d8b96a6e5b2a6b0517430c8ee1e843db0650ca6d7dfeb9b2860f3eb76c5961d1ef6bff922e97e5c43c8f902cb0fbade323236cfb8dcc08a86bd7a0a10dcba85ec0bd2eb5c8794b3e2a865f9f8f4230e56a8e0f1be1cd9b6065013da3d0557fb08e82e5839bfa821ef3feef95714f3c0b562b84b6b6bf7fec82a7800352a1be36f28d93f37bca2b2a344d1a40397f1f4e2bebd230fef9f6ee6aade2a1c0f1e108c5c6f51d023dda371b5d23d8c13994d0434eb3b9bad6e43715d2444dd91d302f77c3fa0fa4018e3bbe576a13579658f2b3972d15bb6c887a9693e5494710eb78e7f04b9be3e69e434195df3326def6de0f8b62a3e1745c263b68ae3724158cfc591ab1c7bdbff01a5a92b0785986f8b49f1b7ec34f4c4509a443f44c2b306c131be4ca4bf2c0b616c4ca6c196e8e4bcc75d829b2ceb8727a9f9f9445adeb37c5562a2baeb9e50de39d8cb0633447bb932d4e70bd7b0b891e76253d054e076e8bc364c6282c35e49541c7888c1dc6aa2d01ad26f99884479f0062a36b8019ff2e90010bdc916a5b45938d5587715c9282d601d0648b978055f4a7191690e621c3ebaa00b83d2ac46adce7b00bfb11d29163321ec0ab849cb487621fec71371f5c3ce9b92b30ec331687a6ad12dfa1ee187d8646b7bc6e47c35fa59b5007f5656995284f9cf3fc08be8f112f1c75e924cf7b05c1a7034245f54dbb6d5a4177852c93970580e9ec7d10bef2c63b8ef69b694f26a87f9526e7c5c75766f8c04481d9a9b230f29300acd5a860f16a8396a72bebc7153957d66ba314bd08cc0a4ace6219480d1d26c0f72199c3d0e708d6b5c38557d3ed1d4a42d5e71850d4337a31c7560d9d9dd624622dbf1d0f72770dda16ea7ec5e6973b43cfa9f30a9b9bda2c865b0c0a55335bf29bfd35cc819f986c20d32981e207a8b5b4cfcc4155bf93e54a75e59244356eb0ce41961514d1160e9020c9894141b5ecab6e40dc980b82374c8e0b79772d6e803708718acc2ae51c75eae93ee4e62279c1e95cc3ec610ad5f29eda7176dbe203918982e21cb3b43a789e727dc7325d80f64dc555c6e3e429c4bb5757253a9dcf4ab9c61e93156b7a4e69b4ba048f8e68c094bb732845b1b7af8c1d131f8c546ba7061f22054194c3541551c0c5cea1437edee102eb2168633711abecb873115c7bbb1b60a5d8939876496a551124d02fe1779be3bc134ac148bbf3233cf588065aeb8d8de746c3466917257daf0c3f59b3d9366ee4f6b6a1924fcb162d23acf0b74e13b33feb7201c48206fa7ce9be38d4d99004cfd9c8bc1a5671ac83647546f22f46cedf7d751d849a5fe26e52123fde67b2f6d005731bbd4a0173ca903fb799cbbf1424ec30fe65fa9f2e8c47530fca8934294f438c309f53c6e0369f4361b39c69f51ca33111ed4b2e349acdd974866db6530f7c56a5e219aa287bf7ec8c349599ffaaba858e296d355ec693c0c4b41537404a7edbbc6d14570d1a48449b56587bd7fff609ffc79f4ea39c1181496aac60d635e04fa29b1948d156244c84b00752aec290ecc00f5afb1dc89fa128ab0124f58a1f368c6ce4f089b6d3cbc5c2f3c5e4aba31d692f65de6bd258b6ac2ce80b70071baebd932bdf93e02d7c16206a7320472b686db5959f229a03e5c763ccaa395aabaa564adc675fb7b185a33adcf037d63dd965536d5ef4e38be57d0b5b78c1255fb2b3febf250240c35da9f67f58857385b0670ca70c230b0d63604699c22f767dc8fd67fcddcd11abf51049a4b76cbba26951af7b24de4221f901107fcd5c1f20273b5d9749c966a3f5fa1671759290e3f2246e2ef3ea12bad705aa00aef5aa403733d25a8f71cc91b0595e73caa98e23f415783c196abcfa808b3c5011ed9f1e7537174fd3f73c84a4aed5430c38307d0ab85e15fa2137f74c329f9f5ae5fd83d0b496db8d5d4d728963dc7e1d1296979e17fd481b8c2ef15fe5a13a9c68cd941efb161e40491067bef29f135bcff92befa6edbe7f04359332b1415f2190447c538702fac92ab8a13fb16090257aee4349288077f200dcaf397df3718837ebf8450950a0193a1a53d3f1b819863e91a8e4a4ea5d89983a6c315867a08a06694e03e19bbfe5bd6245f76557b7e87c9305eecb6bb654eae163fadc930fb9a4a954265b6421a2903b2c552244c3d2a76bc8ba17ae5920eb9cdfe086a637c503213b5952aa50994ec5bacb7b0550befb8cf860d4a10064a94dbe3c8d1d77a821dac0937bf0328a7f3250c2cf458ae79e7699b46461e7c403dc59e3153ece8b3ee300ea87c912416b34a99000305081f496e3767f07c7127ccb33d09cea7fd623b74905c1945180f1e4ae10a2e30f703ac341c81fd39056c7d31f8c2b7d5c63115bc3cfe1ca235f1e7dfc9ba193c039413fe6cb9ce1fd8b1e75318329643439ced525e2d0fde1b8e1f0dc511ff9727131c77667df6e4f6c25f08b085312bed265942d943f61ea77b34e7312d645b1c1ce68751c31f2e354cc6ff04ce80e577a64cdb0de77a103c802771a57f26bf1d72050ca2c2cdd04331813c98c2f0146e05cda46a835953f56fcf4b150051d8b4a3af0a7275ff95982071a2d0cfc1202d3a1a5363385e504045b55ec0c387f443df6e51bb25eded3e986df53a6076d73aa6fde1e443c69c10f593e5eef2822c9f6a104873889be27b737b9630835d0a580577c9ebc37e4d44a1fd7211ddc1136a8188cb75d67d149a73a2426bde1f3f908f514161d0f46366341fcb3f1b1f4075b0cc681550b4dbfc70b01b4b17b25d08757657ac4f7694c2ffcb2e6ba2260599c24c141c612ec8687e49d73490a5a1aa266c412ef87413df540965441e9da5414fbfaec430bdc359fa22349f9dc9a7721fb23bd4cb30aa98aa2f456e85d9c4f69fac40be0d3c3bf4bbae1054ebbde6ad3b47bcddeee386f596af4e1a511e62178cb53071f694bfd20b225e9172de1d1c902aa1bd56829da71d1748c6c3d8aa172bf838ec4fc56061da0aa18e5564d1888b82644b56d0790b5df2214d795c0568c4957951b481c6f2992a4915e6d7647027e0a97626eda98c9b660ae23e97ea18d40068962b55b2bcd7ddf277c813e2b19d6b0161829559686358e53a30a33f4bbdb508f42818fd8b20c5cad357d8c4a9af50a6b5cac82b80d1800db8bfa822d44d9392c710ad1a895095ac3f22f10ea227ab374ecf69eb6a99cf1a2226c309425e84bfdc04233c0144f51b4ddf74008c23cf3736e8b14bc78e73fd1b14e1b09fce747e262ce2e5fc332d44b9a23622b3d0cb7c09f9b58b965cd19b53b545106441c38d6257db8461bb742e569e70512cc667b54d7e1e1d981dcfe059dc3e036b9ab5790d3c4c196df9ec25ee93e6d97419cdd24c862b3ebe1236de6526ed60600d25608cda913300104a82df91041fee83dd64080f42e2caf5fc612267303d83f321064f81dee82e5883e5901578522a0141d2beebfab7c9a9c7849bcc31a88f21cfb04f4f1a9ed63749b86e8bebb38f104beca08cbc8a3d42c3c06c11fed350ec3914bb47d36ecf9f2f0a031983152c141aab582931fa34623c310a61bdd677428945191c9da8ea8b561ff48f77eec501b60865aa8f154af752dbedaba1e157bd692a26bb2d8c44ddd6f4c2ba028d0e8257ef0632b43053b49e8a4ba74597a4ed463247a449e25f060cf9603736e2e22ac494e2dca90ab4baa1ab382f3c4995c2a7cae69af35e3466ceb03fb7bbd6c450b4a93a111e96e7ac44df366ef229655feb123714a5a3e2dbe249c0d79c262379443d246fcaa094a0996b6f067897a5eab926f0c10cd1a9191e0ce3c15cb52860d0cbb5fde5c2dd6fbf10f837fe26e89b03934a728cd474d73496f4de442c5516b12fb2669a2a26b22786b80bbcb3f70d091aea4fa23f116986dbb7016fe5544ff79dc98e91218d8c63597fa5188b54191149fd924bca96fff1044ae5fd4f2927eef3815cc1565ae5e8dc37dc40fb3920e1fa2fc899abef0ee06a48815ad532b07422edc75884cf7511318dffbc1092c2885d30f0ff50603fca62158fe7bfc1ca37236ed2eba4f29a47caa03d0e9de6e7e846e0b1e053f7d30f95684fb41d4a6c8032421a27bb72a760daa5e61a39d506ada7016023a5bd6c7052b711512b74faa9b0bfa9b6e48b9d31fa701a082eab134517ae00b04c9da74c85a3315a82ef9cec080938aa9ee127ff6431f63a68bb0ae235f0f661bf17759701c6fb6a8d921648a4b2ef608e3605ee584fddb0dc09b9536dbac7695929d690c508f2156a224f2192b03f8ed9efcf1f2e7e8d9d6f9ed23efa362777602be2891fff679db3145b05b181cd937e36a5a8ceddb79eaa0e4982157e3a5412b293673d7efa9919b34ad0dc2621dc18cf8958a460ec741774facc5fc91edb36152d7e30ab15bf5d7f89278f1233f6870e607da5df8de5d144ac1ead3287134751b9b2bda8268400e816bc06f7afbf0c8eb75f69c3072b255a5dc37a85ca516638de8dba2d58ee9fc1fb0a2229d4fcc70612a02dffabc5b7d986e062e2bbc880aa06d3289a1c530882ed0b8b4813ca3ee9df635b923a0eebf683eccf14578fdc2ed9822d793dc9a4dc94ae8cb03377db71ee7280abf00051726d3fb557c75cead39fa30164f90081caaab6b31957b755eacfb12845f5c4508e5aa7885b1ba3c180a25929e1b9e4fe014f9ce1f54c03241583e276111dc2cfea6ea0485c967737eced111ffedcfec47fb6980e2d3594fc8f1732a77cfa55fbb77841cb1550438afbfafd798c307d19b2c5cd5b031c64e18f6787efa11d59cca6815c009cde3e6ec82f2875f1770d93746e476a7900c4990436911f0b7c96d0f7ed99299f6ee6ca30fed8244a721ed978d0371b10fa8b028245adc7ca96c6082b141c0bf44f3bf435d362b0a466eba572b88f580f239192cce9f84acba0ab833e8c1d14b2021808b9100f33cefb91d629f597613eb6b6473fb87a0f7f285b119488e8d092c8a92b90c18beae020d1a3410dedb502b2385e1160ddf12b2697df9a4b8b700186b9c07ba247dad5556d1737f3730fe6eaf67c0c1142a7b2f63cea5e8839e64aee4d8e8d0a8f991f0ce6220a6908619fb052a31619d09199a03ec817133c0b625671022ae25e946491537f344caddbab1dc3231fa0bb41b89a52e36ee699e689322b460c4537865eba86929a373ad45fd18b31a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
