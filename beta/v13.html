<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f3a05cb4551028875252f93013d075c9bb64544d8ab76d4bdfd1ac4eee342ae77b6bbaf825b9eca50710f563086ba81433001e31613ddb8c594b7a7db0b33461521de7eb4b16d44e75ff0e113bd6bdb0155996b795765e703d3a09baebb7266ae446279bd114d9308df8f8eda0a97340571ccb26797731f030d06de91350adc303e21940cbff7738a55c1f442c2818ba398b439d6043ebf1ffb75811a7406c4eef47bfab17c49932748e4fed892c09a01f5464320d28603b45067253d39debbfdd9bc60b164a62d5bf2b25be9990d81013c8d616983516edba6af4cbe1d71b5f78977928c464ba06a35cd5719c3130ad6a23dabc1ca31b0be4e109a9ad0df21bcb4a81a0f12e2169582237a60ba8da503e036ba6502da4a8fc500ccf5f90e23e86b348c8c90eeb54dc6610eb90d815ea92e0b08abb3938771abeabccb7bb7b6f29d82c724e28852feadea673026a3ffc4f0e00738a3e2cba3f4b0ba8cc20b91ebb688e715e99255dccd31d462dc335f8336274a983ea923bb934202764b6dd389856ddf01ad62016fcfbb5c64fb171e367a7faadd31593f3b365da01250eb06c05a95d3c9c8123287a7f54047dbe98fadcf6a558a1386a0818517651ab6263d2df11af5617512c0da96979d2e99d8ec51ac6601b879f59d09a96a14693815b8ddf81afe5aba1afe56b429e8e7442353cf0c7dbe2e4cb3d412a6601c7f3602439248f61a873748ca36dacc6a3f5aab727df9bb5c1e006b6f8403df20b1692d05709144083b78368c6d7a1703fbf947fde763cea91777bc822e67a76fa057e6f80f5dc235d7423a0bcd09cb6a2d2c75f6ff86a17262a8265e779181f50be063519ab40a27be79db67eee532d1ca2d214e50c7dccb827e8f3c0931df1b0a868fd502970de50df61c3ad199ad7d86fc6899ee6eac2d5dc33c58ab1561219db2689bd99f4f570597e86853e3fc1c0361531658c908ddab3d6fcda4514747f4424570e7286848428e1e946b14b07a312229e5b04371ab610754ff565e4f5158aa23a0d9583463e9d479f50a4d7c9b94dfb54a82593a6ec45a8bf43dd10039ab19eef76228dde2ade8833d12c02bd44cdd6534b5770f21787b2940fcb495292590f5e7947103a0fc3b01a911e271ddd3ec0f75ece4176cfa3d3c2c24e511d25b91db19e71a1ea91eeb074c4430da121017403b5950ff551b6cfef8531e584746bcf10f59d0ce27a019ffe15d78d17c0162bdb3d67296964ee87db8b0344bc5659e7c87bba15f5bc31982e58c6c8edc4f6bc2d38b59d589c2aca556038005d42dbe9f089597e84bd3c0f2d02d9363285480d8dbd5a4c3ebf0cd8b20aa5ad9c80ae26407a55d51e86e43017e1c757ad064df4bc42ccd206360af26d62e8006aca39758a42d3e1a2ef293e8994506d37912f6f50243395b76061050216d70a40dcfe171f468e69af945809d83a39845fcb915ed95dcfe6982bd82bd3e497d9f9cd5bb3074c7302171291c19026f31209ba8d5ba2fd016f03fa51b7abafff6769cd5dd6f2288c64e336138bda3ff2b776545c970951aaae64c562c56faef9fdacaeabab9bdafa0ecc01fed0fccbfed8dbf91ab6c9bdc25fd030e704ec1727af737ec67c52be79d46a98b8230d30dae9cadd3eaee41fe036c178b17a711837bc37c1efba06095f9096606c43dea09c9a6979fd32982a445c5f4cbe254d6f3d15fbf57e87a3d409d7e7d543e73b96f68532348cd77e5d307da3a98c1fb956b5ffdfa7af81a8cbe7f00971888dd1098eea9337459f276e10431e0f209ec62955e33c2f9611b51589829612b10b88990e551e00a8edf60e94478e9223f80de06d35e908a49377cca6484290797d0a2222f691d34aff6c06e75f03041ad359e953e7c9190258740d6d0365336eceb0191cdabfdf5bb5957bde5a772ec9f4293a9f072416efe945dc7b964cc3eb9b679c0499b904dcc631b9d0f2561d9bb356f47541b2a8d0ef1f9264ff45280f42556fca4361042142e089f426118c5d942bad45d5ce3ac2eff1da556767b26de45afebddb59bc7778bc31eeb1b95aa099ac69baa3aa8290b182c47ea32eb47c2ae3828b25f68476787cf4dc1f23e2e199779b036235ba21c0ee53d3f68aad638793a7e03b3ae4ba626b59848d866e30660c2956f6f185c24ab90031540bdb89fab18ddd7d044f9fad3c4968f2bfa56d994f457c8c00220f49c969e69e99c703954816b2976dc44db8c098d3c1792f6cd2ed184cd0edf12d6a15d35f4e78be3627490fd7a412a72e3503b39b7780332f96d46ae20cf4f0b5417ee6bcdc4b7e84dad62203a17e6aff6f80375cec9a748a126e9915eafa074b68518fff86b304c5e3efc3abae50f627bfdf66733f7fbe6d87e21899d6f293bc6a414b03f767634ce2eefadefd26f112bca35a3b69e3f3418557346bf4d60766c2e90f946ad2404f27c25242569bb816f04054d6741e71d4a85fd3dbae8efa8ab0b2bacc2ad3b17ea3bf5fdf57f1a67f1457793140e00ab95ea3dad1d8c895d2ef6c86eb8003041b54fe144ce63c875a3b93bcacf9c26453ad9845d5b781b4ed3c8661a168dd02648d0606f0f4a38c4b94fe6151b5b8e9b8e5b8390f637689ca599a4e34f3063f46746eb07be83ce0cbd9d39aa51b575f0aa7c41bfad327d31f7d284afe6f5d2a98f1315874788bed5f2432a315337a62a71621ef3f2977b0efb1e1801fbe91930082e77e37dcf39aebc01f9ada88433c6ba126ecb3b77da084d53e70efc24e19d9e746a745bd4140f642a848298293067e44a8a2d3a3b0e9b850f45504f3ed7ab6483ff0ddbd5ea8453802b7acc260297a46d34b66eb132cd899a46246905546f0f93027f720db82d6d87eb0910fc5440f3273a112d47d49ed5718d3ccf9f618c59a6111a5f90b485b5244f26c256336dc2344763cc249d64d75e117b80e01e7fdf52faef7260d7bbfce7d9ed22301c6eabae836e5d16eb51c924c976a30e3b9b9e895930475b9117b01f6f10983c08a4c50f0db6b43d7c7c94260afbe494480a6deadbaa874682eff2e120f758bc7e452736cd5f21586b76d28325ae7f8edc419f8f1de047693a4db0f1d05f35adf10a2bdbcda4a6dd4d3493d029f3d14370ce11d7087caa89543dea6e700d89808894521e805af9b822915135268268054b060d8d6da2371a147c59138e5b1ad7b4c6298cd7725de00bee85dfab5753543f947a5dbd7aadc075bd8d452ac5341e3a1fe7720f12bd5d6aeb3c193dfc308395395bfb516ad39779026997d7830c9ce07256b299bb842a2c9f299c78be67da6d7f42a919d91561593614015a1a6c3c58e199f2c0073afab12a1889957aa59782b91d3109fde3c983221f3466c917ddc1602bf46adc2985646fc747757019aa0fe14c1b21565d7ce3b22e614ea73c59768298b9c980ad7b4b04b6617b3991e47be0b0eb98a8b6ad063227a3684e1741108565716a040d39f2f0925d955293c85e6f95bc521b28af6bc069203ccf05a535f846b56a62ecdbb1fffcb54d00703156b77a129fda6a393ce21a0efd638152f6d4f95f4b921b1905f977376a3138602d7d520d97ce40b494e455e34ba5c92b64dbfab6dbbaf872d086e9837972fec0dfd6c74618751d5549e7ab69a3690deb281325c36e4ccf4ff3596009546cf36644e4a533a5a9db14d0b9df5861e17b1990b81c617a23207902e1f1bf449670fcda3cd2304647ace0fc033c062de3a11bfd7b60ef1e11df9e97786a88dd8d6a326776c6dcd12b6c5edc78779c09b990ae2e7236e2cd53646fdb34bbc7ae0eeb574ddeff0da5d73070d061f3d8278b080e60efbd0a1ba21df7edabcf572ae4f2855f540452e4870888fdd7ea900e6711028d60184e4ceb1b2ca23247965b6b3f6609bbe3198e725f03686b01acd48ed7e54c015263da3da1666a4fc2be9c87c345ddbd64fe25e8204e8f2fc6d13fe7c8d9e558ca18de6b6e6f384a2433f3ab22bd1d3edec0852f6107023eca6de60ff0d97ed5049a01056eccf969cc777713f1e64564a2c7009af72e32b38d51645d113bc1551910038d3a39c1d922f968f79f408f691525285f61f9628fd4741b691e1d44590b161a4536497f78ed07c8d5394626fbd6f489b235f6411486b1f27ff26614c93bf34f6e93f3b608bb2f60edc777ab464767d168ad221c7799eb51dcc2b0c590964907a071c76d0450a381319617ab7c1008bc87dff9d506dcfa25f3d77a297de6e69101bcfde4d682610abeb60eb9157a508faae9c9775691e2c67e450a33413f043a5655b3b7e39cb43639d8e103a431309ca7454121266e2c91e1afc439b83e2aba029caae63ee2a16534969f7a9be826eef300eba74db81124fb75c52dd6557df0b044d042b4738b96eca842616d3be04f24253c1c0175462730b2158661d2c171e6c790684338a32ce35d1303271ed1cdddde09edfb719bc27d23884a74c9ba1c6f4714a64b089d50bae10851262e12fadecd41cb8525a6f572e99afed7aeebc58952a0186898f9b45b25d144e0388864560df4076c228104ec9b9026efe1af0637079567faebceb78291177c12e7581b47b6bd1265ab7cc1b1218c4f5bf6efaf8502941735c4fd12eb3d13614322d8011fe561185776393b2fdf7fd22bb890ef8b353c64c6c9dedeea9a6ff93edadfc8f93d74511434b94404bd13ebff6a648eec931cbe504fd9b0ef10c306e58b5a821288d826b4a08017d7b48e687b6b4421a21be4ea19e62e315c92e4db2957fbb1ce1f00c75d1fb15c71ddd2fc5e91c346ac2b9ddf0df16b166480fb6bd6f53b66bcafc5bc428615cfa87c72f03711f1a780fc0b8bfcc0c1d006fb3e106e679e842d09b2ba23097aa4ec136aaa25b7ca9e1c0bd2258aafb55d02d54ab230eeea055ad7b385bbfa4313da4764e9cd77140f183e3353e00eab251908b66a65baeb86a2e10eb29ebe152ca6a1a83e6f4da7107fad114910aace245b27b44c786cdf715792d8475092491dd5ecb1e26f83b53b13d81ba35938edfbcab4c94d230e668856783fda4ffdb0496b4fcc6981182a98e2f3ee72eb034c5e1302225e59d60987430c1d080eada08b34f10e21952f2def968ba8eb5de82b204177ba808998749282500ed488cd286cf8a16c5c36a000a24e405bbe8b92abfe7bd08defdff7b534aa7ef01e2528a40802105ae01d5f7fe53dc93aa07bb2e363a94688bc5de17dc61e0e5fd8ebbae9c72d1360aef5360fff9e0b858e0e35ff2bc2348a01abed4923af1d1dab93df5acd892816ca5a1cd206185284548529dde4e3e2427446a72f5695c475611e1e814dda1ae2c538f55c1709f1c3723670dcfbc141b8076ec5b6d9030efa1dfa12fa1e1ba1e5507d074175bf72ba08d923b527e9823d5445881f7d10525b00dc7a55ef641dee0f7107daf900a0b829bc11ff680900e5bca7b50c25126b560a0e90462655711f1d4e2f2068f3207e4e1d131182dc8684b1c30e5d8cc04cb0125db79a00b69211a82a63a24402c03cc7fe4f50a3f6ceb1ab2d21b045b8e49449aa188f9228a7e52cf162faee78767191c59029037006dee8b226475b70865560c72c9d62a2e5b4e7fc26a88d03ffbc17c1537f284bf113162ff5cce5c0840487c0802b57a28d28b41c4c98051de31c304f4e0d563dc0d64f7de2f952f79b527fcc287eda4f28384d1dc6dbb59b91729b582a7ecec274f0b8da9f93fd28b4b6dbbfa654f1aea4aac1aabc8f1b42f09288d3ea7439beb0406de4e01ce2bb9c2738c94a091fcb3280a6c9f21f78cbc283474d68d0a862e6e9c06c6752973fdfd3b7371db00559cce40c8e9272cc1c7abc17571f9f1a6718d67b6b9519c7aaa45e041d90c1657bad0a0ac4ec948ddc23f1daee1affc870827e861ec5820d86da496c0c1f1ee08bff3a19c8249bd12d41d4657d3c5f47088a3475843f795e08bb90beb3d55494652abdeacaa853c71df0eb7794f9a7c36f55032fce0ae9bee7414b76e3347de826a5ab82b2afd258291349cfb62218bcb295210281066135b73a052a176099995b86326cdd48e27c3438547a552b97c332feaaec32f61c99d9e5d1d0a8e855a8ef2a3437828b896ae14f0e098b05fea16680baa71348f9759f45f5d120800c80df150bb16db561f859a18b67c0a037e37121d68a1da842a915b3bb266a8f5f4f6b0a71cd949c15301eed6e09744daa4fe84b2e1193f116066d744b0719401a77d2de836b2be689a858864628cc63707c03f3550e5ad69ece644706eaf4c1c14794f599689a3b6331cca38eff8b02f3a0affcae9eb249d34915a37c559300bac9d0919007f400dae82df151ea0caf75d8a706eefbfeed8c0ed9c6a4769478b84e48a1055773533ee2f9254e253c65e7879658fbaf1c08c52674a9693ae5bd67fe91faa9a98f9b636889df5a679b092b3d0bcaed8eacd6fd4e498b59bec5eb05d4babf9e511d9230a093c985c47352e1d2a3f00f64a7bdcaba7c709defaf8ebdc6aed010a443f665d71baf1546ae8cf5a3896257f3154ee27d89bb78d517c421307f0c11a41c7e48ea143d24be5154528a22e34b922ced84951d7fce08308eb0cf80f06c27d6e44a6b087224a048d80eb78981cf1e88058ad3851c4334839b9b2ff830ea1a2395e5b4e7329b43cd22eeb8c0dd03a4200efa653bd9a9108e3842ca1371ba74f69be9a85af878674c376fcdc07421eeadad81fd9c86f15e0bf9dad25f6fc289e6b96e6116fe6722b76434e6337dca8be825dded2c5362b15e5e97f0db0863926507ad6804e023152a46eeec378bcd8b4338ba2c30ce2d270960b94aa18b9668c764383009b96c229276190f7046fccbc044519f72a15514076cae3eed4c1709713497b5352912bc71ae4bba8dd08ebf2b3cf660619f7cfd8b2b2912d0cfdb005cc298954b70b33d3eb6a1994afa1f5a786c54223ba835819eea5dd6fc2403f378aaab90a1a4305d6e40b59d516ba5ba7ad349bfe1abacb196af0bec26296aa707772c84df824c3d454468c30e63530e61dcb841b0cde51ce19a7ef1c1f8d2e6f65f568c75c70e3aad3143e0c3575d94f91da9722d5328f15e95cde8b49c77fd5c5e4539f79c58cd5fa80ff08c234cf0dbfd2ee130c1c804981acce61420757bc240badbf6589704bd26b2f0147c4df42b5333b842939646f6218a5e293cebe9704b25db9e946cff8766e05f42a1e1637cb5f5c4996591005ae1dd0ed1dff29c4af9088257a2580135c47759affce61da0c31980c19e1ab424e2e135c1f26c2b6ea628b975cb3714d7228f9af57dbcabe6a67d28fc2a2be401395720db510d6495aa0254ce5d3eaee2835724f5c57baa930e4695f7ce15d9ec187a3730942d47aa025661f09c3c5e2451480accda58bfe24616b1442875cb2c5b61d8189623f1c9ae241f9b1ed77f25d27a8e6fe4a284b8af0855b31ec7332004374690e651d271b65fc63d312fb26901f720cd2bf280c38a6555a49fec6d759725a29f388bd42eff246e2c03fddcb0942218c648e8de8e7e31081811cacc3472d4ac90c2d94532e100476ad77d9456cb78b949a481238ec7d5e88b3a8b38c0e9cd61c895999febc746801100a0915f3d3169811e4188f8f488f502bdf56c6d6b196751465bd042242e17587368426165e22762dfea3b36827711fc614353fd5d09ac463b37b845917dabf3ef52c0eb1a2c799d40f56d0f0f249610f94564177d2fbec17fe5e4a1630386462e7e7e9487ac7e3615f0529039cbde281a5220b4706168b648bb19c80e94dc9c44ddbbb45f51a735e875793f8b52eadd540ef4359a40408a8e728c33a988782f0e8cb4e8d7cf9139d1ef8ebe72a6ba466b269d65a57b1ec0715f5f09f33313dc2fc68a6cf2f131810effa3c51e44e996593ea1a43aa716b41b9a954d440a3533eed9a64da14dfe4e2d4cb3fd38fc57d7f64b8514dfbb785ab4bba554974d0327d1189954d494cd81b6b27b77fe8a16bbf6fb148b1fd3dc85e4e82d704c76b85740b0e9ec04695d4f64c8d3d32cc17a29db18342f435d4709c6aba5453f1c375e2a0e0e647fad760e1be32504f68df210a0a5b594698de58969ebd7a553e632198fffbd6513540e7989a71ced18197378b6158f29a49f9752c733f149192b00281a59e29824f9f51e22b252e9a20c6ae9881dcb2d7fce63f9e1c1d9d86e439cb5198eb6c82c46aa5411a3e8dddd9ddc52b1689cfa024a2df94598e752bc5603731beb50344fceea4c5abc37549bef32a12aafc3e53ac55f06e8b58ca266601be30c933020de982264be22e8582de6ed56b568af6b2396ab6d713eed83e354f78689de77bc25e6193b71ae26227941ee4b7b36296e4dc5692f3348d68e97fbf512c475629788bcefdbe36611329a98cdbad46dd5cb344044c445a0aa7469eb785c8627bd044b2e6d6ef4ccc944b24d84200089ef85091860b501c17e19f3ceb3f769234e3ffb21df31a23ed7e4aeb0cb48c92ae2999bb5e2b621e0cafd934e1b438ab0db0d909be0b3836415dd9315f51849db8e8629dced2a1aef4a27bf8dcdf8d9c9c306706382af0f8260a45b0d2f013b67ae0693b42202d5eacac563e00c091184749344dddd643ca49208794f067dbcb0005833fc793d7a63341d348c6b0e5f6b91de5a487cc5e0284fdfa7045d03bd496df88725b6e400a643f8f8d52ab10f93a00870339986184d4297df69711d357b623702fc281dc301c6c7d2b5919a71ce53164afae14ea780a684e1eefb7117a3fccc43fc79952ae5e699fe896f717ef61bb320ff06e8d713f3b1e87861d35abc482b7f5c6638c61bacdd35678d624a76c186f6525d795c2897337e53663cdb1c26923eeb2c647b43a371bbe53f114c68e69bb186f1a09c21dec9941e0ae10470ea0d3f8a5f2b6d3203b44fab5bec836792bedb3882e8efe249a0a59c016017f8aaa5d292cd4dc4a54bdbf1ad7493dfa9e99cee8f9b670f35af9d52565b008ece91b38d76e34da4a352f3eb2bc9880dc051067138f037dc03359be1d1f997738b17618af51db77791733b899d13f6b98c486f975724e6f3bacde829f0b31df2baa9fa0c9c02485b5f5a722db270c255f2acfd086091535e25bc1658b7c915cad1f2c646fbd25b6814cf72544f7fff7a4b12941c5ed0a1fe115e1c1a037f555c2e621ca77dfbfb2c81aa3a32f02bb977b3aea9bafc3dece1b04d8688316502d91f9e4391472e4ca7b2296f73c2010d8fe9bc4f61b97463051c5bba129bf02c3b05bb716b23f632799900dabbc709b4ff8e91330dcada7635eabaef243fced78a31de5f9e569f3ae3a7bf9e0b8a8d49407faadf20bca0916c20518c41981a338a7d72770d435964d70654e1c2ebb9e5bbc5ab7e2bee12f0c82089923bed4bffc20b4af2434a337f70c63a229dbb4763ad4eb2f59e7ed3b02870949636881984dfb3eceb7c02ffad138d27bc640c633280d989c035f090e15f5fdb70ac69176df5dfc87f6f052f6f58f7e7564e77081447818c68b3af2e69d97c915a0d25621977ca0663d526f1ba5103371df942b904ebe3ca2b3b624f2cd17026f893197a78451031b32b7f468fa306b4233e39eb8e5f0d01abc95296ff33413ed5712499937c6dcce1dac65199c2e0d80e97a4b04c8d63c285dc8da0241afe37adf7d5d7342f2259ff494379fc8b6e22e6630f0424713f5b7906c94e6e5087360a0cba65e1d206d155671a47953894017b14c8af78249f8bd8428bf490ad40b96d700e178907e16eab7149b68c76abc85844e53b2294ac882b01ac1d3be4b8a5e1c777086c7d247615fdfe43a52aae3c5a87d186e63b33b4e295405173ab54c47a51fbc0c8aa42c1f30609e434130e33c4257e28370d14a7e766b36fce276a01d3bce0654f88cda60e2b0afbd3f367a19446106348b7fd4c8114a5c603345bfa0176e6dc0f6a7c701c304cdbb4ade47ceb110844633b79622163ab003d6c1d04fee0fa2a4e85d8889931fbfcbd6ed18c6f973fcc435165f26d7177b81113bacc34b90d85e17ed80c3d4101678d5de14946ed90d01cfd263729b357d5662640ddc7c0085e7cb5986b5e38a0775224d3bfddb59e5ff31855fdba0ff0429235243731bbf8c4478105a91c53da75cfa6f80784b20ab9e4adf0cbbfc6f8c9a8bb7989b03b452711e67efae5ccb22bb655b23e828153c6101b01dbcc454bdc70a5b3603b82fc0c621ca8bdbdf81b3406630b7f5c54a9c1ebcd47fec8bd03fdd236726c229fef86fb0680720f4ecad8978d4d065022df1653dfefc4776db173421a68ef931db8689843e3df18dfb10cafb9a74eb599dab90a66c1175f374bed137f67fe84ddea1873bfa910a6f5af43e9a3500b2d49d015accf09d85a2be27b27a63b2e1d64dd82b049348bf2e4e6ae627a786c05bc3e8eb4939a26d547b74cf4a254563e1a56aa11bc3c7fc3c3043dc459a51a58b04e3884c846c763fc4a7e4b33547f9765595bd3fe2c1b22b4653d7bdca3760ba3a909a9cd0c0c0bc0131dcae7c3d5fa9de0ed45c6c0aa4a810a4455189fb2cbaf043db545cbb050cbdc41033e56c02d70904abb6aa054daeb8afe5a33c56ff8e6663fcdfa052dfc2d916af2cc965d66dea68d13bb8fb340f5ae913c7368a96064eca3d904b0945aad3923ebf8b00d9b475c100ca59f79ed79e43ed1840929a0067e3b559c305d36a4dce4ac422aae923b1318eab57254d28d272d62f1713d47960cd58db9fbbd80d8bb787257b7efdb06686e93b67470e5447b2dc3a0560cc037018035e288a98be8b0d2deb21068ea230a29de20577166d57ff347bdc9b9cabf5c649b7a079b5eb02b66fb52692161d13c0b58c975f817dd6ae4a63a02db65105cbf2d313489155c69fe4517a467c5ba39559f6847eac877769dafd9b73a4e96390508cdf74d758fd9d006ad108da0e6fe4a184560822b08179a5248c7a8c394d9d505eae6afd34073d02353564ec2241a182b336a68da949e802903aa93e6198ef61dc46c9569b6a337bcc72400d08e02b05c86a81119645337339b5b3222b3a4103f4827fce455884214115d3a643d53fb90f2578485ec3bc3e23ed0bb7c3b1f6f2d5efd95a4ae64ca6515df398cf2f988918bc979e969aecf5c898d8794c2255f51a804f36a50c4e2e7ba274655b7f6ad0aa035c7c9f268665e6cc8f489add5db97c16674baf6714ab708df8ea7679aee69a5906cb2f5fa83ee7e16280b8bbadfeb762a6087d697320a86a5baead684c88a121c3450bf03d8811556c3cff8cb6b26728299c09ce3a08941178ed0dea48475704d0aec0ae9d7cab4a1b7c6af3a7ee2a7133ecef0f4d78ea34a82a6e0afa9974e4383c1f72822a69e505d292e0a1c3f4d9ac4166c9ad45ac6b2eb98b5431dd2bb706d07843ff7b206089a29c9974e99deebdbd3b2253ea41dcca976ca68ca2cc7e0a5369c78db90ebd12ffcb99c2f697d79c257a8138e3b2cd6eb948e1b9c54adffdc15604f4ba07cf9c5b2b1be8688e8da42ebbf1afb2788437ea59cc6d458d9019877bdcd0a28dcaba20108ee6739a4ce149f30243de4cf04601ca7169a6b67da675914cc3d708b641f0f288fee48c071ebab5e53e7bceeaf508721cce729712bb15e55e01b0d0473aa987bb027755c18c3205d375b3a80008684c4ce753031611858fa9dae63fd7c7975d57365e254a04f35f5fda84bbe50bbbef643cb1f2e033758b21550eec5e69dd734ac983dd77d926fc4e1d469937a74110fbd96f8a596b922f77cf8b8dfa5d21bee1ef4e9cbf58cf54de699c32f804359ccb50ac5619bba65bf3c644088bd947dd1a631b7b046840a414bb7e71ffc522abdf27a6a32edfe13ad9c1add48e210859c03d8b03fac78f9d69e6bcf24900fea0b2501f2201359bbb5b80b7c58a0112e2e3c4cc0737faa001a105ca8f52b0e41101eda96df887dbd248015aef48115e517ba02974535b2fbeaaf39cabc3e99826f59373963b3bb108cd53583e8e1c8c35754bca436aa96293f40e6a56949dd747b51d91b4c3d77a7a0177ef20aa8e82a7e87a0a926b2003c13937b6cb46b5b2470eb4ec04a9715d008ec8efc1f9a84389acf4fc999f64e94a31b9a83555e9d4f89d5dda62706378584dbfb12b463c18fabf81f06513a3d9813a777649e541ec25760f4db1a6fbf90388477b3a844a5191435c4db05c8f4b9fe94ba51d1323e06ab376ae741840d90fbd1fb5aea198ea3cf108a0c732ea7a91a518287d632fcb278657e67d9805c36dcb7097e0d5f56afce4d7d9e342853ab69676a7ee8683a09d49373fc86003cb1968d9d5617931bbcf6ea6df0f41c1d60f583ee46f595b05ce6dc53bf6b120b5712d78924f0e4871111bff6544031f76e8d240f5f117e512bd95059a19ec43e93ebbd77e943923b5f747f7e56c9b285429b456c978ae75bf1949e45320caa64c3b44098306b7b4b4f9da80427b232fb29191c549bfabc6aec28a248617433c977bae3a1eaa4dabccb66ff6c776f6091b3b49ca792d3949119349aefa5f03b4b811ee955d35f73392d0f8caa9ea779d4a0a4fab7e298b0c4984a1074dcc3845f2f421bd4eadf5163213b45481f2c6f581b4ce8029c869cbd7342442d51aabffc792f24409af4561c56f71207f3cac05ce9ee9de07d208434cecf3b6d8e497804e1e40e4cef037190748e98fdac3b52fba11df42be76aede4ab1ffb70586e15bbd74ab839433524c6e78e38b1d47488f2bef4519456eeb2800a30e5284526ad61a88beeb43811792bb8ed4852cac9ab478de90b126d0be73c285085042ab7cb8f88450ae4bffc2b7fb3bd731c0890727065180a79ec0c146e694bf05707db82466bd893f448947e82a02877a2d4c85eea1142a72674836eb5e4f377b1cf5648214db611c413e04962e218365d45fc01e00be7d896ea2d55ebb325e3221c74dd757754428bd53a0907dd3a4fccb61e4366fb1b6575a5cc2e83b1efd61fffd3a626c259d8ec3b1773a913720f2b2933cd8b0e0ced57061fd13e387dceaa7b46344e55cde25b936ca5127a90f0d2b40863a761a51069b23f9c2186fdb2bc3d5332977a6a8737a126e31afb81210a8eae9ecfbb09cb8c3dd473aa43feb387be6d7c4bb1671e992a86c7af2768d595607069be11fe84b098303503281f8336087c1f42c9f11ba3ad322090263b9b08560652a0d33ea8b3a382de0e36df667d29d8764d1f1a53b4eab11afca3f4c70b6c40752e4ecef57f4b6847fb64ab42611565f3f9d70e2c19ea0bd77fe27bce265f7b1d80e463437c9e961bfd8b01cac767b41561a35facf9a345ca1355165b91f198f4a546b26bcf8cb2e2889edd973e95b882f8a5d4ef763ee25758aeffdb6072a34f6b598d77dc8e89dc99c4ca5522717042dd6f7869b649ca6b676bde5496fa78760c953655f61f84317cb6c2f165c73e1822701a65b68778fee7ee7ebc80b2956a41aa6054f686286c72c129f2a66f85e5f1e8811c6114360c8ae8ed8bec070b1a1f43d08347706d7445a57398d2887ef35c7b3e6cbc08c57a9e843969bf7881a27c9bb614d7ad29f5fe23dabd61388ebc04fcbeeb9ae76296b8185698929a1d0bc1ed507b4cafaee2311f4dc6bf4e90b51a99bf6652f353a403dfda369c59571f7e6bc635f876f72ee6db13349e05b5f65e51712a3a0b22a5f5ee9bd60f7ccaed3754ae9c9b9096f5249dc7c101e1174d3ab976b5998ac8c75e2cfd995e762878f242737887627dc54fb6116810bc2e69880c3f1392bf5bf0412ef497a1c446b0d6d4449fc8dad1dbfef675f0167c232c11cd484b2e9fa9d8f21ac45cadda76e81fd38c699fa015ad639866699b45fb65a70e636cb0da7138f08dc6198c2eb63487923f809fcc6268349978a2b25b41975de3c2443a59d304de033fb50989a186980c65ca992b05b94dc55c01614995edb5f45c1fe7348ccd39e3a1318748c052c9d46814bd0a1afd947869a6fed477da66eead0ea6abc275a0b31608d0defb0e435356102d9e0a4b85474ee2fe3e1b55f5018aca118a1ec2a035bcc549cc29e38a91d5aaec3de125e4d47e1a1f884182c255824e6e43005753e2bc9ede3be575f0c22d7df86f7bdce75c014c4b73a70d97e3ed73203f06eda27df8f58b8e02619127e579747c381696c45692db9caa6cc676006cdb0791d1fb90498a816b611193aedc7a802e8ff566a0bc5769acd35c2acdcbf122af03a143e838b6a6e393c1c92edd679c016dc8e2398b962b9162cd1f3c70650a8e182fa280c922b5890033a635eeea760c6b1ce13ebcb66f6cde4a8b7f95862aad94830dd457be3b3039619d676cf9b4d5d5ea4233da9e7e89d64682a1738204a03c989e3a4e4cf4e362858f37057837921cafdf931cdc46849fb554786bb4aa7ecc465bcbfc514df76fa35dde9cbb5877c90b0011406906b824bd1cf31e37d1d1bf9b6e84999478367058420a8d31a78ff4468aa124f1cb143486a40967c94545b878b5891ea95a55a87016e72b38fe5463d1b4c4571fe1fb1a4a13dc17baed482b21b1b794353f62cd0e9889300a05620132d736a3aacfdd01a084ba583d0c771e6b424e5698f3909721f8129f7a71","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
