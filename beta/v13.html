<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a51bf81fe905b30c0edaec50e38093808d10086afdd29a6f80085dae9d277969fc9e142afd33ce6b48506a39a252c408bbc05dad03442568389410533d96a8c16045dd01a70156171033bf78bad6a52b1864100a3eebdb171c7be4a4466f97203ce366b8d1b2b55ae5e092ee3a8d607db01363dc7ced4ce11b8750e4e3f75bcf2deff8e378c475651bcdd31c24c9218c1b9c93b5b42334561ce1df74563a3302fbea9edf67d58b69a3528b26488dce1c3a5eebd35abfe45b3d1eca902650565454367b25b4b6c422a1d9327aa2b023d5778693d853ce510eea4c77531cd5e174ac40da0bea78276e329232e170a9820a39d329f27c9cc0e2dd048c2723e25de72dddbd5b70db04231217a3833d103be2bc0d202e0574a4b72c7fc07a49cebb4ec1048879dd2fe6c6e0fe37fddf2b48024a9490dadde8b55babaeff5ed0a6a0c8e144ab38910971601d9a16edd5710970d0f21e84b52cd8a6e1015911c5fd0a72763ac63b7cc4a3ce87db025096420aeaf3d72964c98f5594e6618dbfff6ec4520f79b9214eeff08d7dabc0c4cc926385eb735305814a098a731c485c29d964d619db04a889e8416cf15ce1766704d6a7000a94fdd1ce5f6ee0c0f51df9fdc4561f1e634baf8add1ae18e962e3df5bb15266b5c2c64d82aec3fb7e7152435664d0ff454ca17b1fc3bed5450d57331a1d30e09cda6dba3902ab847c1270767c788fa56b5811ca9db66ce958e1f2daca7052f4acb442b931fcde4d233d8208a4b0e714d5bd96528ef200723b83fca756e75efa4060aea06e8e0c020034390e8454225cab754b7d16d83644bb37548b3189eb87a375ea50ca2ada392a4efb746aae75a4e2c16e6301773039eb6d141b9d9b87046314c67b3e4bb7809015860f647314fdec8a42f8199a8a376a2f5b04f6957679415ca5581a0fbb7883b7368455eb56a5bbed3335db30ffd562c77cc5269b8d84327df5d3a28d45db4ff1789c90cdc571b63e2c0cf6da1b52898e06af29dd2b5836e612137de6d540008d02129ac55fed87fd1747821b11fe0844440cf3fc6acab6173a5c031e572f06ab59e0c440557c4984d41b56364de9d077056061982d08a6796cd1242e19c125fb39a89b3b6bdce9bd017bd89bed1149be460c7f82016e64408bc4391d928f1f1e17a53be534111f6167cb4d513f2f7715793aa75e8b8b1e1f2e598ca82bd8952c52c3b1b80c2dd2f72e1a12116b7320f596141f8b41090c90eb53c66d35a105f60ccf3ec3684ef12e71a93447b1e714d9c4c318bc54d510263ec655ac44049a39fec8913949ee79d133fbec1d76b465742b774c14237b238c1ad24da8b12cc47d5cfad76ab34d6a8b01508fed2b83ef23d347e341fdc6c4160d1fd435faf25f5c93fdc73778155e35aa9900905628b7651b13ed230ff655cb43563f16ed7d3c7e7c01f079a00b449f69e8c1636bc873c72e2599ceb3d55160eece461b4817807d073652b0bbaa8b2366dd8ad95539ea13faa8263d98a6ab96f753c44291836e7165d31628d28ca441e7250789e2c56d81b8604c594d0de6c24d8444b3cf8c4b458eb3f436d8d8b2cfb242c2876a56529bb82b43a7cad9ad7164199afce11d8281bd865e313b168ac00b1a3530b7d1f4a5a935f21f6c6fb3b2263a5d4ee182553072490771c343cbed57a50d5139171c9675d411ddb65cee31f4bf868023f882814b669e9eb3b083793f34173daeaacf0fde15ebea6ee81a07acdc7c56590255466a6205302cdb15b539947ad70e31092c49c5a2f924209198c9bd53aed44f8ec162be3253212826e745ce0d9ad20c23378ca7be972133de81005dadd4bfd9bb7d4bb1862e6340e57a71508e64e7e10a4432a1bd72ba13a8912020c784ecbd106f7bc3f72da5c019587082e497a3d5195e3583283155d0a8b042ccbbedc9f7c72c8bfcaa41a8fbcfc8a599111adf3cb35587a23cae285e57b6bb358480cf3afa08ab19f56298c70b2238497d66a18b1adf5468728c47210b8bd2c39de1c05ae5bb1a857d1ab72a5b8d9589b6b3c75fd7e6bd114f9c1e9df80861d82fe8159a5d6b1baa0c99617405a1bd1d0a9317b031bc2afe2170d82ad1b16d8a4ba37e289c228a6f6d1077499712ff3395c0a1fb26bca4e8eb131093cb5019ef36ecf941041b8763a840c04ba9979a2cb26cc1e59fd77f934d987e7d4870b39290247061d397e8eec19663585498eceacb500f0977a114c687d746352e55722e8352876b2cff9475948b626031817c8261a3356396e7434b577d4304fea798c919c52e1a4315dca8012c8525ab71e49a36c4aebf1aca284c75d51d74c234087604d559737300b1df3ab21cf451245523ca22daa4bff97870e50df7d9470c088ff049a06158cd7379a6cbb0972e58a604d4298962804674aafa66b141f6bb2b818cc77c961badb868b3d8314a07c4114f51e1566821018f1bb007638581e2ea6829eb911f3b10847cdb9545effba464f07c29fd0b7e8298471a8c64799ea27bafc7b6d3590e29236ee11b1495e69baceaefbfeded748e9ad439abed5002ceacba0b669ede89565376db5b1d238e9eaef1ecfe30f45481a5e441b1ccbe6668cb0c7f30d0da2e717561a33c52b3f3f847bd3a8e2ced03a3edc085ce10378da3775cfc64d6839a24327a60ae9011fb1f576f2d92f0a77c0dbcd13bc9b4bf28deedd9305fdc74185400ee4fe8a68a7991301c87076c82fafa6c6b2adc0e8b05b714e5a93e678396625f710c59bac2add000f152cd69e6f0226e1f006f303b9c2fa6f8c1c50888eb8f3e429a39dcdfe17bcc13bb7f5fc016c3a412e14a5542af295d279e4f3af0a185e8d902429d930c240fe0a0d4ee2805d5ca066ad7628f1035dd65228de54bb984ce44ab66cfa7a715da48d3141d3a16dcb64d9b73d43bc03aa94485a3c00bb5ade3c43c806f2a292e4aa3fd61ac98f66badc105d504f4f7161cd49bd3272cde7b42127fd7bb37101e5eb82e93df13ebac1664ae591258b0935ee989fbcbb6d0c24312f56685e0ae926a482e283812f39766e7490e509c7302752db56599fba9278fd0152e113a614e01ad1dff8ae3e7ff5379b75ed4e1cfd8139521b341a1819e02b9f21d99a7daaa04d30f22822b4d68b96a97ed91fa497c64e11dc91694802114586df56b184bbf192ec8c5216c42a8be073d52f65fe6f93557826853dc7693b54d0a1f29fbe805b1f20c48f076ab7f0868250e11da56c5f8648b08fd551fa6f530196aeec28dbc7b9640dacbe5f1c566e57d64a0b1485e0ed4edefb23c53365b282aa5908feb99345533ed0d8b29a76c6d2b30f8d82c0ed4b8c162ff32bee588cdaa4ceb17d51d60e3934da9cf54d9efc5d80349a8ff02519854c0b1089ba8a357eea068165e6de3c097cc007fc4f9c07a694273f2657f173b985448e4c049803ad4b5da32a8facf9612a83e9e75673f997a3d8dadf01c217a7500ad661d698c1782b123df59658ce18307e3b5626b81092d4924e84abf903d6ce6036c42be6d3acf68bda27e6817de051c66d5f1062700650db4e0e9a343c7ca1fb5562ce5da39826c21d38c68a3fe8662e17157e601cc08a1631b3ffc9000b64c3e5fc5a37aeabdf534a8c1c4b2b35c5ee78f2506da220ae6829e4494b5e173c940819400cd8c96bf2883bb6780c64646d3083608160d2959222aa22caddc080eedf88bb11dcfbf6c431629dbb760287cca874ec1cbe52f649f0c81a2c5379e756115d3e44322703607d300022836be3ab5114b14b2eb936e49d5880152a43fac4b77d951dafcb219fc8c044657856a9e3bf227ef4e51cd1e119f587f080e8dc95a1b8b3332339e9750c5f3a71c65bee38eb34a6be16525acb59dabd5f0dcf81dbe794331791d3352de39aaa69629dc7d031acf67023a4d032eb732865607dc5440ad3b7139ec296ae7a7133437937133f48092c848a5f81cd47a0d954c54c81a7a8c94615b33c222e7e3411e164de62325b060961d7f694d90197271d66486b315d82d00ba868b8e28fa8b3e208b8d94120826d78123ed3d6c5ab81b1fa97b16381f9db43ef9d307e4a71644a478d961f3d2c2c838268fb1ed3c86c7b863aaad6a7aaeb4ff92d977766292f9ebd5a49c155a6bcc4ac7b8bfdb6845b83c46152e6510c001761c3396021a2902802cba7dad9d10e78c31de029eb532ecc96891832dee2ef89783d9a35db064fa29ca5f1ab3f139bc59b4e3d13945ea135c4d2608dcc4949741da5aab2133e3e1fc0960b3e9b8e2c52ef870f6dbee375bfedcdc95b1722580c4c7aec842fb462c39f5e43b7dfda1b00d8902719a8af66bee70f2177f1a0fb75d440ebf2c9651e5d1b9b0d9599c086b61b5acf57e1169d64ade9a0f9c759de7a6a43e2d89bd16aa7601d2e921c25880bfb9a5f7109da7398d626ad75c965b88981ba6602f5d13d7aade5614726ce236943e68180513e08dd606fc19bbeb0acc9dfef7e5b5a55358a4561f4d46d949b4fea563f884d43897675b4660da506f437dcb3f032f25bfccb8f549cc636ff9f36d5aab32a8f72f16b95c7dc1bfb5d0c80f1bd4ac0b7f34cc48b62396178e8269ea3c71b9345a8ad2fba9921b5606202ca4a62de61c743fd4a5c8a0fe55d29049635b8d6df7b884e480bde98527c29ec3f7176345397a8a0a9ce5a7875c2be4347537d47c84188dbbaf9ac08886c83360349571b16a855f8ddb26ed8c450e0ad3ea35c55a7e54e5ed9c8672c75897b5388342e0e9575dabb4b282336bb9fe8d70a97791cc9838ab953bf85c923ade568ebaacbfccff9d04e1117dd31bb4bdc05a1a09c7ccc9a6348c971f3f3139e3096a0ff16b622e96db3c7ce1782244f8b1f6412286c903a83f7721ae7641d7cecbb2bf8e9a665aaed9dec87b33a0bc889073d1e938eaf3b81734d3cca31e51752e8b942c9296d3ad53b5795a39be643d61edab987907e2effd1de20588bdd4620850718823bc925764ac97e6bec539fceb28f5ee59f0f49070013e1c8ad580e0b3249e29341e2fbe48e7deae8289a1d3c3e832c713ab36d7c73133591b374fbf39aef77b67f3357d40e67a4ebc563aba37307c552006b22414e37536202b3ed34e059bafc010f15ec45bf5d3beb743652b73ec60b7e9896451f8cf00ff80a4d25750f36ebae5caebc41d1479dd57ee1b8951a7206c62ee3e51be228e5c9ce7f6c307db23aad2b9d937c2334d1a3a8fbc391866158594f07130396d1fc802c27ca322004ddb7eef4d4d7f0d590c4527943b5636586efe6be13fefbb23832b492879322d09799fb21af7b8733ad541ea07f1fa35895e4636fc9fbd652d47a11cb6686c4fb8bc8d2a2750a4990d3141b92c799eb6f66420e21e7ab0685b5c1a00276bb8a3353f3967c68f42c67b579ec18b2d678b8b361dfca17bd96b8d583b65d34e460cccca645f22a4b9c72af6877a7bcc7d59ff34de6cd73fb50e3f15b4e8fd09e8c0c7f1a4ab117073cd111ac66747d4bf3236c2073ee69a597ca97ea01c0caa5838d011a41f574fe1aae8373ec1adc4489c683a24adecb67f957ab75b8e7d6ff318296056d807a16d124e5f0572443c4d66adefacfb9a7bfb985e82d59225a85137467bf99cd1fea7ea58c8cb3698522ad60d40b754bdb759f5c9fe40a969eabd024728a831bdb1c730272efd26836d410a7c066351c13a8476a09eb710ef7942c8dbfda0125fe1f838604245b4640669e524a594603ffbe25306985eb2b9513890786a22ea4e361136ddf44d837911a887977b0cd4738710c6ef4bdeb21588adf7c006c3f02c69a7f5159fa4e96082c8c49836684a9521284ae6733d975e591928a01dd299e96fae96eb3ffd28cd0e86b4d85170e4e48857355328c0be874123f009fff173244a5abd5b01b0419d1901b2ee17c1effe310f8413a03e9370bf823320cf1dffb84eafa3bf76a145fb9269b19f87d1d6e852b4da47ab4370d29d30d6e3eee7ccf5e465f08e432c87f3a570d8f135b81ed1a213c813a7c29339886344dffa378b6cbe217e765fe3a04c1e8c40273458eb93d911e80586bdd7748c3894c2a88678d1c5d3f174482640d4771fba0be2163bc79dbf117ea4b0183e4fd06b7768d9f2a598f82b49dec9dc664bec68c66dacb85280c955c0d93f79815ba60a76d7143c3a7a63cad8c7ef532d3724cbce8661642f8417573897c00a2155b017d4e726a74e5de02d0762213edf01749888a3d59e53f10be810119297e75f98b9027d2ec51c642f115f3c1cbfed0a6d2afbc180dda6c0ec9c1f53310ba2069e01bc0c597c316cd704196e6c151e675fbf1acd3abb3c16b7595a2babc589847074aacc04f5569f4be58b672097ee5b92b192bed63c95f03209b23426eddba51e14146064b1b7dbcace665b9a05f8463b1f4fa6caabce299a6ca4eb58f5225ccde4a6616260bf1ff1f73c10837f61869c01d0ad5165767385918b63b8ea73d7dd612d423aefa3e21affe911533c0a00418412bf0532e1b09ece4cc34e592fb9e72888a75e94164461f490f7e7d86ce138a07cc12be9cbd0eb5a228002ad40303152950c56c3872f78a837d490f5df91de85acc4d29716fb4412c47562f30beba05f58f406e1ba6ba3f195a94763591c35354715f37d0a37ac15a91fac3036f57f7784095777319c55bf6baa8bd5f76abc7445e624a431a91cb4a66c675a67f932bfab68f198ad9a6b4579c7cc5ba030cf90931c62873f9db3bed7f9075f7c598e73ecf16e137234e702d075b6c79942879a645af6431305d0a0dfeaf35f68182e0b6a902b75b4bc9812db8a8201cf7fe1c3cff57ce3f49cc25d75df6121f8ba0cb377cde3f2d0f6702d0bb2563f75ace270a0f005ad1219c9724720849e2515a543097391b68b74fc9af9540251e69e872ab352085d1dbc2e3830f236f8b31dac09b9cd537da0cabcd054dd7110e2275a2965960f4bc20f6d794e35f2b2e4b3014d5762096dfa256cd5221bea275007c1bf3d8c96493db61ce1c0346ca5db1aea6c98ea225d09dfbf24f995da5f00e4a577bfccfb69438ac4d808424c11606947d0b03fbc9d8331f409b6b4b6896d09a16f58dfe29fb36302b644db04b6addd0975ef748b4d2dc040c1be822fc05b42a31b9fb3bc0368194262c237b016c2afd1de558380189de4a9b4ca1a7054543db3ea7aaeb3ab787b9b4bea32aac0cdaddad1a76af0e0c4954de7a3d008ad87699b7faa84d465f46841a37303cbe5c30c2d973bb1dfaded7d5d48e164fd11f0f153d87f8d4d9650d0e30228501bd69ce0d67610072a1256d689ac1cee633d49a8129d7194ecd6b2900d8e765ed372536d5d9880594a4ab2433cd25548b5149ab584797bb1e32ca44fd7ea41bdbee6b94f7421d3b8d845bc48f9d422aff8b575ed56c218cd798bb58a74e19ea4660e87202c753956570fa5d5924ced6340d1fde62adf26c1ea28e2990cac0e2ea61faccf39b5a07a5c5f0204384d6e2f5c0bb418538b1d137c99107c8479f2bc76b7a95330c6db553f1fa7df34ce1383e35c01164e66eac0d4a99038f5c17a09442460033cf929e5303f756a8a41f49ffd5ea84e03a7900c705396a388a81ff9d8f61ed8664640eca92c08e2382e73257841b29152ba8c59875e804cf99a26a019f345c242ba0c689e160cfd5437db005e00b77494761b243be47b78873f3a84af178d01d7eb48df31ddc05754b7a510c4e9ea58831747d92a62b6d8fcf2ad0e8e9685590ff7e1eadbc8ff6449ac7e1df5297c0506fa0338138dddf9ba33886ab225bcde68007c372e7bb1a3a5eca7b72edbbf92add28561f16e50ea5217e052c016009f46e32a82c5d3a9392af55e9856725fc348ad447b41c643b5bf24bfcf1ed37bd56879889ae6bd024d140fb7f9879f969b375f2fcab22deb7cd7e2bc1987ed258465c1b06bb7c56c34e4ee2f9b29dbb2ea41ee02ca6601ea4378fcf4d061791546ca5412faa6c40de23f9cfe5cb5bced369ef012ee44c736eee6811efddb0c276b8d20b91a59f9952c4f8074f14f795267eb90bf7d66db289e4aebf3769918dbc965a0a18164d0fe4aec90f6e3ebcc0c14f31326d79ab229512c28c2be9271116ef1e337e85dae4c90b83ce98bd7cead90f7d12925695084f7a5ad79018b10c2cd8b55ec14bc76f798560b4bdc98b1492e2405a006c3ac1a3583376972c7121b2c27acbbcfc214c787c5e4bdc4b1536122d51acd93981bf4f5e7cfd24553eb9153d04aabaa6c24f2f59211c5df77f7370bf7adb7a2f98b9988ca803e25ee430ac4c3037f01ab6634ea68bfeefa71c6bc7e56d5cdf6e5ea89d9437f654013e2169bcf203bea7cefc01f3a66054b85335e82fa04260091001b6b846dcf7112d659ce897a1fb864d45f998e6078ed5f00b172aa2a634decfed299849235778852b94d3c59fc4216e49952ee9bb0cc601754a70fb655049c900d018bb214bb4ecb6b4b05f94454d178bae973a0c5fc743e42bf173a832c6a8e3642e3bb6b98538a90686f3e5d56a1a2747ade83ce6b372f8d23aa1183b6a4af4c52abe1dd832d94133e5c09a46f44fcbb944fca47926f2fc056e6a01d022814bfaa02538373b79c3eb1a9dd5a688e0ef2be2539bf6bb75628ffd7a50d0c9fa6e625638d71d107e236f19d4897d271428c6a97ae1ef9fe97f7f7fe4e86001363f5a409dfe396cce485d2aeb79aaba1f49d413911a93263335291023bcfe480aa7066dd44d76e8836507b87659e2a612f9cc3ce67307a445cefa05af81e534e23a8034609e9c82740168d0864d1301545ff0f591dac2acb0781cf06605d4053e9598fb6c66ff59b13d6ec180f96478affd43287c125bdb888e7a8cfa747c78f52d4a373bd67f9876473393b43ab88666c85849189c6018f54b82efe1853b984e46b91eebaa437fdafcddbadd341d8a846fb46ac842132ae000a3f6621851194133d12b709bc4e1819d5865e3b5bf4e233eff75273991ee8a30f57601f482592ecd02a65acdc9cf9ac271abf047a04100943d97aa683847a43c3376ccc3cc6edcb2f70d08d53ae98a1c013b832ca7fcd1338e7e5566c4ad6a7c48fc1beb2d2038c181e8747f57c50201209f9ee01368d83c33e89b5bbc11cb6abd0fc8f6b7ab2f22981119c965fb65726ef75b93c006e6015c3eaeef0472a0309a07f44f93e26837da397678f4dd2f02626ad9d9513389e4379b9e9e51c1735aaf189f74fc39f3869b86f3e034735308d8796d98bd43ce819d7f604a15ef6dff73374fc7c195f1eec4d686336234af87ffd3d3342654875470f0aa4375fde9cacc10131e75bf92a074f71753cfda1f4415cd26909e08bddb8713c5fe9ebe6b7d966f388fe0c1edef3e7dc71cef1af63b3a179e66b657a8ea7d80414793c2b9c76191ee4836d373bdfd10c92e2234f4de57fa7eb4d80b8b820ba2847b6256fde7d0ca919452281cdc5c4bb5b08b2b29c2ba49ff9376a26cd17c0504067e77b738d0d96b055d9265d12af50f4c272d8ce2fdbcf6f6c761da54a693d55c1ae1ebc739b28c5e27d82295a533fef0891411d516a2e76028cf950645c7dd30ec02274b852401e3e671e179cc17543e26b9f3b559708b06ef55438d49f2890b1d1542a422a8cbf38ddc081ea6a12d24b856af0fc8f530f319d19553c34a924d5447f0e6ae4f00d18998bf613c13436477c982bb5642c4f577480811ad884c546a7595efc0a52142ead28a41cb9e0cc76398007e9dbac0f8389f590ee61e90b49e359f56daecdf6aab747ebbf2cb79124b1f99afec325f288062ba962fbaad917b9f3cbd0e5ac93f447aaf0e39ff2ce62e4a8211625b0ff40322a17fc01083727286904fe22be38bcfe9d06eccab2468c310366a661a295b4e43f1b95fefbbb42cabc408f67751a88e996f848c2786f2da5354d4f76252e37a826fd944dfdaa8a69d6143b1d76849bedabd3c3c1e4c7faba603eda17ebebcafea07f86c711e553fbbb4d9ef7fdd68b7cfbb85469494208f18d7dff4f8050c1c30a742319052ff722b90cd566225804982f78436fb8420ff96865c134e4a14ada9a15e03c413a27e7fd8d37d4eb1cbfd1948bfcf120a92c77ca2f3ef1f9052afd04c290b77ab15c32dd245127b0807f05db8c237c3b0450166dae988c61460156a4bbe77b278d7eaee9a51b10f8830b13279bef5da467fe6ff6e5748e43182a8d669af7cc2598f3f96bd0b33c9f42a830bdc6849b7d4bc605ac9ab0da0f71bf872d8382190f10a1ce4e784af2768002fedfe2c822876e3dc378b92c6ddf310b6fe83b04806eca1050fb198d4341c47cdf388322ee9d6d9595c90e29c606101158bc8594a7751ea856ddda29e559962f8eed662b0c991817beedeb1c6026e300b80b736b9294d76f205df88d5444fb29e7e0d472e2d2643f7a1def6b223071e365798bf477b9572b1e32b03f862d845ae71b0754e16eb0a33adbadd05f3c17e561fc29d6014a4d1103280c34d4d755efe6b0badd981c1a55e3da655b7318879c63d9d9a367c491cca9b3a7ae5a8a96d361ae205a43836bcc82cbbe51a6512e8595bb4775c78330102efce5df6082a103d59e4da1db95a873cbbaa6ecf323c84c950ef80e2edd0ebe5335707eb8344a96d1f556fa02977d52194ce8184189f830c4a62aee76713feee287fc3be5cb21874cd13fecaef0c89c271533c5bd6e123567f69589a15de85e5ce74d95865bb71fbbaaa3f42435e9f4ac59220dad411ab2aa34790cd5927d0b11b785fc01dabb99c99856bccc655e65f054d6f3ed75cba9e5a72e42870c5068cef3bcaa4a069d6925652ecbe21b5aaaf3f7ec279f51da52ca31cb334ff9041159a894ffabb1e4217956ea09113e01fa0d2ef02b01d81e973358d22c2e81c4d618aaf39c82a157d238022bbb39b2743969fd447503423fdf70b1c883bc2eb3f057e135114d90e86a8f190f1487b3b2df30271b01d92577fd3933b632ac573136471d653a74dc56d6f87f61d30a5c1f7be7bc106397673c994fe0e0c60116cdd3641d3358d451634bd43cd1d725e51ab0ddb10c921d90fb0d1efe0146bfaee4834925027d4d81c85b83412cf54758fd52b366b715fffe58dc55c984fff60b2d329807454b73cbc7223a20efbd82d98b3431c351f2083d7f6ad1ea4efd62b24bc56946c4bed005923fa7dd12fe85edd101c305cae144a16e50ad42abd2ca3c69a3fdc8d678e0e51dd0a721f368a8f8edd9e35d3a2e4d265eb60051313ad2ba3ddca9338de3588179277fa6df20e3df9cebdd016b6ee4bcef18ddf810fe44928c844cd9f68ccc11536228d57c290bf72cb95f155f2d21f984ae4f4d260519df1640c77f1c32028d01d60295aa2993bd34c1630ce144c912eefec19c44748eea0723997ee1a9d94a79df24b550f6c09ebe83d759d589ec81b0154eb164d4a3b7a30babdf13e99ffc082eeb0c11e40b0ff3eb1d035f83ef848dc61e05a06b715b3ef070c86ab095cf7b37b9a51c535674cadda42f537c501e0f76db9479cb0d496d065e3682649320dd1e18d47cbe8afcdb471aa24f4833814a6d415047fd05aa6c7bab42b7a0754652d8874b57a7acda4c27d4dbb1aa5ee4774f4ba726e3492dc8c4ee021f7d7098ef841b9726296dd4913d94b874291872704f7f539eec4d95b7135ce3f4d23b841f50058f99fa35d30d42ddef20a415ccbae1161ddc24273881b465fe35d02152b6eb0ced0389ab76537ff59456c411fea0458a3a6ca335df661543cf88625dc480b63e97e26dbbeee15e0a95d513d5640c663af4dd5174fed72cead25657e598c875472f04a7051955f00565d2578d3b2a1307c52af66c846f12aed92c61768606a775b36cdd57807fc0c9ac7d0c379584475f70e53948ec33e5e5010d84287930eb34b2958aadb2a10e6c475d2ce113e3170bb26dc93098e8e00b77576d0e933e6fe759b8fd5c13ddf563ce1261aea934045fcedc497b7aa87b2603aae63debc13fce5518ed4267b69e01e47fe837191320ada1b51f1a44bae7eca6edb1a9a8a11804c03ba87586c7100766d6e8306a19f880e43d9ea714330b2a42abac6a17bab4c10d1e8c32da164629e513ecb134114e2f4aca75ceb36f9580d7e24478171235ab4492228792f962d4491d1f6d86b6624eae71a0543d515e84e80ee6c17af2434201eadfe9f4b3e39838008f51517b4c1def65cdf2f02fdd89b9d941e7722215a7b74b7ed5f05b6f140745318e36f66d36521289bbe41f759ab4556f913f7a420c1ac39d088f4fdc4a75f176ce790b12c6dc90547ece465b9a131cfa9cb6cecf53c4523c72721aa48b84894b59e9e273fc39babe4952cacd76c7cc776c1d2901975c6336be3df9c0dd5ca11752446ef018d60216d075f962b8b355ee329610b83aaa38230eb632595caafe48a73e04de4d2c8a763deabad7f596bf6af39390ba6e92639efefefa32b3e93afc460f957e46d1d61a51decfd983a0c186717b6ec634e3d737c563ee6b0b662674e68cb273bca600637038d21dc8ae0c42c723be233917446f81b56738aba46eafedbf11d37439961d73397e2d391a3392cbfd2077fef00b89356db8f504cecfcb4c35393d0b83e7239db2d5b8662ca47f7059ce58807b0807f294828beb8ee6c0bc9a5311eee949e69f2194dfa1af4e3f4f1cecac5845d807940e492a8288b46bc61e3287cf63a4c22c0adc6f90fa29cf323eaf0ecbe686f465a0774b39ab7e24d912804c7577acd3cb532e871d6aa6bc2d60d69a447b84c03b5d978b44e4fbe4e4661b98bca9a0c647608a451ccae6e6d7d72262cc56b985451f2506afdbf24d92120b6707815720d920516ec448aa4e9bec5a0c16c5410e0b78e8b4d4b6b47264c05591691602bc421cf145bb31c4c6d832538eb536eed7a975240f7acb30b845436a53fa4ca2340116f058c0199808fef9797f590b3264d2ba0e8f69b3433b29d8cd1ff485c6479a59a3f9c00f312373403353f3cb6e5d5dff03ca0bff49d3f4be68dd92135af51d8ec4d3bd8aac1664c27009eb66e8b2cd9df67047e60c642c49ec711546ffbb7097aa224c15a224959efbbb9b33ccb8fb1b953b4efbe9562ed0c19d9f25098b7db9e46a7b995540ca9c47ec3be38e221d05d1d82717ff3148dd2cd1754bc783fe9f2b75f8b699c7e903bddf2380e2eb4f7f5fb60b408b69455d1817eaba6036d6025f97330cf0c4fbc69b9ab67efdad3897f1d7b8e14f39b9e3daf81b4198488bf6a202d0623a642fcb3253b0e9d0be595f8063279ea601d959f8fb7a2ab0f0ef3c9f5f1ace4b13146b20d15234687afc6854a80b3968158c55a1d671c71d6cbd7fee45419da06348f38c5175b082897c6b08446bae6fd31904980526ad9afd21d52c7af16a9e7a887a643f12d7a7f436a9f0a1cb2b3cbb0f3a6212e31fbaeb4bb8e37b50f655fab192bb0aa53c08b39c97f9852769a3c8b489b1ded6079f0d4f139ced3cb8113a2547ef67f5b28b1e871b321d0fb0f1dcd451ff8d16ab58497dfb0772e5b7b50acf9ad099e3b545d3165f3944c03f64edcab0051b95729048928c9e43120fdca7be7b3d83a88019d59b017e901f21e7e3cd1d02c53ec43e52eb2f0c84e154db6a23157cd755b2208236e947c1d4f5ce2320f8a8b504fc88e3d9334319a6749ba459f1ea5362b08efd0c566de9c90f8095a3bac53f5d554f21756e5aefab6824972e4867d218bfe51ac240c8b75d129ae30380c15c80db75d4833056821d3f64167454636e09eea1215f6cd53e665a87613a4d16e5aafdb2c3378ed349f303b1cb29f5774d2f3577a3c469676437356c70e2100e9d2659cc91e2036d042ffafe9adcfdf0350ab1317c24f0f11e63e78e96c0ec4a42749eeab1d06a9327848dd4cd091a45fb8afb88db658796631cd91da8efce5a6e912e75ec88dbd275af2a7ebff9eee110a6d89e8ae3b7ea502f657d74e05d50a9a14fff9bb5347d118d83907a2b6597f6b63ccf3a1a95195c7c439a407d183fef6f070cb464645ec219dba87a83db70044f60266d326375d60ac16226f41c08f951284e13758ea1339462168bc110f425ab0dac58b353a22679ad93d074baac55ba5915e8b0fcb217ece9869f831d946f4277cb1f79d19ce16bde8856eafeec95d6a40bcd50eff93e1ae2760f0f81b218f5849d8dbfa2738426488c250aab06e7aefbded4c4f36bd5e289e87ee899b163cb4b12421dff40a86b7f152b5e087b22c5d6444681e8c07f549d1ea39da0cf025126c63cb629730cbf844b12444831dee76de2c87c763044db3619142a0814dd3cc0b21dcf35a627f977f462727579ed606f4e1b9723607ed7253fc5bcb58b254db34205d6654a2d5decd4b08cd66bcd77a895ddb4f45cc2b0763359de9037db780f241a2b405899d72e2045892a2e084ad7926e7adf723bd663d6951101d707faf1ed469e5a683cc55b6213aa5b6196c7f5c1378ea8a791e2ea17969541a51aa981052c1380d9e975bbc9cf938b948e30194105d0bb72ab49dbdda1bb14afe94074204ed1a12ae08f7c3d324ca810b04ac1dcb343789875e96649e1c6625c5b55701a5e26dd0f70a804a88264aa5ce863c5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
