<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c22b6f298bd831cbc066f182ade0d3073dcd829e40e313e5c956e58d3e55e0a9a2aa57e2b9587d0a02ba30fe59e481ffb6d3cf9560c4bd09c87d0cde4ddb98c4b68edde536c6d66b50af44f6683a17bd2b7dd43b73ea5a3bd4fd3e89258c41e59a18bf1a49c839b5a8329129e83087be5a5fab8f9cf3d83952a3992cb5ab0be1c637b138dceeaf1f9a186a8c14eece0c0de2b5c3f6125cd09e16cb72155c53fc69617968eafabf432a53a66bcc2a05c97c9df5ba3656be8d9fda5d92fe6ed4b8ce35632a42bb9d62e9cf9ca0596b305cf7bcb28f9a385381949080b132c923368c9b6f4556e4f067bca1572ec6649d501e275da8186f630fe6bca0dfb4fab9b73ab25ff9428c2384521220ba5c331e33c3a055cdf176ebbc6ab43b2a900cc0abbc2d994803401a50989c084c08239e4b500cdf8281e72cfe57dd821538c8eab1ab3181f723ef9a67f76ca5f19ec8c513a46f5edfbc7bbd0a9b27b583aeed3c69c022128ab594817136ddbd73a5417cd7a5e7c336862ca33fd66b51acbbd2f7e38a3b8413995d186676da1728e6710d862366622796c3af0435e07b7ffb478b40a4d5b566773ffbfbf5b79e3d3117b29ea18c853dbed6c7532cc72ecc1f6a3993856af4394f9bc6424de6d7f239b1ce236ec857e301ebb14ea09c4f5807055d162f6f39ae36d9da45917840c4c0a6ed6d865c60855f4be280bb0353e9829489c1e93c97eeba90e28cc448eb832fb4a486c8edb2b3d2e8851cdc5ea3af3a78926c6ba22dd9c2514cfbdf93b89d59f9265377accd256308f9e206043002fd7f2cbd7f5683313cf6045573cc2eae048c5b0d76a100ba1072b805c6e9452f98be279ccee8f6cf9f5d305de36a7770ed3c8aa5330a5a28cb3c0a510a9eaa5fab1d4511f5d63efd4620633a2f2d9acc905685d7478ba3db8e0c7286f7ca1ffc4d1db90e45a8287677dfc125b97ecb7e799d5d40dc0fb5f2d10ae948cc47ec45858a65e21d8f348025ce6af63debd9c31ec7f8f7d13994ad96ceea9d53222ee1a452772c9fea85f37839ae8fe7450ac01ef2c14deb51d1c942f366edaa30f4bfc79b6188dec403c76dedfa150ba67973794f9f09fce914e68ba0f89c4343fd203c483a2557f6fb63170e36f00e682bfcdb6572bccf8b70bd18a3ea24b2738da2bdf79b64190274212bdcbbce755d14c6098dc950620f38952c96971aa0e8c85e7bc2be8e4527718dc7bd522ac687f8c223647b6312e25b2a3c06fc61aad06c2f34e9fa413857ea10f863d90927d9f5478d2812936279d7ba98b7329c7047367c89fd48e3373019a30d6930b3e238a9984f13c7cadf6b1d93cbe7371899b801a238f9727945d0b469e9f08c0b5bf8ffd128a217c4d30d6f48b00b9002a0f74afc1b848d47e4d8349eb0702534b76654b66005db8bdc71778ab9d80322f027936df91a6e935cb69b705504acbc16bb77a8f3c030514dde9fa86b86a8a5015c2ceaf900930cacf96c7ec5f63c8258bb708868f64d1d97e8bdae8006ce9d2f18c5767082743fb837956817859e19c67f2a557b4f24d6f80b1f8019bc7c2ee224fa346a8aeb9b1997663fe5a2bb0b05d691f3226363fb64ff9a50ce1acdd844f1dbac127464e0780d02f7cf2a7351b4d810bb4d2cf47a9b7fe6bb96cb19e866f514baceec8ba0fd263a64351c5b11a98e43e91d951b79addec5c1fe92669f161d9303950591fce8297413b7889a3fdcdbe058fdec2ee3cf5cfbeb6f840431761f870a3cb2cdb47da5af8ffe9dd2f98369858be00499ac694ad577fdcaac79b45d7f89532f8e1aafe0ed6af019c21c8ad9b4dd7f7bc9cd3ff66110bf2a67fbb9245d87f46b1e75079f45752a7cb281d2135beeb87a5172c4f110c146209f0f9080f678714ad269a376fe1e52e0dad030a7bbc5f95b23a40f6df1fc00224f33c2f881b4351b209793efdf49c71b13b3271ca8db503469d9b765d9f8337ae7c6801f66c1d3f4e46e8c0cc489f53ef8d2ebb2a1b6db6030aea0db47286e74467bbed8544bd0c8ac92a4bc56ed1dbc2144ef045011604b000ebe72169ce66f9a1e2cd3b3f3cd3d27628d4f48fb9fbda509cd5f4ffafbc624e9504d9682aa869ac815678201fdc527bd601caa4ac8b52529fec4b5e1181d7cf9239a4d2caca66dff5a9e3c94b1cc79c3631f866d285be1d4595eddbb5afa9c7020eaa2543a5c3c8fa327764299483d4a0f6c4830bba9b70e40c72a0706fcac587fc635edd291b8454c0dd068d0b4c7d39d987f1547d7842bede706a06b6514aef8b245efb33f1f652a4bc593624b94d72251eeba601efa636ad1cd6eb056326d2798f800f0ed21626d86be1cedc997ceffd2d9c14808d64df6e7ee9717f7630ccd1913b1f3fab48ebef510cf86fbc02fcdda3899222a2aec175a8430000c2a079ba7b5375fc8e8d38cd53b241e0ae407d384197dac4dd949ac17665b2b3024696cf92b982187fa174c2bdae87926ca46c07fd509eda85eb9ace40248ed2f1c0f844feed916b489a8b0cc89dae84d6bfefec074d8c042861418116723c76bedd8f1e7f4d2d0623bf014756e2464c74c30dc4413581e58ff992d126d5b4fc3c6478712974942ca2bff9f5c05d280d138db409f8602cd044a4b9ec2f590932e9b512b2235ecfd2c20cfeb141d43cca74dc16d5ccde85e9e4e3b7a6136da427ccb9eae1fb06af81d278cb3e628709876dc9645c8d99bb05ea858426dc12ed223532c43afeab4f28895f89e9e76bce9d3dc50fc68a5178fe48c50c58627ee17e9c601e4e44915b1a778a479c2e361c3775fbf04d482523ef388013485b2a4e31d317ad13c09fb46d3502df108740689b8a1ae3f544f94c827328f7f6d4791ed5050600bc661f2e78dad6597f1d141407cee013bde6f2b6ec91cdda28d8e4efb4cd69822e915e34b7fad77ebefba204598e6ed1ff045e234d1e3b31bed34ff152b2a53c33d63b423761a4d23321461cd9e2748b36dc99b6b84311c488a470444a6ab3bb068f777d2b26fafe8ed2a2771f88c41d243fb0cea26e2672aa4a9612ba34c5b9329c53b996f77a547f08d255eabc7560325f912ac1d7e2c135a3058191e496dfce5fdcd9ba6866d87751341c1a20a777c442e769c326f176c10144f45f6e047f7187d89c6fc7795ec2093501f8ba007b0c50773640a82cdd0c369aa499c5403526c0b5c777720e8429b34926d9aedc0429305f4ddf3a84243006c66a05f7a0a902b078752b3fb17cc802b3a679623d7014908fc967cf1a05ba3bb8ddafacd73f06bcc64097803a18d955d3b9ae93c094488d5ca9f862b9d6951942e6592eeaf72b3e784e155965bfc057d34a42046522fd90b4476b633d59cbc742039ee11e24061a77eee976e2be451dfbf0323e3563ed9d197f8a56edc2e0884e4c26afbde89ede9f558c4f27572a0480bb81bbf2dd0351f55c3dc6276080c92aaa17b2a7b966b15c704dc7ce138ce9adf9c374c85de39f1e2f83338af989270951d174145667c14c3b0267f3be10989bd1cc1c0db901a6f16d8ff83207f719635b86301a68647f3149dcaaa3c6d093d490d2ddb4bef26b78ab57fa4641ccceabca10e5837a1ac353633cc67a89db50eb8f8b170c250b9cadb0c806c2803746a1a026420c2206200ab8e041c4f7d23cd20e96da0c02373dceb570974fba9167ecc504ba023ade8bdf3e64fd6081b43eeb4e225f47f95da9dfe000488e68664bcdb6c923b5165195f3615cf3b45b841b6c5b316dd500795a21cd1fad9e38b8ca0c6b98fc2703a4d0ec619420da6eca429e5b150b3bfb95f93810bb5eb92c9e240002a431d80c69115d1b14de4a5c902f4a76ff7baff688d98d7fb4010168fd2578db58ef4bd1eec1a34671f54a6f943c5df33bca9bdf409ebff0e6f82621b8df1a7f948239734edc522f3129fee355283216ee411d33027a65e3f996dfd0c00f76d6188c9480253253c14b847e4e6c434fc258995c912e62b2306b7c3d4c963478211bd9c3bcbbb73a4da031f3347ee30d715e935d1b903605783340cbaa987bda85ed7591387929ca9cdc84787e6120496200ea8a09a5c80215007675ca3a5cd2ce3b19fd05d399d7626b6a8b6029596ec98f84fcbfc826d85305e358ef6da001c7a82d2483911d09314c0ab859c7dadbbceaf4afd6ae25278c497e13243eee21a4dc84cd8c09eef55b43c2f0133d6f4313c7296e2ea3d51fe7e0513dd56ef17ec2ee311a8fecfd4cdc61ce3d3a174f6ca4f06dab922e83688f36273c13acffa806718e556f35734afcb798ceebf4edcc0ee53996c18601f1b50377553a04eab623fd4d938f0e0b13f956783de82891460fe7fcc6c294f699fb57cddb556e1326b66291e0f2fefeca540f119cde6e58f587120ef47e542547a21b973c869ba3d8e8d60de0ae86ff8bebea91550ce8087d87974255b7f9c32b1b9a4a0ad34deaf64f4b05059df807176e087f5c2acd4b55879242ec04aae90a8175f2e40044cbf73b60afb74db78f2ee9dd57395f6d50e2a465398192318f93cfda66cae49b6f4461ff9889200af945ad05583bdf00563dc9d264c45ea744200945a256d4ceaf0f525efcea9f317e18cee670fcb7b7d29d68cb909a5787634c6834cdbafcba20f295c9e3c74ade717ec35474513a048e28b400b21b86d205e3401fce94d2a85b387c3fdffd9b4ee489206b5c3a4585da1217c09fa677cb3aa79205f93c278d6190481a8486c436369f16458c46af3ccd708fc03d50483bca8ddb1f5428a3f0f3b1f596cae5f1678d77e2e4d0b0202015023b530eb63a95cf508a75950ec6cf7415d7398c9653ecf80f71f2ad93223e36cf16a0cb21daff1f3306bd6e63b5935f1be3f429bb0bcc8cc02e2efba0f4dfc2fc3d6444b2f82f5c5c2e5524caa91742a41ee80bd8ef51bdbba3ae92e6b40b67eeb73f04eb199c64354ea57a25f7efcd5df3f789d3eb05ea889fe4a301852793222e3c62a2cd42b05630e8eaf0c0c21c5ef173c91f33d7ba44eabbdefd1bdcfa48cc53b1448612c725adbcbc286af2769ec42bbc119127fb10821ddac814c74fd05549f8ddc0cee6958c43a8011034ee9f9be56f7cb3303f08b1eb61a4d208c3a0786361c505d12987efdff6030890429795e75665372f693a6938f5465babb8fc80358c67db79ae668b98743ef26d2c137e976d065a3e58e8436a5b5c7af52bf7c8130a282e25de4fd2b22567626e9d72ec2bae8bf798e58a719b84ec52634d7baae0a2f2036047eec09a7056debf5469dd0a67923983657e5712a32bd689f0ccf1d1822b07b465132383785fefefac56fb6f86e53814e31ef8a4c8f8d90050f1b1d32df489497b7f13652a94911f813509d9d477c77fbd8e7268a9bba749c5bfa1f65337a8a512267a135e6ae40a8ad9527c8645b1dd4aa106d60241b75f378e38ff5acaa49bd1f6347316bd8af831cec327ab144ac4629c6eba969885411f24c60de472a507b49c4cd9c1fc809638e057a615e0975395df6005a97cc3de9530d09ff3ef26ffc44391442011651af52bbe8ef4f6d43def58783285a7512e5c565d461a085f2410be2cf402b2396f03880e07b13ded7cfb2cc264f611ae33f0acfcc98a01677fe9b1e5f7581c91bb537cd14c9bcb152da9eda09143f307fac9afcd46bbc092e9bc0e5108a3d56e7634c153e8281ecae9ed0ad79d4014fd79d5eacda0d63893e745ea6fbdff2b5636c14526abe59d69e890d8c1215b4322afae799c807e98478fdcfbccd7a670c10da4070c901ada89c8b560ae1a87137d7857da4639e1a5d09bb338f222a9c1ba477e6f197d9acb1f485b4f186f27ebf195f390bb788a95fd154ef8fb27645a839e7a0c049f6b548e1a67938f8bb87902b89015dcf3a8648e55eb7a0fb3c9fadb7d3aa04ce4b323d8224826438653f345b21dd4e30f007554f8cc6522ffe3bd787e3978d915d1d7475eebec4c81be427eac99e210fa23993b159de9a539c9860b0e4126d0c0f039f8015d2eb150af54a27d288218036be2d17b6ea8c02e0c8fe253c4d93317b1de5934246ebc7e6bf20af221abb4512b00da036c95e5158e8198bda736b268b7883ab76823b87cb73a42c61d0ac34c4336fe665a5edf79191f0d6feeddefb43de9f58e1899ef7b634f16bd870eb9bb3e706b74a531229fe6970a129d53985721e6d23a570bef935944bab3309d88a4d75d074b00e64f3671202331b61d1a9b1c6e4f5567f7e4cf84391a09570e3f9156a1f95391f6e4f74e5edfbb607dcfcedea3f15849325aadcce1eb374322bc30de4a1eb90ad5032f511c9187ec3b03faee40fb691522750a7fd1067542358e6cf8483711fac2fd8a58762617ea432552cde009d90937c65f3c732a6e976678ae2b416004a3ba0c49a79a2d28f84f99212e9e4fb1dc12f354cb87d421b2592186b4fe66da8c4596f7b8fd39a99506e635aa701bac28f3ee838603d86c912a0c45e0318550f51d3dcd8c925aca77b0fa72f23d7763c3bb153ff6b56c7589696cc81027f7774dee684c6ded8f059761610a86ee00a1a413f5b4d11a742baf65abfb39c9828aef0a27441c6ec0d93d3c41824edfa1bd4626d0efbdf6b32f629f2d4b7732174580bd26053266a44cd369a87089ab5d9cc169bd8b97d63c76465f31a709693be75d5f0b70d110768deb67e9bcfdd8dd7324fdf0ad548b6ffc65efcb1e67a25b5f5819e9e1a02927d88ccfcbfc167afc392d9392b1b9c12ce66d266825e2eac4acc0440fd0ac75f9b757749d67e0aaa33a53ed6ef379f28a10384a7e4f0156d51394c8bd8104fd858deccf7274f45c9510df5dfb3aa2e010f95d4ab87bd383fd8466d29754df3c32eb3c9aa4110bc32a4560831b4c55a9687061d216b9a0694705884298a4f68d9e318ef501fa998f75d3b718bdfa07c3d7ad848cb19fb42af4e7bbf2cf2f5738df04cd327c436a362be0cc7d41ea8e72a72935987b8b7f9834206abbc8cd2969d9c3ed9fe29ab965266cde6b5ebf13238a1cfd1b4bd1bc57525b6c69e95c157b4aa737aa63ec6a0edc71a6b6ae92999020a58cfa2434e64241998aa9836bf76825a2bcc62fcd3a46dcb3090d730208351b99016805fdfba283aca3db2a00090127efe5d65fd3883d0dd84a5f56c563d1eb3dc8fa32620765864a2e9f375c04e07317cf15f0e7c6e70f1a66de8c9e522517cbefe9898a323837e1cdc4a5dec61520b320886b49eefead0c0b9a40898543b4681ea4d33de22fe2f84eee5af57779c30579e6f9487f0b899a6ab54d8bd30b630a0ca1249b999470ce874033a50a091b28b9699fcdbf25260d2892a6b1bac4a351714837376f97dcc5ae98f2987e2ad2bdfd83a36cf6e950cf64c622f2266636730adc9400ad2bd38713376541037bf56b591c7322572e39848f2ac4f9e2c1a37d46d73092b82240838df9450cd3be303b415311efeae9738ac88e63f8c796de85dac92346b652e027f56517fe5dcabb1772273bebb4a0bd7f5fdd53901f3fdf7c3b9d9d3d2e51ea1d7ee5c29e30f2fc721dd3ac0084aae70292bf8949ceaf782273f253b8149e89d998f66606b7b54eef3126d67d784de953f095e754e4ad915c33b74885344f79e484de462f0d82eeb69ccd86d50034c612b9664e718ca4c32a6b6674d2c18b858a6bce99d1153e897e771e5f4dd57826489cd4e99ea1eec5026071f509ddf7bc6b2cc5dbf74c0ec388204122e42ae5a94bc8e007cb65c8944dab4db646507bdb8e4684c5c8526d68b7c5463ba245f94466c8255337e38f48864f86128f1ee872adc7b3e33c1e9673e4a6bc7d427343ab5f0646d1680b72e37e9bdcd63a93e37b654706238916d221d824048d41131b94e297276c9421caf261d6f1b19f878f65e24b9cac76e3f3d5085096fa4511e20b5ea7818b2884f43003969efee7cbc218dc63fc12099fac304760f587fcf9c5ec8edac68835c195c8444338d9ca6c45baba0423b8e4c0f0547a4268fa16d9d5533b78bc1ffce80a935edad6f71b3fcdcd3b48a5218b72eb8d3730d9417da8c2f327bea1139c3df97648b1464fff4fcc37d172996c07ce2680238b8e170e0af30935fb1a73ab336114f7a2c62d537b581ed67ff0f191ffc18ebf0102c86909ddcf1f9866cc4e364b949dcbf505d887ea92bb21852abe9745804340ce8a1356262c65efb9c5700a32d2d537881b9ae20e078aa1a2a3c73b0f05344d8b88bdc9fa5725ba3fa22a4c12ced14115c5b74a6b03364d5e71a7f7dd1c01ee7b567cecd6922dd82466cd679e2c6e1a2b4154bff43783b41aa3b0188683202184a510dfe242befbd05e2f4eb69f6cb6677d18f3883733ebf6d786d0c45b7db630e2b455ca61231691e847e6dcbeae30c88d2e3d2a877a1357664ab35add05a1652c3eb6091d313f88748eaa6a4ba4f9bf24e9647430d9586ee41641fadcbd32a6151258acc8fc5e2e93b22a07ff1c14d41a94f4e5f64f73e18b2b4b0a3fe1c5dea15ce69ac33db7bab7ca8303c9b2a040ac83b791e093b78fda1f1255ed6d2b4ee9c3132e01a7163b0501ba746a2e9abfa2dad24f5d99a0a564df42e8da743578763f96a237e989a710d5967d77e5f6bf409cbb8e2187e848f5c3f03e639da8e814363860148dd6ae3243e6195d9e2795305c6abb99953182385fce290aeefc100a4973a34773d3b0e5f95aa0abe4cb728748640801a3c45bf4b8e887a5e1c0f335aad4091e2c5bcd129d209904c071aed4e7557a217dc961f6521f7ae8ebd6b03612ed846c27852c1041c24f21ee45b32e94ff98cf70fc261b82597fd151a6b032a9875a3dbfa47777cb26c9728f0556bc8e21b5e06a8ba48d75602089bf580778338098c4cd0797c10e14e8d1289048cb40af8d71a2315e1cd663b043a218e00aa6859c9cb785ecc5b2a632b4429b9bee0d2c55f86e5d70f51416bcc76cb0ef7e245f16ba58047f777d20235c50a40b8fb2f76a0f89c6eb9a2e95889857e0a03df907bac1ba9881ca4238c3c3fc603a5f695639099109b62a8cc234acacb15e398504c71a900b902fdf4c372d523b6b3cf195047a1a7fe530d21ab259f0afdd7b9bd1fbcdc772f1bff45184197f5724c028c07dc22c3c8c0a22454a22178d09aced064110fe3985e1777a8a327a37eeb8208a497a5c568a1207f19cc955e06c7e9277e0576a80b10ed852cd8a1bec2010bddafacc986a5508e240d1f80558abf3911a53add6b6dcabbde7f30e80de686e4c31512de50d7afdb452c718ec16dae0a6408141bb57d0832c14909de6483777543c85f374edf86b9f24b1598b82ab85b35ff1373e688a5eeb281f1e63d4bd769e86493a8c50942c5b9597017b6148c91865e0f79e0ecd067c99e501211c75b4b1816584eddb7338a8774424d0944966808bc1d803964db20e096e5370a845c13cfc5293793a7584767b35755337e722e6ab7d858f2977b29bc4d41347d9b9797a54e0071aac8c57aadbad96d6f48a28fce2cefd55c2e3a1bc8e50f9bd268538f8f0d2136311ccd0acc1a30173b1ee91a0e4bbe68d8f4fa7bb19061bd378a74e210767ab1cf7baa03fe5c262c8ae5761450952048dacbb9231b7614408ae3c1648264aaba5f36f1e0545ead8bfd8fa25e1b4c1a796fa08e0c2e25353b0108db8d93e03a0c91f04eec1e28193db04e5db0281b7f6205124ca0501eadd140ce6b20992e5049b423e372f785d0b7ffc0827dcae9ace8aeaf156a08be09712be988c90f7d41b34df0fe75c3cf2d4fb1c3052bc0279e43c3da0c6d0a8cf003d35ded47dcf4118b7833744d6752eec774002d8d29ba585a2a92b3e561895b5c48e23631cefdb9d956ea655b9e132fcfdc7b42ac6e5d7a09f41eed9d6264072cacb70f290b79b50db468adda3efbb46af4255b9fde31fe573a7765087911896e25c2e8e284fd4c3191148da77b35a2c4fdaf423ddeffc4717a65db38ac281f9b2f3d5e9aeff137c96dd0b1e78c41bed3915f550d0a52dd30241ee38f2defc9e586ead9385cc3f68c5560b8a14f7e5b62e8a62ffc87f1fb39741ec57f5c93367e7bc4f7e04cb94ab8047bbdf8650ab45de79849beadc4e818c29bce681fbf7ec2fddb57008e8d640bb64eca1f70532dc91e9e15ed7ceb92972d1145134daa7379320485500c63085e75f39fcd3d96a9d517b7d578be128566aef4ee7b1b676920401e539f88b940436f69c80a48c1fc8f338e2b581264a488161f657879a6b0a6d07e2bbbd966ac5a0004d570691b620eef9f290f5ff182212410a14c24c6737e9595339ad37044667090ee2b5433193088d4a349c81c4b705478a19607f29d9e5e9e8d70915a16275eb60dcbf2547c7ab1f25cfd45941cfaedcbbb7623e059af8a40ac7c6212bb09d44e9f7ac26592f20b3b4ce86a2109c4275fd4c95d7601f2efcf29f095e565159c68bf873001674e3628876f555cea7f1dbbc40da72fb62da002dc561f219b8200b09cd729d48adfeb498c7e4570db5b8de19cb33a1204ddfeecff26d9f0c2a2b25aa8f5f284cfc377b68606bb68d0b6d8a10e0144d79ae7ba83d3a4b54ea6ef25c17ff36a03e426f1fdf902648e06b99903a5b886bbe4b154178e8dd3e6532b47edc928f819301d84db08207528ae02c0758e515426a1bbffa3a473d29dbdf8000526b4fd032b145dad18b766b00d60c780b0fa9de30bfbc388d91ebc9a24041b6bb44d173193d7748601a02d9972b99aea57e1ea0612f56256a2008ca97e90ca5d8b66e92846a9cd6b8c103bfcda2bc89555bf1d80488b65876eddc4461ede75059ac3db3bf85a6f32abd7ef6fda04589d93cdd33eaefc68fa69966166c1b037a31ab08a2b7de9b5d7387a52153b752dc3f56981417af65e8893f71917368f3dd678772e2353d8e65ec897f548ae00bb974c0030a7d3400c36a637a29174aafa16cd28f2aa2a9788382906f57f11ca9347ef6271d8b6bc5a45f78bc8422c54603f926ecb721fbfeefe626597d2c310af954e749825d5bad064bf2559957dcf51a89700733c34fbff71796295c541b99f8e2795108ca7e4865d7469255c8c23572464892a85ced9b28c28da2989faffa0670717970c2cb97f422bd8afaba7d2a18cbb96d215f1656cd799c25d63a1c25333e1db437e77772c42fc8b97a5ac8d327b82c06def9a57a3bcc41688792626acbbf269a293cdd4478f39b917d81b800c6c34464688afd64c0c8d895bfc416e9e5bd5185ad62b18ffdd2e066d939c112d6fcf345ddd5014df1a7794f706bff83bf7582d547edc1021d2b069744af3e7d24813c5faa52faa73d5f44a26cf5d9717f3b4cc0104d9e957c96c417c1bef86c16d21bfebcd49b208c43ab772fa9c37ed3937692220f71ed7c08625276fc8caa2c3c7bb8835a100f3da86eea91de56a44f3fb78c886c0ed1bd5c412d186b055097082214074f5272f73c88a4f097c10df503ceef041ca94fd570a7288d5513c73122f381cc490ea30c9f5d0677a220eaec24ab8a97016bbedefd7af23e52381d25fa1703c7f682758117abd78d5166cdc6ea3c323c757fe0b46e3e9de73e93f98fb433926756237dca18327c315ad6f706d0cd81bb2bbaa4223d858dc3dedfbf74f0feaa12ad0f4e7b8bab14123e1f5f01225d967bc9e035578b77efecd3e0159b1f2b0c0b1de897cb3b520f0eb865ddb4edf4678a0fdf85404e7c85f0db679f6f1f671c99f053a6631fd012696c3395283d1e661523dfe985d72b944bf5fa06703449607c923b8dead25513a6a658257d967820026e65bea698321c4d526c0c04bea5d878ce7fca3617024c42d45c564cb2a7622c7b853e993bc148e8000a39e9addee3a27a613981a027d10f1ed51dfbdb3c7a68067255eb6257cf7ddbdc26891652c25654b2664395a1012745bae6f7259c231ad23958ff282c5e8f3e2a812baefd7b2edd74741b273d547c7c9c58a5ffecfe24219246877f530079a65fee31ab3fb502d5cd4990b18af45ecfdf007885060049995b3b321fb64f377b9866a93c560311d215ef3ed9ce04be69df59268dcd200b4f35a012989247eeef709110e2f7ecd761fbf4304cfcfc625ca85fff424acd3a3cabd40e44fbfe68178b5f268caaef098b6630514b3d155e912386185e8a6ce8b1e6e6c2af12a53a71cba302cdf32d24f8f3d7acf17d665bb51ba600d5de984b254bf6b118dbd2d49d51f231e6d86cb5da60c872860022d88eda704d3f36a01ca53fa36011d891123ac4d8f9ea1652d706079d44c549daee0a6fcc69df526654f18d720029be5d32a35fc0ee07d4d3553ee49f16216428861b86d513f8252270139f6c4298f3b17aafb3bde7c8b20fdd3b8d0ad0730084c9e6f314d48978c2c7f9ffea0afff28469f034ef5de492fc4b0bece8c8e310d6bacae1e9388375e3a2d4b354627d6ea5516740e94607cb56f8aceceae10fa011e661bf432e0c2484720cfd5a6473bda4031f6194e41e53625598f8e4619cb890c5a1779d927bd9856c2895ea5946868127840724562802ec394ae3bece1646db3d336d2e6961ca4169fe73e8c278d0b924628aab612048348a79210a5a792f89ef955550d68d27cb3e582c9b0b92f8f8fb515dced1d499a04efdd6e9e30867ab85ca8da6188d0fe8dfab4d40153dbcf357b041d57dca702d7b16e84c079b3855f8aa72f3298df15e279dd5e65532d1291cab8537f74e653e352258b6eaa9a09cc6167640b0cf4800db23a069f6bffae7f491e1aeaac1e22658e444df58c4f52662ae91eacb974f093e8ec12e6f9839ee4ce510bc3d7e2078d819a4936a2f322b7dfda546ae334d8d05c1556f980da7a58aa2b95e9a0b45dce371a8043ce8ad99e1cf5a4422d7e62258ff0ec13ce0fc47d7a794eae5300edcfedb5eb0f660120e7f5bf7c390c95c5561b7d994e9d57aa89c038bba3e398a96d569ec7dbd13e5ea4db7bbf9e1447991e78045448004b9dc1f3fe6316412a60afe20863253e37eefeab4df7b6c3e6a98885c5d52fafbb2a5c58155e2a32431a8e2d0cb1f1fe7ae7bcb4b7e728641ff1c35ee121b254f771f72957a34d53b094d84187378e3d56617699e762db4d698b9bd8c569e1f58255ebf503193197188ab14baf8e5fef68c67867d5a0e82b2b56c9648222a9431a0c9b8eaeba9d0222df2c743de271dc4154e44487cb03eb847bfb04bb99d1ba39c102329eeb1432bc33760880f813abc1cc7ff88323bc49216cc469f79288579cc8b47eb9d1615682c7d7d8e132b1ad92c3fc371a23f739a5062a31bc7ba940110ab955da6894dfea9ea71a3975cc890f05ba4c72badc49a25f635eb6fde8e1506a15d66668d5e99495ca7819154c0bce29d9a893b5841a9f96f9b65a7427010e4e4da11771f6e6be80f33c7fd9634e1701f2dcc3a204f041f9dac42c284d0f8748bab746d0d390d176544df356e8bac97fd656a29306143f73592f7a7a524375693ec0a415b9f73e8197174a8e8ad1c6bc4e1e9cabd3c6f337754c23ce9c6c8f1f36671fd47eec1e8a6c634a8891c69814ad7b352f872a19e185d574de2e27a5ce8d0ebc5b503ed0f98b0f78730b54e1d79471ee4d5d8365ea301b9d3639aefdc15bab7e4a4aeb73a7f05c02f52f71fc7960eada9baf9218e8ddbf1c95028d216b74793bbce33b5137f1ab055b632823c3fd1dd65e4698a36958156458d21f4a403e159238e36a8823cd87b62a9bac065ce62af9246835cbc0fb2fed8383811d22b480e7af5911131897b5661e0c8bc265b8e004825e8206d5eaa8d564d2e6acd1593ff266e9e73e5719f3fc1258f831be2c0ac2428ba7ba7b5c006e20dd9e945034d85ee7c4832cd46f2a24b6373c549ac8d302fd5739d6736df52d3aa89d1c586644f733b552f7ac6ccc15cadaf30c2a838735cb39c339bcb7bea7fce2263af72d4f5b8ee54569df39e93059da1c6ce86401efa882601d9007c453ca281c23de6701e14ef9913f64bbce33ed2ba93070666a34aaf0acf5e7cf081b1de2819b53a0e05a87a77a6de0b14ec7fd428ea1c8d1d7e3185355ceab8375cb3bf5812349e6535f33621b45b7441006a5101db586cfdc6c8bc76097ec5adb287f980121e0a555b77ce84be94ec7fc75038907afe086f40003a27a2319ed217ee8acf05b87f9abfe66acdfff6b48fd8ef47cc83cb31a20fcdc68f989ba2e44dce9fcbdd0085a32454022f8d790f7ab5a7d0d37ece48c9f02b426f6991779a8108aefe68039f404022f131ebc30379688a63fa7e3830fa69fec8685e6910d470b6b65b033d5a7715444d101174abeff6da45c9c0b9be3d79e48bc9ae9c74a71be669386a9d319e4e851b5cbd23ead1d56828e0b35b9025302d288b8beaf5320ce4624b2fbdd43d1f066610018656e31add81c854ac5c3fd633e4e3b1da33bb2c64b097afec5cd6f3cbd248214e4e17fb63108412ce0494c00a4a67645ae6a2fc2186e26e925a2ba47c51cba62c73c25da55630709b32eb425c494091a3b30a97859c452674a7264447d82f71a5e5292ae053f5ecdc8804a2b1734689186bcc553b6a1689e467f2835debcb2c03cb16b4e44c6d43ddb165e6ab7fcb86bb666cb93ce141da504ab8227","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
