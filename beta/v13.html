<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f9ddcb052821d3b5e9e179e36107cdd2a8b9f862c1c4d117ad6ecb304f232f56502e2b485916a89f23d3d519632d82f850310972f3e8a7c17998c9f0e268279e2638e2849bc3df201f6ef3210b93550ac998ca05e85c1144b8705c1bd9db3eeaadbe380997c8aa0ef7f0bb0ddb705e7ad24db3dd5f2580bfc6ce54f2036c4f1f7b45e81661884d4660ec4f15225ac7551426ab2be8f78002628e5dbb8924c29cc4aed9b93549829f6090723672d8b1372c33636b4cd741a1db1f5898d2b5b7471d1171a8e0f013d81e929dd22bfe3f190bf62473c6736c12d8c7e9e3af41d7f647f2481a921fb43361337599395ca65d7c73a6deb4a4c4b9937fafe172de6d75e04932eab106c4b92b3e02b3708103fb59c277a06587bc8a28aa753012d5fafbf8449d257de7c07756af82698521936e938f3891754c1e247d04375c285e85f12cc7a51f6d4b0152ff3764f033db6810f1b54752bb6a5bbae36cc99d15f283508751ab73eba3e76a9de86c51daad09b776d50a5c2a55addc4223ce03b0fa94bb00f17c10b923e1a39d3c9fd7bd76fd3ea6257dc7cd7d5726f0cb45031ce0a10c88c84532a032cf65d6557db501a818d2e66ee8790c55ca6d8b95063ba88d7bd1436afe4779e63319cca52cb0f37ef67318df4c0b21045c6d21bf6a1b4d31a37dbf488c21490aa7643934067d4f830254609944a95e03b17ac7f9c5d06acde26a718f3fa65ea53b51e4e9add4480e2be00fb771533fd4919aa52783ab498cff0b99a9f76007dcb7d95eb675a87e6f30cfb115a38d3f6e999c9ddf1cc1b6251ab8496b952ab1bb33775d008ec70b8a0aa337a37099487cf4dd9b2ee7622764ec7879e9a0dd6cbb7a297834a8096520f6597b19c8e9cdd0d66c3c0cdafbdc9462fb3b24526e74075315807b3519d233d66a5d1b3501da813e52572bb4de34669e2f42b049706f9260c81bffc74cdbf423abb7efb52a216a0c552033d32601b5ff446d90ba10b9305d04e6601cdfce35d5f27fa93e083c8960ca05341c182db113175a8b3d9653b6b2fe1ea6ed526280c623f80761e0184ddba0aeb06e5c60a20c5e2dbf83cb620cdfe8ac537f46a8092b567c7376992578a999b42bda427570d35e53c6b8cfcc9ca3d3fce8af4e1b0b033aaccefe6543986625fb1a42802270062fb4944e38a72aab267efb9d615883455db959211220896166321dfff06c1b89421dfc4e9686f267e382c47083a2bea26b30b6fdbc325e961553c150593099ca4cc87b01217b9497082c699b6962ed0964a47f16e5672aad7bb985eac9ba12310ea2f598156a90cc211d300b4ff74db18296b4764111d338f19cde24eab2ada6cb6ac6296a18cbd7dfb08ba63734167fbd78cb118976a6c241409948edacab9482ea4d70562d19a31b79334a743c532cd51cee3736e71e2b5c6a724b5c4132a89b6bcb35147b37a0cddda7f8e84660bbc5de5c9b8a8cf2a96ba089c840e40e317bf95b85af43d72d5c924ccf2d48639a6381745bdec443c886b966c024fc839e5843f3a7bb6ce52c3ca0daad77ecb0d41328a10e54949d867023d61567b5b89b7f822e2073c0d79d08e23cb8bcf45edcf2a232b5d1746645491a152e4ac18225a2cbd18195a927a13e0d7152c011bb692c031f653ab6f2e698fe7f9c29c43d23af6186a678319d2205226b941cb593fe6f60747f61699a5930fa60e03b69e179833be2240d3463f53456e161da975d02f29cee68f309bca99642a364e24118cda48b73268f5d5431ad39cd892429254a9c122f899ec4c05d8132e3fec3f38a3c99be8fa58c3585508933719b80bc6acab2e90ca43e9f3eede10ac4a3b08a9266c01a9cc610da866b9305e15e8e3adbdedd05083378fc3076e56945e3dc2b72be62b10d4dbcab8734e85c7908d5e9a4ef3677d22ea5b4b27252505b3b7cb6f3e0f083a398b4327357808c22d06edb49280fddfc404b8a37b5c6ff483b030d3f77dc9e865d5c6c4b8720dde0da0691bf3605146190115826b5525459daa9ae865177dce55f79ee6687a9dc7c5b8ac988ddaf84ebcaa28b6c51d3673581e5aeb00076df7c5c6ea592486dceda54468e5c76e44b3a40b4c33f199130ba46d1f9fd96eb43a43f7e8b30be6a6c9f9280a1f15e2332c52024cea67c8614924d6b74b5365bf1118ea78f38b70edef7e28fec82949086af2802674f9dbba3de8b1766beca2070897f39d6053cb9a668067525aa29e8b3b69fd2755c43496e8d40b54515875b5c4a09cc13aa7907ef324a71464fe39e69d484532c5e9df68edfe15fe572352b65e18502b9e2778ccda67ce1283f4bf20062ae671ba0b2aadb18c92b3d41bf878c352a530d2850c1b634b5918cf99673b2203ccdfcad7649602c9ae30ab776317e6cb9cf90723e6520935047983dccb644b1eb5ec070b20d28def67f49a4f09d7a27920127f21ddb918dcc10aefde6faa23d5a6bb8bf5ae7012eef2d544cb7a166d77f9cdc59a592a8bbcf2f35778547b9612f6214db01d223ee4c6d6f2ba64cd71ff277acff6fc4e04d88311273b06fa5ceb7023a1d29214ee791af6dd9734038725bff6e9e2f309ae7c156181d9c6371e3679076ef332b60fe89888090407b18fad0a3c0e60aaf691031b7af989313ec55cbceb787444273a38279c1a95ae4d928f7b617ae61a11cf791fc3a120f140e76ae538e5df6d47f2b5eda2376dde9e0a2a203b46d4c9e4b24c4017978fbcf872b282ab91affd29b9b2ad4b952bf5e1700926fa043aa6148e186d0782932c9100f9cf5daded73af0c4bd4565e9d585f2d2726f31d93a2b7921e3046b2a8d5833df64588ed3582193d1b9f083f66a5492621703ac2f225fd93889e5dfa3189e1257347e01512421c2955325d96db63900a783849f2832d7f9f973050f4f0a2b739f3706de0a741ae1b42f939f4095e0cf96b7b8c322b7c9086c0317308bfa4085e4e60566081fffce6a508cf41a77207136cc5b03f2c22ab57a7d5aef4bad7b7a498cdee9df00b3e4ae5b9d71d1ce53dd4e5df5aaa7aed039ea6333270e68992531fc63fd69a5c5e9a0ce7f7e3c2ecc09a1baa6baca9b691bdfd27778869e9155628bebd6e9708cae2a4881fe32cef1fa8eaed2d822abe4c995abff333aabb4efbdb9d1dc278a00ebb95d8bfd34c834ac38cb56f33eb1b33149a50c2d9cb662058bd4abec189f69150f936a466c7264d80e3522a36bf09417be63f5a71fe3873515db4e8300ac842e72a45d63e03a34674c0f301a80d100659df7daa4cac1d9d12781cce7c5d998b1c0984a723d5ef32b036b78d4755705924584ce4e70cc914b0d50d205486c12de5c219e7094bd1900c2e65e71aee8dadabf9e84ca3302e4743fe39009efee73ee5a9d0137e8fdbea561009ca876a18d9329a7a2fd42b259021210efe764381719de457d24e5cad1f6eafe245cc91d2e499d48a2f71480484abaca69872639b22d9b763ac59d61d6250367d62ac06cc9b8cab5464f4c5f5c6803fc962094a6010b98383428e0bb0c0ca37e209290afea370b01225420c2a55e53baed96c88be910c278cb3469911df51b190b1ca9d395df036208585441a4034ed898a40f664a301c1f70e339692aaeeb66969809345f7a29abf8857268fa28658edb494d0099ad9b8f3c6f961e3ef24cad45b32baf7c4b5916e73dafbbe33b52bd7d56eae6d3b4f76cf808ba5922c4969ce8c4188e85de1cc7be2594047a32c72b892200f9c68f7c083135251001365ebd303f1f3a960a69e65ebc03af23d064ce7c1bea6a6df1bfd9920d48facabdf27bf0ec8d8b53edd09a04010fc9e08ff84ee7304da47d1c18d556def26085d085c43b400f7f24ef7d95e733b1b0543a9003d92b4e67378fcad0fc19481acfd28273107fcef6471b37c99fac88df1b4044ab33374106f85ed79759f8b9f26854cc06884de65cda407ef8207245e96b475b3e018b627a78fc15e2971384bfa1567922bf587427c20ba1ca4022f23f26ae7ee6f32ad0b1f6560e9688a8b9062c3da28ed3a2f96b2d2e0e7ee7819616d13ee70f8dc0bec6c0451ac71ac923ec253b3a0f3d9841f02de3e8ccb64576312088fa7c9fa46521bac0e2cc10cd179d15e7830fb04ed82944efe70f0d3394cf42118d5b811577fdc82361d29eeb4258af976ade546be82900ceec2d206109532414c3f72d7787bd83bc7010bbbdbcae2777085795dcd6e09e5451cb7406629b36729395e4eff090f4e900da707efba6f9093461974dd6571488cd7eb87bbaeb60ae7f1e1174fc0ea6e75bce099a70eff75e0e460f6d4d2d7a9dc747464d1e196e95c294dcf245de5f2cbc7e7740f1cfe274528824390520b7d161d85da77fa092de2eb124280f2961fa7a2586bebd492ff3acfaf4dc327fac277715871b464336c4c3ef3bad8bb277e7e096dbc6d11ebcd4f63f76cb26d5644eed9c62823b0f32d458909745be36d3c8d8c5531a3fa1595900cc89e06ee97058edb1435f09940e31324c4b2656366c01aab6c955a2185c7e5086183ed3a44312341bbd98aefc4457e44a4e26d3a8f90bbb789d58a900ae45f5059ea22985d154c154817207195df0bc065ae38c8eb3e781c91cb2334802e48855a4576e2b0f560bbfa35853c483fcb9f56e95351278aabdf062ab28f2eba3063a6236903f08098b739642382c95ec1b3547c4a1f2cbde9b5798c1bf7df7a73253e73deb953e5ceaa5406302173e81a7c0823602da83df96cb173885f92c7e2c93f36f0b5e0adc599771491d6e2c5cfe04cca9efde98f949f6595293835774b2aa6c5c9c393a73daa0bc8799a7f1479670c109a8b0229cbefcda5afda18c04262e49e9a33e3297f26735ee78c878ca47f2dbb8672565afde40b7d1c934e02c8e4a0bad72fdf7a51942a40e2dfa331f68bebacb031cb450d0d9c84d0d93d0bf3e97e33b56aedbbc2e8b3c60d6769dc33ea71ea17eb6bae29d757d2c0c83636b05df029ba9e5f8fa50ecab6610ae9d5522ded81d7073fb7e0494b7ad67b82f44e88acd474dc7f651787498ca327eafe4ce68757191552e4f0437aea0921c4ab89ab19abe339c81c028e4e97a606ca4bd28af566035ddc620494943850b2f80b97e57d94ae5e66428c169770cffc4bd766add26169c1dad5c5953c738c81099172c8af18d3889409a5257c2ff933791ecc2f4060e0e5e111039c96be484184d9aacc9a5ed5cd9436db8b1511bf617794666904aecbed9b52b6ecc8e26190d9a99f57a871726db43b2e40401652979ea71993172adc4b3e3614523228a2407b726aebbdc632b6b7eeda27206f9ff4de1b11a77c0d84d590a904eabbce3a6065b22fd9a2b9e0165b8f0b7a79ac9467d8a031957703ba23162c3792ec28a2105bc90d77c761606de8c64ec7c02cfcfad956c0dc3b256005421332c3568108e7728d418299d5009f17104c54c29f7a6c9634db310613b5b6ad5c44494e17469b546b0f6fa246a8350357d29ce58b5f8f4c7105cb3b677f24cce9d43c41ff64d85042e6414f642a3441b84504da41b70487156af0671fe071a26e8b3d8e467055926234e47ebc69c55c6e80863e50e41fd4e3fb411c83021694b5122bb6479c3e0637332ad25436a73b21a2660e598867a03cf6e5eb51a5336a457122e4eb781dc3aa0ed4bec54a194352f83d54c906d9381d79d2a2b84381c8c381841cc55c66fb7548abceb01e538e37d354b25cf1b93943f7439108815064c1bdfbdc97d9ab984ee6b2a5bcc5d7c8078a92edbeccadbda58f5f67cde98fa0c52b8e574b09942157e23dca8e0c2da5f8e80ebc5c23eb4ecbecb96997c47e5f9016b1f715cba59e1a80830b1ab9ea499102f4c6593c077658b50db011ebab0880eeed72d85245dca9e79935caec8ba0c531141ce41586c9c4e7d27abfbb018431ed3b748cf7f26a43c8f7fb5f8a71f365dc913ac652b838d4307c899ced25f7ef7a48851cac44fa87fe526c56798b4c60476d57534fa0db9fbe98ab54c2e7716e2119886e26e8ef9a1f9ed42b9614a49bf9b3470fa21738776b22aa52c924713ec61902713a3a8fe5698ddd17a8c044e337457ef2ba093f65dbb326f5425187962647d51b9d1cc10fd13ce66061e3bcdf24d23eb5ed84156542387542febfe84d6e72a2bffc0387dd73a0e770ecb328483de13b3d0e434fa585011f23a150db77088663c996077dc85cdcb3303d4171514a5a6647b2dca6c7c6346813f3b663a82dfca2a29d8c71da48cbed69decd0ff3bd00ab65d242f5cf563889926ea23675fb279ebc6cca35566a778d26f482a7ea5322a21dccfeaad1d939419a28a8ff431746a2ed86967bdb086219a93042f29a81dc29d194cf2caf8e8f7604fac029efe7ecae881b55be9f93e9479e3914ed57f432960d56cf3704fbfe8070f3ca162d77cd62c2d568dac29ae1da49593a3e175c13d148b7ffbfe148cb490333762c65130ea44eeff872b53d3cb19bdf133222ba05bb33100a2479129791620db18b069b558c075d7557c00ba53089c73c752cbe18ec63391e207d563f96b901fd3c424dd1883b73a6986b3b62043c41504febd3627e7d918d36f90b40d69c02a60b8d967cb5e0ef4363a743a2d826925e2b30b47e23c74a4a320c79fb81921c0e8250476857358e96f918b8259596fcfe4f5f91e201f25eab2632fa8af2068287dbbb7b02a8bcf76070f04fe7b337a9b0d5af0f60d926397fa8d5f99f54c264bcca4995a614d87dfdf60870fa9b9127df985eb261212808c22fc4a3402176e808556e71acbad8f1d61063680914e2c0afcde89251dc7c352794554b1ee6987177e2355b83c81a45b5b8f979a9922307f8d6ef5f18d0de4b66d15d24789edb6c8f80b9f55a8f30064b673f7dc090948c3dafe177d5b61e2734c4ae9c4c574076aae4c01f47cb884702159a1e94db3b1fb865bf62dc848032c1fb8e3581ab5cffebc3248a410865ed0214140a522b526ed5d223873bf2965903c3fe331afb9f5d57878a8e3d64a09c2dc56067cd8545a7f69008c28d5c7f20c35bfe83b20c0605a010f915da1a58d1c023aa97da99adf14a6bf71518d903b3f3b13489694830614d84814b89e8fd6e43f87f4a67d91d274ca798143220a0136fa443500ddab646f389c7687c6834e5b9f10f04a083a45ba9628def151b41045f34cc1b82195766026ee44aebd2c830b192b28081df65f92349166af7b190912cfe3c55576794fb856fd8de58baf66fa09f1a939566334a7b2b940ea077aa04f63c29c1567ecdad4d2f5bd309dd43874026004e559bfcec3de154b2c50544ee253006ab8d6858d2ef9e424bbf37a82fb60292e8dc4a2c66c166ea7550c4ac2e61b7407a6a474b431a72c9fe8b19a0ced84ff03d3921d888979cea3be145c2cb4e04fa1721d1bf38bc4805a1b3aae33f71d20667ade70da48936745058cacd9337b61c5c1d1a9584155998c1c76cdf3fa0cd694a428821283134993e19f3595a1084c5a809e90cba3048bfbe58762be5f6a8400be587c1924bced81594180ca734703a2c3f2c08d5ed6fecae25c54e294743a52fb8abac52c56edb933801096401251349130cf727d50ee8ef4ba0169d4d91548eb11c19ecedf5c7d7483bdffa8616489f554e71b3940c32b518cf4b0528c90135d3b2f617dacb83a6e508520cdeb2fd00da03016a1667bcc0c250c943a35821528bcc21ac63cdbebf12d6b40a4dddc1b434ea00b96a765b4efab40f1f1d518d80f80b73d50d0330e9d809513372b573fd58b3b1c1875a3fa3c6649920829d6e8abaad1cc99324549d2e2bb4b73877786b2f7b124cd7246de4b766c9ca4e83e22aaf611bc9eb84e1218ab42a1c8d616f849ab43ebc03c52e65887aa292a5058355c26229fc0e4edeb3745a574f70882c16b67c0b6f4dfcb946c0742056bff0f6c8696f267d3453d80335fba1ade8b45d5e89a0a7277de8757247b607daba18f30661afb3ec7fe46ab8790118828fd9ad1715d4f7c9c0b0502fe71d612b1092de7c96a1792fb75b59375757dd69c488b762a32de1b1feb732862bc74442e8a5ef1493f6a1f9da7dc1b7b6495ec7619d012293babc81cffd45ddd39ca8e50576d3c855f78a004142537eb164a7b877e73e6846f4285819553a2193b075c072e902102d91e135dc60da9a99c1858c476cc78309662dc33a964c0a5e55f2ed4eecfe06050b1562aeb4c88fb2f7a768ccd2ca7b0fa012886194e444b41c866d0a3b03ce163136b163fd285c9384efdf9068b37df168a48c3e07aa5dd2e6a96b8420a3fe008ffe639117debaafaa6585b2dfec741b6cb02cf03e9a68c2889ac3689f9500df43cc0a1dcfe671978927a19feccacd64ba88fe3298bec96e125fb145be33a4a2b64e76433ee7818ff424c6225c75d82b76cb934eb83bfbf3fbda2ce0b24af18720f9927b30ae5266ca3d420a1b531be0985d12d4a993466c96fd6e4b6376ba3994b48a02d0655a666b3fe99a17d5dd49e36b8f7db85e6777841c3c1c0421c9c821b88107c1f4b731d019ce51542d5f4191a98d4df28197612cda9edb66a2119cddc0c8458e685c3963ba4ee4c803b70e3ee6dd57fde17ddbddf3511d01c22470bdb404ffe54743f0fead73b88ac814d0f1a2458e7871fa0b6a02e17ac48b973e7773b0eaf36dbf4f203fc73fa2c75b45fb38548c5f3565484d237f37001c264e71cdb26ff4c20f3440dcf626c2b5291d2026c85421630fe1e00555a7a45fe40d6712fc9344ea038a3493dc01fed956b979ee9727f6d55754e9c5fd3effe2257e59e6eb847556427a76bcf9fe1524dedbe85c4b5a1403a424048c49bcce782cac41d2b7ed23e1bcdaf4a6e3e69e0a8936989b83714c8c6c09eae0988414d9967ba06f7086bcf7636de467288880b04a3cfcdc576a9f25022ca12644685f16e71fc7973c26eebc785948d734b6db689137d494c8874b1d536e3ae845e64f6f99965c2b236a3073d7016aeb6622921c3a562bfd4a00c7c33e8a7e644ebde0431786582270b7d18e8329a8672c0bf62caadfc16bcbe349bdc5b434892a05ac427efbd933fe1070a808323383b2ffe4a2b02e973920eda4b9cccf279d08943e5fcd6b8597a804b6d29a23e8e2aba23a60ae5ded11f23ac2c6ffb956fd55aaca6acaa245da425886a562f9258168504b865f49621a1e1a9e966161d95e860c83e7d147ddc89429694928616bf3f4e109b75f1931fd94b8e68e4bdac7670c5e6aacf6b79fb3affff116178fab6c58a9e277749313fc921fa185c2820c3e58b286c4cf90de6c6ca318a85c4f545a69ac20263e8c57a519b2d2ee390578e22f735d7449831205a836e63f9c0e925afe33587be080c343cee492803ae1c0e9e973c7e39fdc4f3f8334a56a076437d0fdf669eaa99289f126b6f76090aff53cefc7c0af27a101a686bebf6aa2f5001a854a5d0f625e68c31e5e9fbe888d2c56f9324bdfa67575ec9f1f390ce9f636496c7aa1f7bbf225086c1200dc3f3a4769623acc3ca8fc0406ee035bf7dfa45abe17aa76da4544bf94d567e2b209b39573ac0fa94f18af0214b229892f03b591da0d382c353bc9133f6df63f63bbfaa1b931022e7fd3e8b54a69f0b29e6b1cc8ef348cb1004241d5442506a3a5f93a5464ae8644f446012a4dd678131a7f5b8917b020d8947e638e09ee10abb549051f50729f78edf4e4fb15402dfb6dadb0001162550152d0f58cee37de4e2b47e3d59a6e361144f5e581b2a792eb28722f6d16703fc10aaae33e68865365ba4d06fe1284d9ff414cca0f102e1d41338f9bbca8241ba4a461b5a880d4f32662f70e126b73c226cb6c1aa1cb1687e0d9d6af5503cf7b3b1020f14c1b23486703bd5c5a5c9862c4104a623373df10f47101c26d86e4fe1d5565f11c675219fc1f6f9116df788de22b3123d4f088dfaf8f5f0dd775d1f5b5b7b159a064ad913f8c88bb7ed1274544334bf12ffcdbbdc56906f4343b15d4ccbe3a5d0dc59f0ce62abd8935c85b6c49df2f8534ccdf14c1e751e4a8ad4c7c99c7476fff8fb2d800175f565495607a8fd72b5bde6dbf38cedb2cb838d9348f1c6dc7e77cfe64679b18e4943230ffdb21a45c59389e926987b2fb5d584d4a7e5324f1d66f86b4b088866b3fa243b899ebf6f7b6c45d04f370111d5fb58ae75b936ac2740c487e17ab87f98fcdadd573ebc0de039143965f09d58af151a637110b61fe3eea150372d11bad05cad284cf1cafc44158efc2c967ca371ab669c57739d8bc6fadb802e5209fe823d87ce07d0c5a1967decb6df327831114845304e238db65448254723b0e4a12c5c12dea9224dcb3d7ab7408e55459f7455d2fb4aa597932e915b72c8f0cb823158673facbd34b79c904dad08558b8c4bd0d0149c892f23df4db3056b09fbe117bda57452d7f664f035aba7df04403f25058d78357c75ddc865605701e7ffd86ade6cd8dadc9a5f46182166d5dd40473573fe39497786704f5fd759540549bb8ac38ce4cfdffa2ed360a00b106b177f5e08177cf7550076b2fee83ffda4d781b458bbdb9d8d528c23cdd2d984d7f45644270b994a17fd61a56d5a7b7f55eec6d2fab2967808e5202a253bc726fa09317b6b034a6993402adf7d035217066415e2b9b729f3639e67279f96dad430a25634b966c8edbf5cd621d1088dee771ccef002d213e755378ea8dfd1a7d2d68d2c920e48c2c62005f0d493b638096a3c0a9b346efdff6ecae0d4292a1f210ae5ea12f7819e3bf0419098277ce49d33f363b956bad5a8988143238a61ff806bfb285ebbec3e085f5105af808c47f86339df3c6762b00f9ad578e9837e8252d744bbdc45259863f1a26d9186db76a4b218971852fdee3f7fc0dfe913522cf956924cba3c56cd63654b4aba59026aa0d5f707e7cd027c204d15715812d941c9bcdef984078208896872ecd0967c6eeecc02d13ce067ea5daacf3be221e8ecff185944a7a8961865cce59fbf80d1c5e53fc6a5caf309652548f1bf5b4eb76ed1ea8b5f3efcf798300ded93d0b5b68cbb43a5876872e8d1f10aa318169c744bf29d29ad702f41b195334b925fef259e7a40c079b30b3d4b85bec996d1325ac1bcd6352548788d3bca305fd46011b33d4a5192df55089622d87cba8aec1240b284e6f8b232613792f9345514c507f17bccb74f9a63a3de3bd92e10847deac32025b2a362a087d415f09092e99c97140bfc82baa6052ab328dc1df884872aca37b745aefd22dd263c0eeb98d396c155c2b512d3dfb5ed5ccd6a362c512caee4696434331b462311259ce09bd4f70cabdbcc519a48d4fecadb2540627f144cfc210d543dbc98e082922ced49978dd71dad80ddbd57c392876987eedcb72aeb377c2f3fedeef6087f43c64e69dce63d828a59cd8e03e006054dcef415b25858e07e78f26c23fcd0d4c3451f61941d58eeed6e1796184682076d7152d8f407b47a2606c7b2f71805b36d31876508fd7301a80bd873b50418812d391725547d21ed3a8aa41f0d9aa7c678f82dc8c8a6697b7cde3ac82eee31023c06ef1bd1b206482330e9fd19b044468e62f7231911f571e7e6caa3791047c4893e270f3ea34078586f4982bde1ff420840ad5e85e870fbfbcde62aed9078b7154e07ead3fcf40e85e89be23b5da5f65c68ce7fb457211f16d0e8276706458078281d420057f867d164080209c77a69262c059328f0fb08d2e99a2872891ec868362938f60f9667d5201eeffd4331272c52e7e0ab346394f96d9befe38536b830e792824a8177398b682099ba1b240bf773c7837e97efdde176561e47d6f07f2ea2c66e0bf74f0db86cac7190c7f5d2ae7b77e707c1fbf40dab245fd741ed9186d3693739eeb1ce9bb3241c081141cb4af6f921da4e9b973675c8e3243aa3a204cd8303ac911463008c60d05fdb4b93dd9f870423fc044323741063d6201cb67315e1ae35dc8696811bc040c951cf7c057759d728cc79aa7448bd08ddf263ec04c0d6657083c3bc8004b0d61f656228747939df2e74a85453a009507b76036a66cbd5868ab03f9980a98bdfd928cc029f51eb0a2fcf591a6968ab17c3b5775cc31dfe79589bdb8c055bc11c14696fa36f22d08da5fe160f71f65489f8e64d3389869a066111a4d1939e253a85b11c89d82cad007cc2d973eac552916dfc41082ba3bf26721f35b48ece68124bcf2cb8502fac0160489bf875ace112bf80924d9e8370ea7cbba523fb145b1c4ab775d092afe54e8e6e051f5f8e00b780d8c735e437666b72e9f39b3e2f1fec109cedc8ddeba51b0b882c8b7703239458810858d7e4bcd26b204c64566a68747cc0cf3494a5e9858ffe72264d26b79e18b254ea9f7cbae9f0b8d9c3e478dc1dbde98794c452f24c9628a3dc4272db84f490e0b1f7f2476ca236173068f8bf3fc0b918393a87316df341f83b2478b507b3868782496a6623b43b3ed1874794239b9ebcefa6da4aec6127397be23c25953dfef185e21d741250b70d67a0a6b7f0316fca40dfd76671f9eaa04c2a42b765b478c50579915e995dd310b73693a528a053d82c5f5039f30b814c67591a94c8b9f52a26ed79663b61cf7c50cbedd61827b10b53deca9cc1bd154cae810d7c4338d5c6f01d0514b9461ef7afce3dd0a5bc6204f02ba8175774af7148feaca49be3b858cf1f6eb7143ba63509829238e000fc7dff919843e14b80a4e2d0a5503b77b47fbb3571e0e801cb1e9693a0577490c6f9bdeea5a560ff4702cbb9962395af36aa3efae992d53fb469ede96e3bf67a185030122f0f4a5fe92dee5ba3d950b3d5055197627163fa43d58d0a9e372c9f7f6e3a4993cb6af1c2654f055c7567e69dcd16b617d66a3b87fbb5bfd52b25d481b0fedd7556f04538323db4457cd8a24b8de6f8e05c63db63241c5a2623bae2857ae9822336ed85564e4356cbccb393bf3e5a3e6a80307a94b174bf11047e121b842ce442cc0cc8516d1f52e70596a57da3ffcd313d7a415484dde9dfcf46dac7b3255e0a43d10b94e0341894e8f3f352bda6f1c513321f76b674cdde57a82db8e3e0dad3ab33d14f82d944c208bab9711dbe16a56ba762b400964a12e24f83a7abe2af82b62b1f80ba60104c32b725c7d6671204db51b04828158558de237e660d23ff4516c17bda599c8bddf5bc7d3e7e4dad6ed4435ecc421475a63f8d7d750b8b59e5f9f2696d48c1a4c120fc9964e7375e19281a62ab53d0e03a461a6d98d6992ebbf186db318ad31872c8dbda279d85841a99e0f6fc2dce155b3c47ad785588f85d4715bb6ea6edbe2ed316ac102858b18f877b5a3be752f188b93769e1266ed40e63b8d0e16ddcd69013d6894e453f246538ead772b94394ba49f95d51eb8a688fd27c60c16ce5e2c8758965fc427248b0a395c9576df953550800da4d11522c5a7488c04e49d4eeb2df1473cfb5b12918eb219ae698f96fd911e29d2de1c7a81b6938a000a388cd967d075e0f4eabcf367fc2235ef7d5fd380f2e36fa59f2ee0aa5cdee4e66187028fa81cedfea37199d783ac9b89dc58323825da527b062926ce486bc13a89ea4a7585f15612314e7bf404fd293ba16d882713663965959f72a289885ad2df2d07a79089f1b5888f44a10818b5829326a40eacd96f76181bd68e926f7120767d422578fc1d1cef23a113598e086805b82853dc43e7c478e54f6e17ed84731ab13078d6671ac6b167c90e4ae379c515b3502a5272ec0b66f12d55cbd0dc832d71eb5c85fa577c9c1f1455ef7c41d75f404af05cffdd6d4dd4f752b0eef66ba41dc234376c5399a414dd9465b4929ddc4e1ef3b0479f730f835ba399729c8ef265d62feb50311f9353c5f8ee76b45e4af5ee6b8ebe39cbb00950eb57fef305a73dafd98a3f6949e8ec3b4d92016ccbdeec1b473da741d54b883ccb012679ebcc68a9a0d4ba22e8069316d4d4a13c001f5a53bddfd6e8edbc44c48230305cc0e1f13cd6e7343912302b82e3ec8b96b2e076eda89bd9574a54ebe6147e488a2a88b24a55e2ba2b1ffb84a13fdf05363c0e77f1dd18cb1705576c60646d803a3e0dfe9ba705c3330bc93cea8edea51cc86bc4977f876c013710886a7a225643ace53d729e2fdc9dcb8b412363b134a10f4667061e8ac16492c03784851f6e8417d747f7df931b78a1c10090a185ee50a10cc77e66be9bcd24bb7c18176fd1d220900a393657c74b536b4e523a395a25c21d27eea81edf2c858dd81f7a30f3591c4faf6f0abd0541a3e839edfb1401569ea8b3e7ffea03e04573c186898322eaba4b646ab21243473705155ce1a752ad554d601fe4c3aabbdba26e5c9a589e6532ee80d971b3afa896db87947ddfa72435cc7b765783f58f5992f183a491678422715e9abefb3df2711f3baabee3f0d0e255078b1ea852e4f36084891e44c6e693f91e730a7b0965f7e9d4961e9abb657b3361732c21eea55b9400a8db279cb187fac946678ad191eb19d3d42e79eb150543b53a1bc8b87123ac30e47b97feb54c5bcf9e0c7ce3d39d0b21ab7e5c552d2daf36d7815b44b4f8aa8e7f3ef38e0b7158bce36d0156db2da4310c9878","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
