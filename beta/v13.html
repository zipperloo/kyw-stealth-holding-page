<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f907438e6e077c6017fad77e8efbf105fe8a694c081e741661a7487b5158b254e0e2a54da2ac88e3a6e52154b8131501383e0a73e16308d1a7f153e30814f23f51b1c5b3c91c1d71cf9b41f0cca7227173631866b1b6007f12f48204e1b5e4cd011405fde5b700d5604365866f55cec1a914ad1fa455385f19fd9c2e96a47695f335a36cae723562ad0939353acc68f77cfe2b81a12b32c6d829ae3800f3022304fce3cca19d6ea14dde4254ca3e45a31cbd7c3bc6308a5d1792031892a0828f34c9187b44a549366955b121327fe3ba0f4d0553077779e33e252b7a8344904b9ed128e7f68204336b703fc39b717c2378bd289832ef26deb4bd97ce3dedaa80ffde2b441e3780a57a205a75dca7d2b4cb79093f578e761c36163ed2a8221adcc75bf750dae5cb94ea7a4ca22892b8309fef3d0c8a624359931f1f3bde9e02da1dee00bb33e59aa2068dee38aedb9c141b58cd7b45e87775154e6be5d9ddc22048bbbced28b2416274a676cc26495d210480562a699b151406f7f6d1a6906f4aa76238c641628c7b0078871069360a564fda1f44d29ad8c79e1d10e2e6555329335ed87ba90244d94af49e975c2cb73995bed7f034cbe75b229b021af17195455f06c28e3b88a6cdda29e73c77d8aa6909328ac8c6deecfbc2ea991f9d8a2237e095f911441b891285c92d8c862e53b70bd7503ec242f25bc339e54088820e557b7410ba38f9a7c3a4f8f9346e1d4399eef822c7d58c6946548a08643375d33be03e1b5b67ecb93e1a95802e3ed24c67cbc83bc07513442eae718994d6e3ac30aa2ad4dc1435244d965bae9a50764fa693e65be4aeacaaf2cf319aaedb7f722968b96ceacf96069b014eab9b77082b2226e14d925cbde16f3f4aeb7cb9d9778ae8031110dca60d8d70ca3cb85a2e74b6e00608b2bcab0e3c4dbbe8b5cbe7bdc07843b2e62b373e28eba0aa812fb4abb7489affd40b258bf4d94dc4b1324c34b823da7ec919095df0ab022646b34120d92b8ee0c7ba1c32a22d22d3fcc54c284757cdbc47ff09ff543a8b72f2f1915795849d5704164c5243910955d72d313d368077c26e327013210d5ad65b77143608b32879ff7d357bc68936874b274b67c91bf715d1fae4e17a2c2a263f715e4a2baa5fe51005a5b2de6eb31eb90a1a03d822b36c7a93cd410833a6cf3c685d4588ce3de31064bd85d6e38a9db605a877864391c55272645e56efa8c521ebf85aec6f83da2d93de5337b750e9c7330be1ee0f73d4850546616061aa3425687f9d3e071c1dd515f79e43f12d0b5c91596613ebdce6f89f2877c1cf449eeaebc0090ae8f3cc04e52537d840efad65983e3bb55e4f716cea1faa6ff9c309170d9e8845e4df59be68d9a7549a1f6c56aea7f2d6e1f60f7baa30fa98c9eabd19c7d3180c428c39aaa9eaca03ad6e30849d895f9a21c24bb2003f3aaa67b21284c203b53e98bfb2c4785ae46d986a7429c10e05e5c8c6c3d0e7b3d495666fd30ce980a2d90a0bef5ba764dde9592434e3835908c83aa1edc1c95543778b808c9c1a5a9f9781858c04d47de70a25b0a02661c18690e43eaaf2048c51be5b1fefd1fe0fc206d44e19253ed8a500aee639fa1f00daeb6edcbc35d95f54d205e344a4ae22f450de75b8d10b24620b6ef0a028deaad1ef831191093a52ff18388f42e003d33179435cbf5f0db37ff9fbbe416c25a528c298813847b670a1eb6c7ccb86fd0d11cdb889aa44a6cf7169baa89e290972c622ec0673d046bb32474ba1467bb9847c5ab541cb07af95227e7f0ef2e46143eeeccc80d5fea58517e159c7723507e3077bc7fcbd7977da63db6d997bab8dfa623f46a8f895dfbee6ce7733c42455a07b3e5e3ecc31d0b7bd96a9f56caebe3def2f00e0c4719d81c0483888bafed2a19326f89e6766b8f27d6a3558fd28f31995eebbc511918aaff3bd457b3bfc0fb86228ade4fb0ce6dd2e5c37c98d5c5091edf03c9890eb3caa3d1802b6b485047862591947e7a5edfa6655dd37e4f5b9567dbf734850d38cfe533b9896f8fd879e2b492788fcc1ce205a48c147db9179503c230e7cc3ccf4a77c845ca2f7d8382db9fa265970c2d8c1b981893edde8fd605dc87f4867b704de2bb05f5dc09ad4703726053a1e95eaa42c366af9e9b2105b75e0d99c58d293095f07915a5781273b1d0553937d83a7061fa47e1562bcb6ce50cba15df8854f79ff5be8d1ee05e1d5550794ed854e546e777cb7441713cf7a522b1a42cdb932b003e3fea0a9b04f022bf8f4be879052fdd09d2b31d87829a94358f158f84513e01446db6d3b6222e589f9d792a4a61f8fbb16ebc52be071f28e234a9c020c69b80af65ca85840ed316ba0cc2f187a56a8a639c613491594a4b2dd978116188ddf98a60dbb3c210bf5272ecfea343d9e120cee5e98a6e075ab6e75336b6f8e1bf463018609a7ac4a76ae1413c171902fe4fd22a3f00278e291ff6decb8a6bee5ab3fd24e5d33873326357bf0671cef47714fbddf2c429e13fdacf993e9b3fc5fab6ad1af8b4f87742b9ae80eff6d679ad8a2e76139cb40d17dcec82ce0ccf8843c06d7594688a80dc4c977d21563f22240553cb1a5a52f09f620d33ad0d3d35a14059b9a5e0d0a023c8418a6610accf75ae31dba2f0fa225fb8ff20174b01fce18b1a2f6b5191a502257f3c11af19b0367ddce5b926c9286efff5d12bbe7f3bf255adbe6db6dc08f9d80aa84d04c211ae46ff64a9a1ad5de279e49a9a5e1db9fa7f1d9112127b8bf034ba055a2fdf4de6bc1e1cee7fe7d72922e14156f203f1b0218eaf41426cf2063fee19a2eb096166a648e249447650b71753eee13019993975f6bb933a5fc158d91e572382ef42e9e80a11142d9548ffd4b2beffd227214ebbc78025b810a57dc3bba04923f7b9edb6b2f140490392cec37bac4a53b884b5ee7caa60ae40f27116e44b15f39fc5e830e165f7179a622782b8a953f93335d57c6d68fa7f85de3fb76e096923068c08d613452eaca5509a1e78d286b7d5b97b09f1d39ab74e48c5e8d7d4a2c53e1f9b86bec3edbd13771f4e2fd194a175dcc7c6c307867bbd40d161dbe6b4dda51323ce1b4fca0ad462a8d5ee2174fc765242c764f78947bba471ed35d94968b19c2352f264904f832417fea72970ec95a0e2fec35075e9ec52ad47d86e72ab61b32faa0538a5e4b6845c3d1799380fc2cc37ad72d22ef32d78ffaf640acd0e2d2528082f6285941c526b84335649a0628ad39b8697e9c621ed5ad42525f664b09c878a0b4faaaedb110e2c072cd5b7072025a8f300365c49906f643dcdf8775cf5a72887bbd90eacf18c11e1170182811cc90352d059d8baf3d8a51868a16b119bfd3c4c68fe55ce733ee0813456aa4f762e4ca90169f153532a6f4ed5be1cd41ced92f4920eca9cb1602e39778e0e52a16234ae0f0767a149a12c348aaf4defe48c542077725fb34708af9b6ea1e4e776efbd9179595bf6dd1848346bcb1b0e879a2b0bcdc929bf308551c4ed1ac7327726e193b983d2c74eb00ff37c2c3df4d1407db3fe3e4063a24846d07dd3f9f795fb2c094b7ff7939ac9cf7acbdce4c3d855a187c54d8a634966f136b21daa49c00e505424207e6d03041865a9b05c3f515d78e85456ccca5d4ddf2b7b93f6f7f06826344500e534bb40b88259db9d08d7c34bb55663083536928ddd4b2317eb6aedf0e6d42a77e5af1f3139440cd0e7a3505cac307ba230289d25a4ae2edfca89598049021e92ecd004d614f755d4ae8358ac1ed84fbb77458046aee8bb445c88a066e6eedb6c7adf1dd34259fbf3fd07625897253bad9b0aa9990b3568061754b8e837773ffd408da650bd66ab160bace75f9ba3bd66e568bd060f84e309864057b6680b83999322c42ec4ec0bf7a9515f3ce7c1f2dd63370839da465504258dea0a557d7c5a62d92e89d8110d758eb69a839ab7727a832231c7facb94906cba089d23862a49efc0b7e55cd37a3f6fa860be238857274a4bb126e3b21511eda2644b6eab3957d5bbc305e3e5a69f41176479662e133a1fa7c012593cd7b620f8d2ae74cd2999009899c4bc8a209bca652548cff47ece54128dbf1ece7914af81202cad01603cd65b60daa120cc482249b85e20c55b81844f548cb577fbf33733bf5fd2362202b1bfdbac1b24c51208481fb28f79b00ae26666731b1ae5d6b275359125835a7e42d2e688a159a761154f61a5d95d2ee37bf7ab685acccae1a66a86f5cea2402dfc3cfda0e9e22a4cb19354cae58f8bde1e299bc4888584623fb1d83dfc47cbbfd5a73ad5f444f59fee566470116a2abc965d22df27d80a65dcf95a31daf6e6962a7a4b53248dadf3d8405968bc45cafc6b983422e2ac2bf761e61202e0456f6eea63851a4e074816f919e2e9f09535162de8ef61fca848878a282f650ff18b812d7cd8b8acb97afc68d6125d362699b21747239888e8b2438584d06449efb11d1abd7fca78819682a9fcd37b117bdbf13baa52626da90054c8fa405e6458e459a7610caa5a92c92cff9b21389d6d9b913867576126bebe0f3fac37d1ccc31faa2cd866f3b36e41a83b337706833ef3cba06ee33685e2986b524e2d3b268c0e8b708f767330c136563a2bb41244214d566b3a8800bbb40515f34d51948d4bb3d3a24d344feca84c64543ce806dc8761230b175fe149bfe4713e82fc48e531deba57241ac010d56c50536ed30601ad41c6613bb9318407e55370ddfd09baccb013baadf1433a02118ef9338bed22f1c3f279924505c194f2480ae80ad0b787b16d58342a9e3175453033f52db611522bbabb7852397b444abb61c4c0eee59f16faf551cb89ebf8398dbf60b2864bee05e57d5ddd4d08fefbfbc92eff14a10590f87b9a57e37aa8e0886cdd67a83ccb4a24ca99f5fe4bc116b5175c3d6566d49db2245326f05615335d3f01dcba431a6d8b4f44e35cde4ff789d95998829842ee75eda9ba3f23259603dbf22bb429455bdc27a0c18c7e34d97096b2193e13c3160feef2959b5aa584d568874646b01da9ce35d7d011bc1ae8a6b0b23343986b9b60b5107b88dfaae71c8270e210f49ecc1de9ab1321fbf5b4f811d6cd9b0fd5b6c87259788d4421833e4766c7c8eb3352f200b7106d8b285b49a68c940f6e489dc48b4687944a4c166355efe1fcc8754c7406019cd6d4c594bdea27322e3edfe32daf2539515c5c328dd49dfe726eb2cb668d7da7280c0c86e9de18f4a46b65280e40a1b73d6620e0d3e26d5505b40497208a8fb1761e4b263db6cc752baf188b82c7f673229860837a433b30c1eb2664925bd14278dde8ccfcb15070330d23e4f63fb087149b5e1edc4d512c0cc196df2170233a8f4caffb7bd5ab390bec2b91324d74e0cb54d915ac18d48e5255496345817b0d850737b5b6f36bad059e58d860642c4f724af2e454eeb1f7f2a81faa16a631c0789c800692b3150e6d6ac2c39838368a3839621c5a8ff68b1a1673136c7c86abba8d340c197835018e88024328801051613e4292af2e175b16a4cb876b6b71c8ff92b5e824ff595b9d9e0b4d99adf95979285cfa4078a4d11daa592d55553d7184c5b70e1c3488677296206fa52a9b2c5d1fa436beedd5bed148d029bf6e0800567f95643c77b66e759e80b4f92bd7c8d418ad477afffafeda4ad7a0833097a4a12d0fa22dbfe19ccae80ac2406d2c22fc63f72ad1e7ce95edfccfb867112266c781197e5cdb4afca0b3e59b7586b2fc11d547e04b561992882e72777a2d9c1077834be950c9ab715eb49927708917bd07ef2acca6957c48c1510a0d44dbbe5c38487b7d96db82c87d8f32fbf9c7a777cb3737340c29275f0209fa6e602ba34fab68940338dde3c35920725e1ad2ebef4eddfe29bee19d5866a9b7bfc3e2d70d5f3e12329dbe0562bedd88c0cd1444698b89b054475a4212a4d4c249df8444858fd77e69ab8aea8e2d6be5d3ba86459312a1d08dbf11e9b717d70ebac6e66c266be80528e58ce41f519822d9b9f9ad092429fcea7d4dcdefb0789fcb9253bdfeb334ea8748014c807d8f5580a4f7cbff6bc5825e338df979994fc12415ba2c6ef496cea371f6fe807b39c31041e4a1f4e9da4f636b346baaf5c12653cd16647388a323c60a51e5832d92f2c92470af565a872928bc058f1364316a5eff83cd9b73cb95cdc40f1842c71b92804737b0c2c04b8e2906aaf486eed12c3d1a47209b037db594d97c8366a72a11971664290819c8435a55489d8261bebd7164069e6b968f83d9ad6f6029b47fda427670a882a252246e6c72aab9f219370a670bc5f6ba4f139c7b7c10159c1fb346ffd92ccf598a43392e23a3072953ba1a4c552e3e3f5e59423f948a8954e4578f2042a6ef624eb9f0400d7a5b3666788304d2747c511c0ac18b2705168e1565e91b8c4854848508b99274abd89b3c3b6229553ba270752476524760279a31c436a7f763ab963df23d6d6248bc785b4d2d70eb243d30c7a6c3b672a4972f97cebfdbdf2367d3a7a0037e7df44568077990aa2d8480c139de8a084ab771e384c3df6c9fa2758d6fa79c1e6460d4cf946791a7ee654366cd6103055c593d5bfa1ea3348374ef8e973e244560b05f8302a05693c3615927e75fab60c8c65c9df17031b5cd91b9a92a3eda944ff91a84c1904f627be7c86f23d9e6ca778fd3a63b701d0871477e9a03e99ecf689329dd9e05117bedd4ce84213dd22610f9c17ebf7411fed1abc9113103a2185512b16367c763492cc39ae2e7bbb46f782a6205808bc7a025e4bcf56726d290ea77051dfbe22ba25f83b1ae0b3284898ae181e0def1c075c823aaace1000737dc1f79ba9b411ec718643567b7ead0d2aba58eaf742e9c9977202924d1842d1ab8e7c67a527dd1ab0335133297fca4ce09327994456a33d2777294357b9f5901a3bafdfcda9a9daab0d799144be70ae0f01611411b854f8c8e6497a89fd6057bca60c6224a5fb6efab2222338d99fd485a683438a451ee82b20d0c05a43b336055e319b53455834c00ece91ef9e0af16b5530aa329f3d4f44e08f3b1708b4f761bcbccbef178632a4c326ec6b8b9cf4c7130db97c0f406a188c50f395e710106a061a2f9e1a302433aac66617e639ca4298a49e75fdc810dd78865e4c87c2c98e77b6a894336d38bc5a46658fbc5c685cd4a11cd042eb0b65ce61ec18085ac8255359f44a02f3f03451aa2b0d832cf5f6a015e3ccc5ccfcd04965be3d50574254ef4f0ea3fc7552d183dca1f802cdd13462d65e78ee0edfb536e6c7229cfb40e31abf3cc8c3114ff171a5e730a47d3414a33ec5dd6d2889556517ba5f0cb4eb03a58718e73dc5ec84b240f8f055a64567949fd8d84f9eb3d3fe254f34b22c85579f663d1f3b4469ca916a3f868545031bed16da92c84570e1d15450c329122246a04a3de88ccf730ac09775c681e8362774d5f41426db358e8621e38f98e29c155aad90d92e83db92e950ef31b0b5f19bda6238cb8afbfc8fad64e12c8d388730f60a05d6b69b4eef763c85777ed4e0f63ce295381cc846198ff81f7ede85d24c20b3f9f3fcc70fef76df59000fb34f58c8794713c5d17aaecfd4de3572de995195efe447a76a79ce65459655767d75ecce836e003b13033fa79b3fa9e7cc481981277002f7bc28fdbd2183ef71c8d2e7e48e8302776900d004798321e113bac9e18ca07e8699bf11625d65cfb1ab0a1e9ca366b664cf7d4cb5b66d36694e2e26655fad56932329d3fec4779cb4645ebe3e9a0b749866b27b8c4c4f8b1fd87334c91a865d35b66e0d6fef3f5c3b21af7b355dd4020090e21ac978d1d1685457d757e7323753d1f09588bb9da47a856ae36415a399817ae0b5cc08e91054cfcf28248e43ad09f1ffacd026145b3ecc04b00fe57751828eb4559d0a71294e3db224184104e2893bc59664d23b21662a8811aa498bce4e30accd9b9d4f40e57c06c8b53d2f9804989255ac53f631ffcc076b6ce33a852e035ebac90bee92c0d9c308d846818f2e0cd039999bc07e39b4f0cb12157844e26ca86f9dde21596b4149b3cddf332a6aab432d9fc9ab7033783e7821716ade20e7638510eca542b0c2142ba825a28d99b6331025c355e92d062fb25db4978e26288c1e0c5476a1ccc3c317aaa60b811ea5cf2575fb80a680875ec4799002bdb4c24affe44586652b08fb1f09f0143354cae5f9fb05612cd3dee80db8649e4db6adff512622c808d9e472507f045cde2986ea42db62990a160d4fa1c14d02b1e6a4140f339ba5f23584c11a44a6f2efe013cb3646d5bbaa736458e5949c47aecd77252c949eecb4bb225c7e69e48e6ae3b9c8b3b32e346497f147cb505f24e12d0bb19a5eb8d99bca7be84f7bef58cee29d053d472554631470540493d090ef9ad18d62cfb608c50386f02473ec4b52975ead0f1aece44880f559acccaf5b4ee25f6f6210ca3c7ed261d3f7aba95f0b93c78ff335541587862cc53b1080eead5458b210ed6d53643de9a11c5801eeec0a7dea3e2275c848a882cf392cdbaf1434d014a393e5e8258fd0e72715131bae05943604efc3afefdf61be0e54bbeda8cea5518ef454c93e65249d24b46c84b4157062bd36bbbb2943eef3265e83162d1cedce8138aa6d19a7c4611e0776735106e60453ab367153ad8b5586d24ba9aace6044f5a24ee78101df57669a7d2a6621d802f252e454f3a9e634f803d4b3e142257b985e788f1ee3289555bae482c27cc20afebec3b453551031d37d7f1221b62cb58bf05a1cd60c469e04756b3950bf81a00d1a152dfdf1201cd34f8a30ff098e9387b53d0f62e65431c92aa7c91ea3a7b031afb6605e7cff51efedb319486c52b9a0d24248d4b0eddec1d1e803814a6824789412a1d51a824afd5643f3ad771aa48f03184bfa86fa53dd59a3d566087f859d19d7b2c2e0fc21191f30472c0ee2405f5b22b03af791850d24ff5f81bc138c8133b1bfdf073d9cc3fb6b37afe0e203178d480bd889f6578e4497ca0df36b82d25525f1e16fb8a62f2805321f7c5178f5fdd2187e328263ed5532e23e0503883464f262d9493a6fe3d669f27f6fee33b863ee012fe405a2fb47a75e7e98b80fb485149005580e08d0503ceeba3b4c30f3bf011a2abd93066c9be0a256695212f7f65eac2e9dccb05c70dc3850c1ecc8406bb8a91bf0821ea8fcc6dc659d8d2842383906920509baaf708e0434aac17eea46ddca0db46df902d35c250ec1062383293dc805b6535f4c2e48503288dc017f89f777719f926cae7af92e32c6d9f6c21cae935f8a1223fdff714bef917e5a2603b3273db2fe5a9081eb3d09e57f37e3a7a07156a82c1d3c851921b965858d0f36cde1d1dd0f4fcd78fe07498e2975a2f27150c7f8d6e61015a4bd3385559aac5738276dad0c1114f1491127e34854dbb2ccdbb67734093c16154b175147793d03dfae1f894d3f2cb3cab3fa8481e1e865d904d42bb3c963d5f7cb0d79e497c65c8220027f91c44016253e1decae6c079857d9f7ce9ddc50e299d0909ceeee8fdfe0d904fef54667bf2e9602738ce3b997a14a60d301ce8f2c6e7a6707bbe0005d4548cba2190a2b5ceab7c12ad9ec6fedf3e36b3123ebef965ab937a60c14ae0d95f10f9bccdd33bb5e0cb5d17fe4e17ac3c8c1a3dd17fc8dd715a5b7906fc31106460f712d7cfcc687c5566f46a54122f4a02cc29a71c28b586661bc5412515cfbbb2c5b5da1aead99139e1e7ebb2a6aff8dee269ab0f0f7fbc3305b6f51be4c57bd713f9234310015efaab213ca85ca6299e5cc2623567513775ed525f2ec18abdd33e99db40a1fc364b4c4a104c43ce9c814933e4ea77a9c2f6926b18ceb343a53008c9017e6510dfc36b313a5a048b40833c9e54b61dd24aacf97beb3f7e8cd442c106e460c093ba8670ed27826adfe2ed700521ea6fee99c0cd7347c01b950446f25191c3c9a0c160159011251034d38f2d87f7075d0670c720dd8c11834db84a54103dbe1ea9027028d7923040c44550c0c1d383877c2694e8b5ca84e077137afc12b523871377bd39a1ddcecdbd8a177f446a78d2e9113a79625fb7f3eacc79dcc3eb69c4dc50cc47ffb565398d109d30f063867869008168787e47df5556bd4fdaf56f100b78f881b0811ce1893fcce1e4d134e70386ea17aadacb98f69105481533e350471de52f75063b5545d0da985b9732365b620e0616cf3e1b8636e558b32df662c6689bfbb24747b58dba65f6d8aa8e9ef9260f48723c06f809da7941492a5100121ce5978f257b56371a379b4c7939cdb48ac05c1c9383984739def23a2ec97aee42241f32430672721d768872795ef68007d0c18e89590a6c7b698deadbb7f0fcc48bf7de33ae5c868938029bbffe3b41cf410e1d852439528708b752ff6588d311c1269be6018039f2045a872863d938ec544256893875968a34e0a32e4046f1d05edd96eb73407d8d0477897df0a57bf35625ec2ce19e3436131f07cffcae1d0afecda0f825e896d0a0b9e316e6f242ba091e34422c1b610689067de8d7e533b69f4698cb0f7dc6cc6a40f72c9713b822908418a8c7e877d100d8c59b812f7935129856c2462ed152e5e7c8a60783c953a2b6249189ae9834462d0e338af06d0aaf3ddff29ae413f185bb5ca39ab1ca869970a69aaa4febf309dcc52382abdb32412116268f1ea03a925cb0f7a1bb049b305c8ccc66568f39fb1fb9c05228022f7ce80be5283d1d8d65affe4fc29304e088b3a59dca8ed080d1b112abc40e20e014e79c9aa99491641f649f784bc597c488e24e8e3c1073ab4e3ee34c61da87f9a513ff011c9e2674275e6024668028b80520e26224870f683d20bed9f6fb1996403e0b803ffd51ff46160851b3672faebe833ee38ec3827c2b69bf4b92f63bfa04687eedd2388c5ee74a27f084cbeefb6ca8d6b20e2bc32afeb3e5c2a6002f9ad099ec181d5da9071a999c1131ba7f0c566a6a3ab310db20dd00c3fb2a93267b13682903920391287482c2b02bf48eb33bf9f0b6f7297c27bd07201a846de5ab075a817d6b9a6b17a49a43ec8fe3d1c867b58f555ce7b9e43aeffd8bcaeadc493ce0e4e44517c11bce0400ddc1b521ac4b73a58b8d2a161230e0cc6d41d86f29c6e44e08d20b51a2aa9cfc4f37c47c81e6e0e2019828c91377a52671f3f88238abbcd1b0b87e5eb2c14992eb2c103eda7bc464075f9c817a848fd79925f1121ce942590ae4fed405063e30508eaf5fec52b4b0cf660d03a03763a466334ec7748908fabf33c381f729da3522b1af7b8706bdf20a6e77377b435d987d6496fd1f58c0d6c33e13b0a12d53c7f37e0af3469b08e6b652cf99343d463712f5ffe54fb5f00f626bd53159e828fad123303533fe5f5dc6cdd3cc6afee4c41dc5092dbc3c6f517696cf5a4e5a6a78eacffd1565170f0780fe870685d0dd75bf082ffcbe43061ed6f9010a90b35c97a75eaacad52c6cb4ee9de0eee747b961b9b29f35641791b8721e4444e417d7a50c4af2cffcdc1edf3f243acce7ae283a80a2fd9e6b876608439fd867fdc5a860bd7d64eca8d7127c37ca578acd60af1ccadbfff88855186d97fea25ee946abb8ae490563d519d563b7fb65e0d778b74f55b31d5d5b37feeb2f4b738359f9a994ecc914e319d739f0c8bf3b0b716e0ec88d50f7f5b7727d1a18ff3e9c55b1ec72eb4c678193a88998257888572ed0d1c705e2d1bac97fc73f258e4990be675c86ed4698fd001eb075012d99ed632ece041d805ea16ebb7ec3c675e3cd8f168240c45c4204b06e65b970206a223b21a71e504369145397bfa540223b0038d6d7f76039edf4e3baf8773658d74961283c50504b380204e797edded33b00761ac3729d12ffd3c1b9f5f6b38230082134739c0400dd6321c578b7d6658735c951e5f04e8e0740be70bb7b045dfc4d4889a9c128f9a7a3674b3995cb02c202df680bb4e0128509e32bf5b3be62840b99e64af64abaf42534826f793db6dc69c56607df8a5c961a7581e4d673f4a0cefd3dff9adf8908a6fd2417d70002610784666d818fc445b68a473609ffe95f288d10a8ac8f06e9d30b329d49c4c5ff5501c3b2efb32e57b4c985158369ee959145623cd4db28f5cc66ae64ca2990f5658ab75773d3e0d7f5794949b7fffbd627def8d7557904684dc98baffd796663a898a6646c8a0ebe74ebe8ef74682b395c80f83fe595a6f0bb07bfbf19d7e2e618926ac1dddb8e2928fa5a82d0858a9e8ca975791d9b820502815624eab803c60d3e8562a318bdc3edcee870bf93d5833d47257c57832417c8a2874bf6d999c179a2e4334bb18e28b9facb1abf3b71c90e827627b426f7eef46e06b3b47ad55854f876c95578b676fdab87b30a58053b3603b2b0c60e740be07b63965b28b3822da91bc33515f060fb455f6b9fdd87b8705ee5b724cb1e7ea761a866ae8df1b0c202f3b368e78a377b90bef32e5428d3f54d36ebf6547503a6571bff4b0de4fce49af841a2d1fcb959846b69921f77fdf2af06130272ab9f7232c8559f4c5354be341f494b1e7fd312ddc055c0ef0f51d48b7aad315283968d05f68cda7dfe5dc06e651a541703546765f92933ed2636493d0a6c741634a11d6e1aabc2ab8e828db89e5b0e2d19e9336e72b578266b887d65d70e947720125943bba1e33b55b80536d1f2f921018b8a5a2eca0c84350f5e4a68ff778cbb61a8bc8bef1b073febd2589ed53c8a56db9a88520926d89ec69c7d4d19e876630e3db3f6f273e9405a0fb2b8922189291ca45894f10c71f92d5b27885b24480c61c970422acd12d0d33af19994c50d2cc384378abb83b86abb6ad01f6a2e803fba770716dddb1138ae5bb474cd8050410047f35c3ad2ba55efb6b8b438ec63e9bc6201d91c9b05e7ff2444382ccdffaeab0c96a4d6e3e7b126d1fe43ad959f0e3622c29db4b2b82d11e77e8a6e47f4d6a8d9ad20e84b92ab14050b80f4d7e8b9e3353cecdc0ed7b31000fe4ad4c27f07ebe61c17bc4a314bdb61b2e86b062d0ded34fa71a8fb344f68f3cc1239fb678dcb5e668036a889ad7ffa2d87ffc62c5a3796967f7e03ee8df1498b07a8a25b09b8f684dd89e4e4c8fd790f4201cd8ca40da4106ea45de1ed92d301dcc8832b36b56196dfb983c92a61351b77d3478297cfa36ab9a81cb85021109fb0b6eb3018d15fe7ae10404fb949901bd6babaa51cbda965c52238752accde94f6cee102d66c28e65bbd09aeabba95d0b8527aa022780b9b1513bd132811e75b9c78e0595a4c96415208dcf5c981ee1c2bcaff80917a57923cb93bed7277118539b5ab3f837a863002b70e6c865bda86640009d193035327b531cca37a025fea3a5024117bdda494730297e37af36d148e34c2a2e5f2e568d6df3fac08cbdcbb7f7bea6055c8f184dbecec5de3f4a0203490f722aed16d159df12716a41b8bb4061710641cede46c29f93c7c7e325280459da15dc4d8ca466cd041734806799a68485bb52e9bc0c2d9e4c49ef1b069b8e073f5948dd58f98e60a1202781fb20d5bb3fb8df7f0b15a776cb0c42b44860cffe52aa88b93d7e0f1eb2f4fc6448f42c17a217e4eaaedbb6d415415edd6acac0340119c6ff71896ad69afc4a191aef1c826dcab5bd946b3be1c5aa87fbd7f9a1d3e8f44e984b8ad5624039cb5dad442effb0af345e36473d5437abb440bd73b00d85201f83fb737d4a20cb57223b415ee1e2de671015ff057aa1531671b51fc7a584390c7883a86aed952eccca902e1e67ba2292fd6a3feea968b1cf21bb8d810296fcca6d5dbe3a1778f6427c4815297b855c1bee4d261087c2aece4f09decb14988130010ba2cdd3c34a8d00dea8a1345d6e8896b3e26b38dfc5390fc1d9c118dbd60fefc3fdd54eefba88bca0c29f418d114f831198c9f2949f75cfa4b1ebefca77e13102895c7df6d6ba622f7a1b3d6ef494ea4ad0ebdcc539a57d37f3b6381abd9aa01a2b1660306daf9b5e4e3b1416c3d5c4df63509331710a12464fb9fb9c9046f00f4ea1c56e201c2eb9120d25db3cd73cc94b995abb7fb5e36bd8695d45b6ad44e76f808705e78bea7e3a5f3255ff4d9062eeddd0de48ff5a70a1a034567992284d40514a8b2b8fd79832f06ebb34e225df481d83495abc520b880e289f4788fe76728a764e77cf14f671ef532fd1ec527f741c2137ce33d272e45250d7b4f2c4073ff2e6e33dfac88eb0d651bfb016481778399b0a39ff7c896d150dfc7740b4e63abc01b7c05cdbe1133da158cd947dc7e7d0f24d5d46136e21f99046eb6a74fb58d3d01b1a3a51869a2f31d9d284957fadcc039fdc21756e3296fd9a8fa29f270f46e633048b2e3c757389315a98d8712939743249b6ed6094e093d8b81e245effa2129698878340332dca7d1f941c5d16c0e68d7478c9c13c97c23e2123d6f587198520955462798058e659bdeac8fdb496b0c02c8e6af409d061122564b9d4ce1f3781b2a3b17768321b6fc9e8293a11f72eb30b1bf5c34fa93f93463313f66130de082ffa4e03284a281","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
