<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4a3b34c73cfc6ef4289495ee691d28600cdcbc840805ca6d83bb51ce1bcdee1471753bc075c3ee096575658cdbf4082057b65e2af209da35caaddc75fdfe24ec92c6b3fdaf2407ca81155850f94d33ed67df73d2b7e0335b77660640bfcf423629c02ae71c168c973fcb2a3188d38d8f947d5a4277a880060a25310063dad1d0a07db50ebebd1543c90a2247c2be6d1d1f05299bdcf44e38584fc4d99e73fee20848b094c7f882ec541c9674e6a6a78f15898b1432140556a98b2e46751b1e010cf261a2c1063baf09794be2af5062621edf0a8530b9e965638dbec41c6237cca44cd555b892ecd910c86bac7f40ca9880f27ccec6d18ffed9c642715a628a2dfe06ed60cae9bea792c8919b3b3536ea0d71f700861cf9fb07576aaecbb3e84ba5e26b9dd99c4ecf429d3056edd9d3e8359c8243c30dc256f03f5cdc9b6e04e9e217ab702c360ce33d3d074f36c6093c088db93a45e9faf137452f77065da7def714d58963feaa3db766b820081636e7f59b855c1b1c1ad3fee9119053e2660f2a926143b8f5a463c13a9b8a5dde7c3fb0fb355b9b156802199fb457ec1ff6558ab4c5b79cd4fe5b812108a9d41f2773c800541ffcc71dbae383bac948b649501e063bbd72041e2b97a5b952d5e5d30247cce5daea14f47749759aae8a6f3c63f9b1947005e904d734a213d5eb6a073d6c904c48d1e24c5667ba5005b71d52935e9ab13f88638741048cf29b9de55f1552f1470bd1017a2cd18b84318bdd429cb1156985f9ea5382b018ae94b7c7848f38dce0f16c37c3a6080380501e7fe92416555ad25a21e5031fd6eb93d0e359545aaaa8d10dbd3b84219d8dc6a66066682e918fcad2d4102fc12087db6573a037844c900d70a9965211138e3a02a567e47e0ca84c568436fb430a6149bfb37735154c5c608e136ce2f5d1b7697210ba80b8b0fdd0d78e28c42c2b4b737cb770ed5381a5f99a60e18cc44526f07801d48d3d0dd43e9e30100ec4a160eb64a93b0ec4919520955807832e0fe5fbf194b761cac1cf80a842700216bac27bcc640ce72d51d424bd9845b956105c4dccc17d8a8650a8aba37acfb5ad29806bfbabfc770864ebfa9b5edd4094cb52a118b2bdb3fd43b3055a62ea66b9c75867f587e079e69494214ca9611d12a45dbd7f622d44b0d003dc20c178e371fc388bf9107f87af4546f25a79659e0bec2fbd59b397fb4ba92b1e967740023d219b62a21513b4137310b8f8c6f87b2922904d05abbbffc7ee7cf67ab58bf85f86a1c5909b12a0315ccfd6596ca9633e56b4ff63f7c2cd24c9aa9bd90687565acfc2491b74d26e9c2453b60351d097302da4cb842490bda08f2a5e7dbae73778a19a633d127a185a385a1434550da75147559b2bf54060ccf0c3b13ef1c3df49106e0f63d447ee303678ff70b6f2f5ceb31f47d9ebc7231dbfd4a2c264258027e3a0605ef2854ac8a6d88426d4704521528c8a22e694da543d4079a8937f7734a0af4c3e687f46cfb1e31d4968fb20277896c05dddd66d877461c00e6b90ea18b8b017fb30ae62010e2d5d7bbe446d74d82c9c2a6d498cb4ff5dcdaa9afdd0ac6b0ea545827251400cfb130c017f413e428ad8a1349666a0b6158a897506aa151e3cecd42a4979671e742dfb0608bda5be6784b8635c1d042f06ee8b45ceb827ea3a3b221f512ba183065397f91e460ead21107f83c70d5219ae273aef68d3a486a79d14154d75e74b3d5daaf6f231487c8ddd2db00c968e04e74fad74945bc71205fa11dbdda1f428410d7e5db143a3f4e0a6c61626c62e1cff3137a774d337c149b390d40334a37e90f2e2b63390bd3d731b49d8731d22099bae5e16a05716367f1232e7bd7b2cd186ea7de13b179788169136539c13736244a71ce429ce007b5715e86c7b258e0c7ab74932424a09bbbb423977e09f0e26fc009103c7ed2a5f5078e5d9f99e7896589f33e7b67927223cf3a471c62c70d59b9a45f1d9a7f181c2221d52b99a417c1e134562210edbbee02fe520d071e76ff2e5158a54d3f7be4477a336e25c7a4995b4c95bd8df90e43dbf82efa17499539d022b327d6da36b191eaebf4ea63ece08f25c5585e63f647d33b479c9489345012324cd9302bd5d264bfcac10a21e91aeb147d43e7fbb05742cff9f49dea48482c41a62a61bf6c59ebe6907602e6fb7efaf6aebfe88f1cba70062ef470d24e858d331fe2af241586c2bbc5a96dfabae6ec2f2332d922f029146dc246ccd20cd87576554ac7ad11d95ba3bc0a9625164c6c5e82ce64b31ddfe9b28d1e1fa4fde36eed441c7e246a2e5103bd94c324060974deae82a5df7e8f6245eabf3fe2ba8ae23606329757ccfb505d48f214279c6ff907778cb8743bca999afdec9bc87b7ea2ca6a03c7af21594a03a4fddfdf74f1d1302eb682a5e1ae56f36d857abcdce03936dab47aec930d5b8e6f3b18e2bd867fa5afa04e514664084d69d24fefe5927f469999c9551012ca2c7fdd2c65c2bdbd8dda4dd5aa20de9a45759feab8740976871fa645edafc87436073538cfa14eaca5bdd7d744cb612a21a36daf0a72462f91672f5c58811a9682bad36de11deaf337c300df8bb066619858684a33d5143ea8c91db63179de07eb3c9cd6e6b0eb30d6043cc8434bc82f124bb96d50c6a399ca317d97a1c66db0d5fc103dfd5a8be074ba1d2599e3890a59d27a944eaed74e3f583c0797a918988aa42ef63f2adac87f3ef5e410811dafa8f0de72d79242ffcd278f87720b6f79a7ace8fd1281dc0a236ed6a4581d751908d4ccd31581c5b0ade094192fcc20f337c31fb663675713f7cd4cfd95ab6195be378270474adf0f7cd31b2ad2cbc497b0260eae76b6b13cbbc6e6fea04af26edc6a62ee5e5b4a58d48935a793c8e5604b22d14c80f00b76d009eece23428fb113b2c28d2e6f3b040772cf5b3c429b7d98f475aa5f6f4e5045967832637c322fd383bf817b1c1e10ab10c553c6628d5deaaf168f6d9f49be94bf9e5f239b5b7c817ccd86e8943dd90d38e225dccf4e1d21e07a1c7b4e28de317d29811827b3910eb32d6162a0633783e6c487de2198822a93ebdd9314e7cc1fc3accc3d52eab2ae0f481a60e67028b807ac31022bb43292999fc053353775f1f9fd5f4ece51175364ae2cb405dbf094f5248567c99e8f66f2f503a1f12d8883cc6d5b9698d29e369a7b3339b41df80bbfc9d940782bf590359f1777e7e68dd5bc14c714c50b2237e35402735eaeeab65e5bbda69a48e556ff9a0599d97c537103003693819217c3a22ff91091af16d146a562684477e2124816b12ce39fcebafee0346ae158675f837594154cf416c38b70ef89f634405e4a0df12a523788c66271d3cc9ea64a544c20fcb36c4f1448243f1f05f5c86e1a2b6c13b676d5c319dbd5bc5493d0b7d467af14eabbe43d5b5627edb758df6dbd5698475f4a7814da7ff75852d45d2892cd65492a8b08a51442da7d93949aa038aef53b3bb16688043159da2477b6969bb8a901ef4a40604ed7c60d08bb49c81238de3c71a0316d2fd4d9a9e254fc9ba10e0e1ba101b8aba51d666da2a005add29c231155ff98b1546cef58f31de04f6ea96892eafd74855a7bb1b00e124f4d78963336224d892b806006bc334c7259cb1cfa4650ff79efef0667f8ab5aa78eac3b85d4269628b0cc0e52b98fe05bc4c9034fbb6f0e34a430d27fd5812dd20784850ed8e0be9d376652fe1a7ca5ad35983be54d2dbd9c1887ef999cafca7cc0403185ffded79439ccb96711dc213102b17920a0cc69541f9537b76a5bd49f3617432cc820304cd9d2b5e410b8f40aa5e98f2b50fc846c1a375bca0cd35797f8c62eeeb70870adc4831381b68b41f7dea09fd520ff957cc948a01201254c258feec217717b3e04f9fd00e9f23e9137075a578725748bef7afb88acec024b75ddef8a0d95a83b2366c4f2bd036892a58d10e7fdba2251642ba0f077d1867fe735d41fe857b37326ec23566ae5681eb9c4abb485b3afb99114362f52960b1aa3d7d6f1a588be3313ac8f1c488321bc03d68ebbdbd5f75b17b480bcdaed1114078d7491c36233305aadd3a1372a946153af2569571d2079987766665e91e45b2acc0474b721c2d6dfe9091474f71165c435ac9dd7ec95c2145338aa0a41d046e84600f4e7bae7b13d8f9aedcc5a006228d90a820dfce7b900296d3abcbb9ea436b8a66ff50456029c37932e1082e3e3c080af3cb831fd05d00c96725b05f89b135dd312b60a280e39cfcea0dbf5a08b1dc5bbf9566a449dcba2fe389bd7e773281d7d54ba62d698a58f52b7c73f9af30846e116c4c49a1c9092649fac1e7542e2980dc48b7ed6de3b9203cc58abe8e750d8f1e7ab10c8f836404bd9d819ae7ad43b9d8844543d07aeb79c95f9da95d8fa647cbe1734ca80221bf4d7eade5bbb919d05efe85ed935d56513a3a842b46cde46a15bc9ba46a8d98e1bba51b50ab854f0e992db3ece01238b32cfd3b6bd3ddd140df40d6aab92328677d170fcfdc4981549a15da20dfde1b5c09df57c7cc0e48dd96bdf03ce82f3f594e649ce79dac50ef2088e1ae0fb7267da1cfbe55e9da2c4b0fc96ded815594bbeca36f2cc23334e0a73f2fd1119369f9ba4a5a56818e146429de5ed3cc8e5b575cf98ce01925f57c5cb8c52a923dfb87ddb342b24e70b75a4b1dd3a6078575ecfd44b9b8cc8d9197302cc1330c3e38f391cf9e2a63fd1ad02722852c8b1456336da24fd6514e94b81162b9fe7ba25a57fd9f2499e29ca3ca3cbd4543a3f85d0b97b5d4aa0a61d0191d561501f404cba1a5c93773c9cacdfaf067235f543336f58b53d3e996d5a322beb297ddd64274bfa12032e791c6f67429451e756f54fc7c8b2ed46a4c6190a25ee9600c6215b5a636c056e01b85bdcdafdfceaa1d12ab12b328e8d31bda83afa5c57db3e5039d07db663d0fd4e0499353186680b98c2c690918f824a5d3b10c9bf1a1180ee9fac5ad81259fcd461472c2ca110c4eb73b9135f3a5bb81229bcdb35cda1c5e00a7effa0534d9e7a00d1291c9dd675b5c36b8c7d7021a0b5d42579a05e80c2ec11f9550f57184bce69538266ae66edf84292a5adcbf014f0f98ecca64e5ba199f5b930edc981a69b354bbb2e14b437d6a705eec9a761db505fdaea428579412dcf3e9c2922cc4157bb9d25570ea950404147fec3b29ffb130e805b4b4422ef519a304c2e0145f32f2c5092ba523eb6bc9fa2132f33030d59aa55cd54381adf9a1c2133f5f1744ac9aaa31755a4cc8ec5f1b619a2860e6561bc89db91aca3dc62ca344c9a0fffa272fb216ded040a66655a6957e3fdd55240f1b098164c951104dd9189c5b39efaad1eaeff07d5708dc7b1cedda985921bc765f944b266c5e79a5ae365af235a38eb853a88f151efc4fb6631fc3735f8d065a9fe4a758882bfe1f86b07ad16ba020608b725c2f3eeab5cd1cbc87499d7deb610d7f7a983198c5b78d0f1aed15ca65acf55ffb659cbab506ff9896c54231922d038f75e0bc753f636e056ebf6ff9fcea706b420ab937a35dd0952476ac3e79c42e84090623ce448c66ac6142d2a9fc131445071edda7521565394f3b18462dec42171f13b46446b0951c1e67b04e0e789d8fe08ffc5610a12e2ca960305af1067e4263bb00f8d5935489d8570a5af46cc1fe0e351145a59b206b5b196e0fcc555f9accf7eb302c5a379fcb8716d5b833b28e15f09fa65d84520cee19018af4c146f23601c8ce69e5efee26a6b7dc3a5a338386d54061983930910953d3d54a2712b299c12844533f512a40b4d943393782c0fb90e900ae99dd401f2d6ae3e90fa6498901153679b33bf64ae09cd03528859f0c08dd1f77648e61b8f5e509c81b4884024267346df4432335d9ec15ddcfbf472beda667eceba14ee9f8b98d92c8cb436b3cc34d7de41c276c771fe899cca5533c4da1e5c0c0e6105270505f6b8935ebc48b1d63743283b1a207fee35016505434cb105c77dd03de7bc93878e2b9c93e6998217615b35bfac462a4a6787129bac515bbb8cea23c805799a4ff10a38265428ea6025ec8e8fd21d927f8911d5031a037ccd38bcee5c42f3c15fac04e7965be832f99aecb86e43e15b20ad6c94a3e9991a5d222d0eeba4c86c6fe866dd46fb601fd161cbc07b98fcea990a9c2c1d15a6be21a1ac5d2a2297995fe30963c51be3769939699ce9038f475bb2c3fadb60ee11e217415018271e0185df67e3b55a94a292de10ac8d59884acbee0962663f3738d9ec7d9f5970c5dc64a5486a5fa08c179bb68f4a7aa330b9e538e4e834e7f34aade6ec0ebe7b9462e8115edb1229c600c0398c4865ee52ad0fd528beffe9a89fdd5a59ba0f62d8e58326b4793d5f32bcd2be8f2395b17b42ab5c3d9f7cbd29f3de72e19d5cd24680b0c90c70a4ac9939e9d24b848adc2fb46567dba68d54eec73e370538321ba59510c9854135438955b9494795b0bcf03487c50765fcd7f987a5d80982ffbdfa75340778c1aaf197da5e84412244d6611c66d275420b01b3af346f172b683d8689e88a978d8f3332ec9b963f003c3342fb93a8445cc072acdfa2101a77acaf242befc6606c1f0b611db4fba0a9cbe3408e6223f0b5502eec7cfcde333c2bbeecb478253c30f3bfffc9386ded366855f2cce0fb9e752e4afa76ba9b7c7f0b05b8aa93291cdd53c71d59ac79bacae79fa3774003500b2d28dfbc367635a7a761e4fa3afc1c9e22781e34adf1a8d5132a703fd2348d875d99e7c0cdbe8ccc6461ee3ef26cc4651f806c13d236805fad0caad22b4cadbf36335fec61767fa260293524e4c2bc46c9db1946790374b3388d2ac455c608d3a08551401d6c78aca170eff445757d484b1c9e8b7078d1cadfe14b6f17213525df0ff1265cb2e5f2a7e6d1a9f56837388cbb727929558a6f11946f4c81384ec76d49b4cbfbc2265516db118208d376c2644af2093ba4449408686213ec8a132846e2a3880754fa395ad297e4a9679b7eb781a66ca225bb7636820fe2afcae4c3d04da29177cf03193922d265d9b4f1a8d6c977897d8cac2b5d41d592cd6690b3f86e9d95cc3c8434ff2d30880a61b26adfef42d586915fd26f3447f49bf48ee380daaa32c3a2125f68831121303df7b8e1395808adf53179e9c38fe9ced55817d5f3016b5a6ca92dcc952ba1e8c0e76531209d1abdb7c5dc4c05b6da734478a964fe16f44bb0e4b7b080f3804d90e5909f43e627e559de316ab0c6cbe8e247a76352c7c9598bf82f37e8963739453a51116794e7d368c82e82fb18afb101ff884027e0efe728111d47ccb441e704273fabb4d89f5bc9d36451104d19f29acc8e8e4f1031479d69bd3199ae2b8457615d8bc071e709cea2572e94725daee82c2aee85c5a6601c5f34479e08f3f85ed5ec972ba9f711171fbf3754e03c4e05738d406f85f81872fd3f222fadc61b3bf4978988b90159237916f79aece30f7dd6d11533943a803037875efb05f44d780f18ace669f224d03c40e2f147bf653ae648151e426c785776258a92349bade860392a50830001f74aa7012fe41151a634d1094769be8bc0af5bdb1463a4503674316020cfcf7d341f3d6de59fb44b5ac2b949cd795ce720cbfe2b89f6443bfa3ccd81a3fe5b45ac6793d770c7d16e45ee12c7229aea5e7d046b741fcdaaebd24ca80d6707ed309bc5b5d0137cb07afe5faa5308b901356c8a39951442d45b7cae309d2dda2bc5de73d28844edcfdd8190d0280f8ec01e548eba8da9300fc359f51fb9bed33406e737bd514afc966e179281f05217280cf5bde689d844eda83f45cc7d055fe5a8e5fa5764b29c0c03a26d123817464adcd35c559536840c8d0871d7e599b8c48050ad21a0642d39e687e937a1c5c1454f0c63e1ada68ec7547a353e9403cc82f1de34e885c9fddc220f6da0c150a9e382c7becfeda659c30d9fddfcf9e74b220b03c314a576ba784ae84b531f53e1a1b75a57e6f1d5c76d385ecbff98d8aaec08004ff40b79f56fd349b535dbd3ccbf3f953456de8a25e3fca7384d38fddf1ab83afa59b939ed70857649675566d36141f26cfd554c07285f6c1153cccb16146cf9038770b20da3d22191b49038ab2d5713c617b617237c7166d672b220f8df34eff2f93ad5910407e3dde122c2864f7b37d94f796fbcb75d5cb02ba66c5d4d9cc4c9d4113ef4f9ec58334121bc3c28c3d8a053d533a86282984dd5f3ed6477f2a8a76e6a80c5e1e19d0e7d25618f360d586d728ce42f219b0e435813d1d766f37dc1eecad3bcb08b0374e89c3231b32823acca8d8902e8dea816d65edc7af4bd5bd595f818315bd4a29a7aa8905fc999f290bdf3f6428435fb392b69af2e5979c83498c41b6121438188faba5f9f2798b4dd9cf7485d672811dae986e7c235522c75b1da6a217530cde6e30f7acafaf043eda784f4288c0b41cb970daef3c807b75641196af0eff06160834328df7f3312ca1ceb2db3672d69dc3ca8bcbb307c5bd737da8841e456041c55e86ff8b64a1d5cd575b9a132eb8f514ea9d26e721f57d34a5f6d5039bb218b7d6b6f393d168d03d2f076eaf18d1a5dfb025a1101f849633f1daf4a6c0427147aa2a90ea085b91a534d5783e32d3a82229c8d53d72dbd40d29d6894bfeda5af9d8325f6e9ebb6f0ae844f9f6df3081b26c997046e68da476b9b02a762fb16131d1469d43e6927a17acc4e240ab199e1f4db9db1ce52204138c25964b7389085c5ec7dbabb085ed523fe13121d413925623af7dbf500277e1dbcf1d4b67a788c042c3636f1ced47cb2d8730fb9b93aafb7e4649b7ce35f8003b5f69da94e4a5edf11b4093c7a2a5c48e8014093f3901700d4fd0cb51e5dd34738512ca3dcae6b218d32df084b8f3ae4ef86732125a550f8ca0e2b25479bb0cb6d2fd4911bb1d27bc7cf983a783c7026b2972ee0a1965cb65da92afa745a10d6b8c2c55091c96f883948082a1a5dd11c48902692affcd6d8feaef4b3ef16d98ff942ec87158a62747c386725c86184b06130d957ece7c8b15bfef59c9aabe19030bb63daefe08a281f0a9b2314b4c65d47674f50e83fe37ff954e7362f0353a3eeddb0583339a4257c7c72daed32996464782ad0ae3705be4e5523efc86a06bf18ad9e267918dab6ae54687f9e35ed03aec2219f7b4256c8ac7168bbaef46d7034048b6e51b5d1bf4a77f14edc2fdd771fb830a0ab27a6ccfc2da404ee05ce473607688523d64dc4a4f9e21507e42b987ac2d2c8659b63aff660c6006a16f2ce0e2c3424f5ae300edb2c601fc0ba7b55a2b359a35d46ed047998d19a1b36d4d78edfb4e8af570074c4b0caaf67c35a2254f7128735742b64adc498a57df762f53afa4095d45731a0389dabc2b4a63a015a54b47e58a65fbb28af5feb5a84e01e1d4a4cd9d3cd3bd3a4b7abf80cc7d80a9d1eda15fa535666f81ad6c3d68b9dd8140a939d5393a4e1dfd79ae08456ad7cf133912ac5b4f2271a480493ef164d57a43a181de132e085e21f50c6cb5bda21b59431041b72a6fb69746729373e4fbea79b180b27a22b796b5ecf14cd93bfeb76a8b03e56eac813165cf05ffb6bc808d345a236c1e8dd07f3947be544c56b0fba92b567609b1d135d7fec0439dfeb621295dc75e63e53f65dedc18d246bd4b8ed5513216bdf783632b992bea37d633f63be9b830383062bba411369588f9d39dfbbec1b2561d6f1a1a1da6b37f731f4864727833d75130a69c5ef7afc637096387eee23ba8ffe77c8c17a2218890585c354675cb96384f2deb488fa1af4d43c275bee5b99990ff892f7b84815d2697000a8883d761992c6665c025306526267457c4c4cd65b7239bffcee6d60323746246ae435a78c75a1957d7744775f7cd94d75eaf43131631ee0afca360cf1b104186d43eda09b4abb5d117e63d16c970232c8ae514a7ea868fd004d22ecd8e0709f4deacaec709d316051d856c71021923ae8f3fa32fe8c56d1ee1d25be7e5553d5b2cbcc8de214949aa77072e3406150c4ec23380c7e6ab05982bf87cf656625f34277750897449c7cd95fadcfae93308f167a928fb3bc20ac8364037b188a140992ae043e2efbb73bb651889847eb1865f2b4bcb28a8624dd1aa588aa3116be2529cf2dae66659cf30113f00e2bff9bf596ac6af8adc3cf00b10a9f7bdf99afdc6e0310cad8e025f7d1e42102acf24dcb61e40a34beab38bf77e4a12f4dae12829cac5ef74447251b3bda1d70fdb106f278e952aac55c990ca05a256ac0736f19a0af82e6418bec25c8e6570d128df038474c8320f6edb688e9b2b17893f47964514f9f9a61ee5e9c3c9228c96fc5fc05ec0362958952101f99b365dc3c05a368ebb47ab94670d3eb68842e69b95969bf4ac21d914238043ad5061ce83448367d65247d6e4e9be67c4567484b5dc98c1a03a8823a85ac39917947e922013c51fdd7ccb76db560432bdccba50cbf98b98867473768cff0fbd3bbb407cd811c4ed1ccc71f87a3adfb04fbaf10c1af11bc6e1eea5afb213d4f720f91504e0dcadad81e1fc4a5ea2afb0474835c6b3d1f0bd639af50cf0e0b438a875c091cba831e01c419b23e4fba9b78c8692878598996c4c8f5ae0b37c6686ba12b120a222e88c53123a9438eca61235160d85c380c9aed059708aa5baa68eac929d8ded8ea7028507eaeb9a4fab4bb029f6c0219b68e0f9bb1edb551d2a5a6eb3c0045c41f34c155b5c0901bdbc5351d9678698650bdbd8263d9cffd9ce2f8c15e8c9d4d1fe6902210fc1109b15f21bcb8e359330759cb00ab80b7e3f77eab242efd55095ac897907d3c34da80fdbf88ff7c40408992b5a027be98c9d584b2396f8d0118243b33553222d26d4f979ebc1c814548b87f79609e21d4d801fdb249fcc899406a1979f125b0ab2377ab3183a589d98236f30f784f482dd0be400f2617e76150b7b400c322e420daecb0939e51288d84c9ceb379ac1de76487f91ad5b18e219f001c1a32cd6fce2b244614d3a99f009d33fa5f7239d27ba8594247e43df78c9ec08ae792188c66c798ab5d3bc6385d1e11f2417cb08de9b0578685efc33d0078aae629edaea710ece5a4bcc784b3609ec202cf85dca19a15faac5029648dbc039ec1011065bfbdcf472fb81efb6c18681e574747eac1dcadc4c5925d088f6a287445ff2a893f78a6d7c93285903ad573b648bf071cf2a1d97c5324d3bbf3e6a2f82f992589d0b0ba0bdb57e518e481ce68364b712ba4c8b2534ac733dd1b876cab31fb78de713e5072a4cedac13c5cf309f48a76de1a1f235ea511be3420df9e31004e801e8942fead02e1b76595fdc92266d08032f9d66c920aa6b7b2efc364225319549ae5c176309914acffbafdb78b7ec003087debf1adc0d09a57eacee20fc64bd17ffcf60aa067118a1dc55859899cdf9fa499b6c061233a9b85fa98f55fbaf1560a3effc54489fdc4f86d33992cf456be9913f6e65d3aff5ac3a3c74dd1f11035b2d01479e7e7f6db0960e05dc3af416155214c33011a2b06a3205299ad5deb546ce0dee7dc787b938361bf36e50c7ae30e5b69067e05dddd6ceeb07efc16aef254c15bd1b373763a65d6c47318ac6c35b3bf6f154fbfbc307976223e07423cfa8917c8825c27bca1f9d61276500edd68b8827989b5c3b5a43e86a055663cb579606ab9b6eb3f079c6747b247f6b08a150fb4985c27904961d31f443ae0bc7dd372d557427ad88ea2209d74c6c2866bbcebbc9b89f855f27731d527921f031c89d6a7ae5e4cf2545b76d1813ad4d1a90aa976da49126b8112cf0158aa20a80db57f4d2cf3dfc45beb61fd9e8eb7d6372daa6c618e5068a011c22fd2a5f5537a417eecf87a3996a4bbd8f66dd9d8ef7a3fffdc53e6d969159eabb801e87265285fe0395c03ffedc3c21da4f38f401920a86f119591b54fdfcd74f3b7904fbd019b08c37e3fbe0addaf86c3fec5d3f8b9bdeac1dded6822f8f16cea2f414629aa3e4415f5042ceffe1e08c719d623f132e5a5967daad19ebcee940f321de5c1cd34b7445a695aa571d7757e2ab3c926069ffa33b46ba8f7c259d367786134f700d14bdfc0dda29b04b2c359da594eed4f3d86f32cf374107bf98f9c78609eaef2f9d3166ef96b2e906e866472f87d3662bfbe0a13a2216599561b32d6dd63410204389747295094457ccefca9f1be7ba74e473ed10187edb3781766075fc705b4c48867c38b22a44aca7dc07c4175e8abb3db86cf37f30ccdfe15fc8f6fcacbdb487a062642e8308c11ff8404a4ab828900832316ddf6d2ef8d46c9cae0c96c54d69eb52ff0eff59675236f7340c560465ea0adabdaacda299a8ccb8a8f737250c3ebd92a71e2dd5bc42987a92011f4fe5007f591819fcf624330c86a00cb3042797175c3856fea10587474a4ac7b054bdffa749be3e527d82d78091c8dc8627e1a0bad8306aa62a35b3ec399e6393818545cb99f57357471bf32fb6a2b6c8b8390b721f08970add4c3bec6ce22e7d088af3d69e392fd59cffa9896a655718e713f09404d839c983ab9313fc242ad749cac2f6918051c7b63018bc8b9f6a51d764aaa39d76e841f688caf751e5089fb95e3fd7a6480705a3456489b265d5a9076bf030260fbf6132fff44afedc1a6cc717bfb044fb813f0844b4751901634bb4cb4af0f04a3589f853ad18e00d95e6bff1f2ba60636adc0c5e2e2393601f154ae850c29804bc9c91cb9d319a8c8b7d91c907f48d51014ef76b089a9d84117b5f1a01076feb16b472598fc1ddb3c34a6efdc62bd7df50fb1925e1fe5d717bbad705711024b6cb9f98e4fa47a834c7709f484a829f870e3f7deb298f05f527720f155cfc0bf79a1ba7616b259f5eed7b8ea3bc1c1e19c594e37efb2baac19a8fe82197a1035eb8f9e5bb6fa731bf9e7cab8f72c30ce9da9d9aa9f6ac647a2195f354f99a0cb76bd5baa3ddc4c94b5edbd078be294bf60da21f2f21848076e8b06d6cb0e386fd60b9db0a35e1ba85d7293ff1fba59330768ac64ef60f197197d125ded8ff8db790433bacdfa231ee4e9e3ac10a2e1d93b5295cb55e42f545c40cc47453f34fc0527949519c140d42c74daa788d87da70e04d059546e5bfd65f5361d4d3afba3980c320069df48acd06a817ce673b807f1ece53993f7268c451180344c0c393b482cb9dc33e53d0cb15ada89a779bd2ac6ba647fd5425bf97f90a178afa3c2374afed61991a48c44425ed489387cb43793f88ef8d8811e272344e831aff3ba69b35143862019e8ad772fa5a1cfd8ca6cd7a41d0639122ff7ebdb6098f558c30d9ae15c9be173d97449517fda059095c8efc50278fb1062633aaeccc2db8367c7822c54ef3232939da97bb6227da144c8a062a11afd09fd282345b1df3dfc32e4793bee3b5d74bbcdbcc8290decce941e1cc4ba4c0eabe817111bec5c2da80ebbd0d2fd4139529b40f043f387e6587e6f9e2366c80fa5f35e21512f8e87ef8c91c3ab3c535b017806d9c52ef2f6037f6db9f99599456b6cbf3b0f0cb706079113ef6bb55218dbad8267a4c91ddfe1106747e2472c031bf7423ff0790e389f3ed0a0b1c90c5d1d59cf2f44d58c7df14f0b9f22e1d9f0df88380f13cab4dffc5867c021de6d4dd334cb18f7ce303b0b05772478319cf7f490cb41c6d8d14953ee8182c0906f6338d9a7350037db81d0b3febc480ce030130861e701b34d5dd3b61800e42f20779794a58dfba34bfab7e0df709764918fc51d5d3569ea16e0b8a54f743cfa4e00b8be0974990de4c9bd73970cbdc3bc1265fdfb5a35b8351f0b4ff4e26ca54587f35e83468462ea257a8278798b4f02a0eae1981899407540066624267693b1e778ac6cd39dea613f90eeb12b7779451457b976d1cef070ff71ea0c23d1473887524ec3154712aec6e7e87f6d09a9ffe53e47e7a17771d8b6fca135b99fd661ec9484644aa28ee5b65eb5473b0409d1bbe3362da725d5fd6791696a29ed2cca11c550ccb262eee13f943f0c98c901c01e1b028c4b04c1e088b80220eb85cf440951b6187bea44b72fdea7453fd8747ba27c4c5239a1bafbfa65fc27bdeaa34243a9abe64c6332965189e30bb0b893c63fdf152645f9d5db0ea265b24e5e7e884713e9124ab0173ea7fb790714e77bdff02a43fc7c95cc9250d30622f79549407250b717d36e5f0291afe3b5c75f4addc2bf97048173334a30e9a27504b9d41435118f1d67e217ca21e65667936c7a5b42f132ba8a73d8cfe462781c3ccd38ea2ab0860d48af79ad12d9b0c426781bb9decec9a40140ab8ac1f756f3819b04c56efff2bb84688801f37b3163a7375ca5f09a8200017e105b132204dc7a0a63aee41bd13fd67cfc7958a98a173f4d1d178abe2dd45bb7bfceaaf2b4b7351efec04088923a358d72ba61ef47665614b5e99819914afc8849867b95e9c704c7351bbfc115201ab5ea554c68761844097fcbd143bf8e00a288951f5d8922eb0fc6ed7645449d8947c22c4720cb21fa2a47971b1bb735a19ff7812e3247f6aa20b0a2858c0fea","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
