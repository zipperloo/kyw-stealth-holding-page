<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e8ba15052772cafcfc1d2ce733a036d088404a6a71a58789e0d4949a662ad1c332e4dfae03145519eac8b0fcf895ef21f6028c57dfba331d4bd1b24e1df6bfc17bf2840c573165840aeed0617c9f26bcccc7cb7d319226a7c8001cb0db4f42ef01459a697084149729ea48db5f1df60f45ceb137ac67a1790014d9d965da766b224255fc2ea0361a9f79d3fdfb5862c79308dc3363d426af285375e07e1f9242992ae836fae89d9368daa5ded62dbfda4e5c0fac0363a8b477eab9b1e95e78393989495a8c08e080859cfacb766920fc9102358b2ee2ed0dc4325aa455d2b9f820f0367b9cb10ad1cb2524d3a02bf25e7950f3989a5ab3477a471a376e10df352f556bdfadc8971ed61722f4b95cdf69a32ada2de98fed44447c3f211dcbd9dce50cdafe007c045fb92776828c0ad123b7a5aece64b8be7fea3013ed8db42edbeb83f9aa1d2e1ffc0fa8729c2a7e55a6fb6e962b7f9b8d590fdfac28eb48a160b59963cbd9868a4030eb0029b7fe9b6cea6773520819f4a841ec60ac5f5cad9ba23f07424cb47d85b587d53cc8428e31e6040f3f8d4b1e5f1861255e54fa75c3a90631365708d1e19b99a56bdef83c364a9ee6a05f9cd27f251de00e067bf420b16373a066f46fae077bbff2d9b942d9842da2f0e5ca8edecbb8b60caf82b7abf3be64f6070a44de07d14a2232e64dd95ef87ba22e44f00438bf71b17647b19f948a9a207002ccd30d4a6ea1d6e45449cea56ae28b71a19286eab61cfae6850405786b2f43285cf08783f2678636023c9c7bfdc0c30c9cc548e62bf62671e0b960d42ceb349466cd52cb252b4bae4bef1581fb0b81c83e4f116df95ddadc97cc6920e2323dd6e0a1e4d44e17057e2a1eda3789ad5df075522aba55cae4e16fa42e1a99452527b5e4e12682231362ef8599cde5368ce541d2dfc84ce72b3dc4394c0abbc9877c1781656018d5abb0c28111487655bfcd091f744ad2a6995a864ea4cfcbf35ec9b10abb612900c0b1beefe776a441d90bb288da8c18e970d9e295935dcc19aecec2b72b0ae5d21767031bcd2e4fc934e069c89c2ff68556b6b18e196011b9b2134e991397454f01575f08ad77f24da3ed2c658b02147a527507cb82caf81de45d2a544a98cecf526166cd6a57c9e078f64a17bed0469d9dc6257ca6c04161cf119d9a20821ec27cfe57ee41ad1375c167d2eb4e91aa984c8fc410e20d84c9a6827ea4a784244a1d8bc2a6806610bacee6931f08c68fa3b23d5576d9cdedec3fefd9e2f32f8b871eb772485ec9ee626231c511e8170dd17961710c5e2eb4603d255b9f0822c4539c8f46970e671d84cd4397febe5a7f57957010c1bd22708d8b66e8fdd601c8a4fc3af171ed8330f33896462aebf1c2750e5f17c4feecf5413949a247566017a614edfe585353e8c85a62689725c4b56155d4e3663c27c387685d15bb6323895597555eb107c60218205dcb2bbdef9baa4cc8bf9d91749618102cfff9855199c8da7328fd83e4d72fe30c12070edcd9c6ad7695d48b5ebbb8879bfcc9c95af04845208fdadec061595fa7f419f9a66014b57d221889f84dd8ab0e5c42d7f136803833e79da37f350b6ec21051ed678f370600f7950856a18007f90d3d24831230042039b61e2b019f89be72df39a7bc38860ceac45912956d37e0d6ae3bc7e355e726c4f8dbb36bc5fc5f34d673f712c926b6de6071c5b6e318dd3f9c92a8f45f28fbe4c407aaafe544f1656d9cd251bc52411a4783077be4d2385865603bd02f932fd0cf52c0bf995fed83760cd4c4d74ce57498bd0c94414c579a9da3abba8a653c9708f286e9a50e556d49fae93cc458e1c90f8a0c16487b7867457b0db078767360bf2ee0de3cf7865308b67f3955b0ba5be0ad1a58680d78424e275cdfa72e98b7bf96e6b025a37159423ecbfc6f671f4e7f9b404e528d6813580f6291d1b0b060cb96f188efe6979928f23705fa025c51105aff47648f1eb919847114edd7f7f759adf8ec8c4a8ddd1a002ae1b5dd4f4a5132c01b42703e01d828546a8e55fddce23b506cf15be424c28ce2f2293ad9ceb9fb4125a6860aad263592f8ceaed2ab5e780f527c815c366dc9745565b9e1e9db4e23302d86ed5c8d3d8db952afe2e3e65b9baba41c2a06b1ef847d09a6905aa5e71e7d58a3445151b4818b38bfcb2da7efbc03145dc9d0331047e9bef625d4d2ec71fd457bd7e0090a93a4f3c3f28c4d69f39c3d4af561f3c44998300ae35bc56b9b2835e587d49fd9dfb0b38ef190aeb73a3a6dfb42e3c2f8e8a6b8012f2f472843f227974e3cd8428d4f024c90086732fd66a91e702972f5ba66dc155ec5c80daff5ddbf053d4b092c173d04940a978e19e474b0cac52444706e9e0a9a8bb55ef23e36ec563e947a333bd273106bc59577d1133b3b362a7d54d2ca750a9422ca1883f67c22009c71ca9ca6ccc02d219efbd0c0b322075a1a7835a1c2db25c93e501403c109eb28f91d863903f0f69d383ea5585e5d830a7f01e051b6c9f614367ce197c9f98eeeffcb9d0528590e425a52c918cb828d1677c116f926330f8aaaa9b439bf72963be1760debae24efba71464dbdba6fec980e21cfd57265061d61da96776b86a7f1ace0eab5f55912223a6c12d55224c6b5db112909f08cd8d8d1c6d5be3ed067524d23d184439e62affd4d4d3b19fa4abf9b7033947ce0c06d0f6ea8ed37574287401214058001790b439b2c312534af7ffdc7660f653c6e452eaa014e38fd0ba8e04118763215bbdf5065bcbb2ad8b16559e80e8a756ff67567cdfbceb91152da6c27d4c7c4836d6b294727920508f1411fa19b6f0d034b34646a4d69cb08016589679bcc1ba177166c70ff4e5c1b00238f7e8d794e2e8452a25d219def850cf7c50a883e4bdc3c4a9dd74a60fee9fabb7019af75dd64ad62a008b9e848e48e2a3ae69de1aa6c3a7135f3e46758d8d714f2aa7ebd93f2e8bbc202c7674adc85ad65b2aa4c20583bdec4f8429e5c75fc17bb9c5c185989eb442bffde2e43cad0914f8ab09b13949043a47f08c76c16a84b4b1024750c796f7a88cd50dbc29150c478a76d2e12704d3fdf62b89f32029e98212e4da63de8bb6b3cbed62cdeb240233c01c62dd21003e1ba37377736375069b80615c6f295a24bb93d7784cb276247eab495151900f527fa1e4ea2423f5c0fbd837bf4612e9a2886d2f2c1549f903112fc04d444e5a4cc660aaf7c5a1fae782404655357428aee079dc8708e16c0b4e989c43f24c4b9fe99c20fc31cca2705b30d6d04ff1bf4c85e49c97286934fdd0009a3cae75963456f70649dcdd19e0f84e49a79d9a2daac3e9a7a9be410d8c3f40f94421d053eebaa7e7ee1b7adb1ebb926ab9ce53864b008eecdcce27ca15cbdd2bc073173bf87ba7e1884b829f1d3faef4247d6e2a581335256e047cf32e407424eeb8a055422e74a0f565ac2036c066ae4c7fe7805f2decc1cbd87f4ca317a9eb19b30fcaecd30302edd57acc36604e87e66e6aa16e02dec618fe7aef00503e1917e0d9e85063f1521c48c8914a0235319c00aaa8788a9dcc83125a1de3130fda31cd5ebd2be64fa99dc2ab747389e82f9c764c8c6d38c4df336a7487056dac17f94cd524aa6b68cb7077ed6d0958719d88b2a5c12a3545f7bd1d2e07bfde8706d17c3df513f78953f01f3fd6e5ac5f1cefbdc494ca83103f925fb1f36d0da4fc811915813d888f44d034257207305a49cd49e07fdc6a73ace04889f1d11d65554d6f5fe67ba67abed18dea8711b3e0064f3000f26e3fdc79d5cbe7786be81f50f6ea826a4610a6be25dac460f95e7dfdfd45bbd066ac9e6bac1febeeb9afcb1f52495d7ded5b9244ed8d7fa79de30b07ba0d8f42bb5de3d5cbe595ae003e4362aa6ff409cfe029dc607573b730afc02c15c66c67861bc85b24e88654505b1120777998fd9b1e4a309d7c679bfe6af2ddc9d6e454e2d569ff3b81b3a9a136c3580581fe2a82f16a48db1000266901dcab7ff24cb179cb8c04f67fd30c5cac0114cbfa42ad4bfcbea68590efc0cedbde36eb3e9d913192d88bb1c30e69904835447c914c74ee42c53d6ce2c2b8139310cd2a38b100a81e1430a363a4415fa543fb2b388db024d053dff8b9a3bd708e6713a7ff5bd69ed6210955c2511b4fda2b76d59ce7b5ab62714a66dd131914f47132a6441f3eaf34c6796937568faff89d7f924cfa0b0bb305524715022b968357099ac184adea415eac0b0456cdc8712a1041071890516935476c64fca80a40c5b7765d6192539e70e3238bb09f8c4591be039edd7d8c1c0885aee126e109e26ba449ea8aab40221f25170f3f17b73240a2081cd0289e1341646ea0a080a127022a56e13d03ad77a0299477615cc0f628b22557f929a5547eb24b65af22ca9ab527a571263ab3a45b649b60563a9ade9752f7c07434353ba219aece073315086cb4a48d19f20b144f58e792093b663491fb753c9ff5b8bed25dcf46538364b4adf7ffab29ed351356ebfeefb4ed7418b20e177a10d2a9f22ef76007e8fd9fdf092eb8b9d591e565f9a75a6bc87cdb18170ee4f7e4a9e79d785e144f2369d09ebebf666f3ddb64070beb206010f45804e56260a1159778bc9fc0370e52577139089b2b23ab9ef445ecddec21a7724810f5131fbf4a31aea1cb3ba95b4efc81698fadb09bbd2ec82eadc52eddc980ed7e310c4562755437b23ee3c222892db3df0f8f97995d85fec372b1eb7a4bfd22d172ac674a4865a566066ded02561681d07bc86b7cb7b24ed27d47b553a8510d95c9858e3bde1a6cd09b4e7fcaa548a7df032afaa7979b32a1e3f99e15cf3e0a938eb145618b5617fe19c1c932ad5c0efd07e141c8e2ac2283d070a1fac0bb42cc45fb45341c0ffdce2c4e3ea089196e5744f87979283fac65faf517f41941b0a96fdfbb4a5fcf1cfb3d4a1e6a97075495c3bcaaa21f0687172976abe97e73efafa64b6069bbebc67e6a92715debea9e6572bcfd88c7d04cef356d06fb605ac7de17e189e3d82c248b56b76efd512bf95a54d913f3016b827e2ebdf0a914edd72c9b6092ec68974e01097b5b5d0478d48620f599abb8e9612762f734919296064b2e07945a166a643f0004ce4a0b5c9ab4d19c11b3b277ae8e42298da2c7d06fea2d3e7096ed729cb6ed6b0350387d5a49b15f60f5eabb71f1d82c9bbff27072a2e73c6c09d1926f393475727a4ae97bdc96f683c8c48be6e26cc0a517c55a24598ed8599242bfdd2c69b86af29447aa76dca2fb856d2d150cf3dfc7c5ab134a8e6fb0594d4f93078fffa1f85385e73b8bdae0be6b9c94cb6465e3e022d32a65d815be242162e32df39f42b9dd928f155551d75529f1933ba1eb0b2096ae380fe771290ca3a9a967c2b9d103da6cedda3f5652c5395c75ed716afe8cb33a9ca896aee01f6fd68dd94beb67ebcb079d88b4243d3cde787aaa27376a29d5f672bb8e6a2d7c75476baa03c8f7ff4de2e410f44115a4b3aeaaae2d2110de3b1384d41a0d7091d71ab7c250b65e0c2e8bd6e8aff2ae85a0ca00d313ece77e232faabff797c821a9bdd04c985b058b002a9fea88488534ea7605db65ee61f244a342c488936dd8706d29ec28d861b19e1c4c1fda62b17cc3bfa7450e1ff2690f65d83d85b982ab5c05973ba04a94c401ca1caa3c858d5e2346a8f8dae3cc4360726e9f212e9e1535ec64bff0cbd21809ff5dcc6f50f4997d6bc80f3cac8857a8ca0fe4734199ac9c18de56bbbca6b51f60ad0d7838d56743010af1327ccdd081735a82f8766191d678ce6b6a31bb7176a8ee66d2c0152a2806a60ad9170d1d2de853e73506f76fdcbbfba8e4c8d59968312dff0cc58ab108d542c48dd9d92fb66a1785e7cd57b06a1258a5f67e4dc4b96d327cdabb56a8f7f364f6f5e45259f2878d256d62d8e93303f989b2ecc2b3aeb40a470f2460e5fbfb656f7929d2b966b46289bddc5723e29cafea9c2755a409998fb3dc6fd1ad18c1a1f4d110c873def5536fbacf355de7418ec5668730cc7650e1741469d74b0f27d2ef814b25c7ecdebd6467c72daf36e792cca056d3e0b1a39079268c4d80c0d16fbdc2111e059cfb80d6cb687d073481bf5abb509927efa1b034a2a1fbf57b0d312e34a825c240b495956892b5313e428cb31a30f56727ff64d1891a5bc2ad99633e4e19b9877a2bd5adbf71841de8a0de88dffba3e1e6efbf5fc126c6244833c24bb36de5270599a15ec521890f15393384247498ff053cc8989f0f4944127acae0771100a9c71dfa74fac529c4da39d42104e5602f5089760dca9b5b3a6a316bc4104e9bee51a85a640802423905ca238918cfc982b1409718ece7766f03223b8199f1e3979e28a97dfedded8b9240e5b3d6dd7d6b5c71ea7fafa38c01bd69b7ceb5acef4e147130451ca09f45b3c37732543f97e10e387d4a4145b4530cc950ff8b7aeb9db64dfd2be266dafd2484422a49fd3fe8bbebb3ce458bc73e528caca6b39a52ca7542c4490463eaf58cf781b21bf5b13abc20704b2e7ec6b9d33252182f4f4f03ef146598ca0456712020452f6c872c7726df9bd64013339594c7d659aa2e52473a3f07e0149922cb0ffabe7851e3cffde6d480c2de4cf12e9994f3bd00af6d3bdca6214f62477b9a48f8b4f44d9aecaaf2121b805ee340dfdd5112f58085b3cb2905c5f31aab588d50ed146c81f2465dc1a9ac06a9122dfad7b157a41e436c980b56583eb4190184b1885e6d9dc5dd1ddb204381bc00388efa3f6c3da481411891d7ce9eae3d2aee63cd1081928cc65a153ed57bf383e061e6d8e1da1a2e5e2e5985e083f3be42c78b1a15eb8e84d91f9ef8c60e6237750e52be11c16c4c041cc0ca914419ed312c55130ac486e27d84556e10ea1a7728c2f9ca222ca54e0361c4c5cb939fb6e2cb0b7408e9360eab4435ceb33101455a343a8e0a5d4d0ad23c0b1a3c49ed51bf84c94d9375d85d74b17075fcb536de2452587e3c2bd5ffd0c444669ca5fa457d0c9562ad298d3c872bf0f7441ee43bcd6f18c086c8649f2e4557ba3cccaaf31e360ac9f3266779d2a957bad37e1c2c2ee93ab0d5cb37091ac3163878adaa4c16ab832b10d044dbbe647fe56b84401c3d02091760b854a1f10dbe96599598fd7807bdd7ded08676397d67d41a9985bfbada7a8dfd593d0916b47e9e3d21ce7aa9b5d4dea85f0a26e78be7ec23e7b2d9f35d971e83746b76fd9be0ec5f21697b8ec74a3163f1eb693e30f3a8521c9f2ebe1a56182eaab1ed7c5d5a9a349fc9b9d75f2d7dc41cbf7a7056e27e0981cd625fb33a31dd606f7692685cde433148df226873af996fa5f64a495a36a362634ecf97cbb3268790cb698a9a9f97d8f3452924b7927fb1cf5fd1315a0cd789d4dd084351bf086622dbb680a7d44e9937eef88912fbabb45cc05ec7c77306f3bca08f8d47ec1d62b5ad51414bcb443755a0cda31c4e9cfeaa7e53aedf4dc76cb315f86c71d72d2bef00606db35b3c9a210e26c166595f0ac3b1bf6898d519572dfcf2e7d027d7c4a46ea67d18cea0bd84d372939479e047653a6d7e5d5e12c904cb90bbb579dddcdf7b6cf0c7f11a0ebbd05344430e946a89c0105e679e66b0003e9a47a23f83a99cc9678380fcadea256cfe40bd2ef00497477347805ea36bf0d3eeab59fc1cf475ee61ae8b1cb271b68d051b062581bcd030158898f7487bcc72d57e8d1d51ef965305ffd1be8f9a9ee2cd02597fead96d94c27f75598d4b64e0138c2f8c80a098fe068ad875c9b74f3361dd9514ae88fd7c794b7de22e0f718adddbada7ea106f329d8a431469068fada43066842e658bc37a50a350e7245e9dfc36767346d6db8df41fc0ff27b0c3b88bb6a7b8d0caf752329a49b87d7cf97d4e05cb15fd4799c74d3b703f4591315eea3efae471afc4aa0907e6242d38b1782dedc8c0e849e1517581dbafec7564fd6951e2a44c3809191522a10bc09ce56704ad62b4e2c9e2ad93dcec721add01e82690a5c541dab51899fd5643320b3b37cc40ce183d2a3a560c025aeb91ba5fa0e1ea89f82280235c9bbd5109e9f2bdfddba3673e3db80162d34b4c84f0e7c9974ed735f231ffe413228c4a4282d6461c5471a75ebf5b366c3bc49133291d9117d4426d407f26285fe5b03140e5e40d683ecaec43b31c0c03d5e5c73867308962c28ddcb69200697d57d14b12ff18e4fe574278ec2310ae2c4f797b13fe9991542cbccbb8593ade764a0bed9065d1fe37cc9f6cbf18473047d6f8b3d60c1294e6bfff327fa5ca47059f789e083403adc443070a5c40db99dbedb5ef0d4e9ee987fc084eb7b972e4e51bc43042eb104c681ce57299d364ef673a7dc9332d4973bdd073148d16a60263f5c9ee4c95188d40aea14b328f9d7ddccd611887d99495b3f528f081a40ed8750ae3217c8325be4b142eca2cdf07d93674fbbb62b3f53142b90586bd2edcd10bcc4dfadc47405b8da780341511f83ff7333d9d0e8df1a91e4e4cfced6a205b6ca87b7276e3e43587b80a0d8abef12894986ce5c95247f83b06d96d0579414063353a4d2bcd20fe221ddd9348b526a663b686ea8436d19d09a5f67eca461f57ac07aeb514593df0609d580710bae15bf1aabfaa814ab75f68a52c541a8c5f2950b7ffa601cd16932eadc9a44f9b72633e40cf886b0db9b60da8241124453f3e06ddeefdd4a5ccba10b83159d78a94a2af75dc0a9d1b879ebe0a708135929a8f867e8a177d2f51f4f9bab1dfaaf48ed39c3f35cec5d878c1f94c9a6213ccb824713658215257a604655018f5dcad663c93f80ca635d4e8f1cefe3783fb0878478f13820e8cee15f325f74750787630b83c1d1a76f4974526a44c3e98767ee9e22be8177bd3a7a91520dde0dc5506132ebe45dea0b048b5d1f153ad1d1b528e4faccd7f10ddc2b2cbb38d2121093db9a7466ad36a05b1ea336702a53ae1c5a3ebbc09a0551fbe4d665016b680a8e75bb0fc39952722e6e1d333af172a08610d9673d16b8e8d3ce53f9908cd5976a22757b57a163b6d8a7138dcfe95d1d2881fe0e3eb54d8e7f804fc468237a13b1711ba5fce593ee93bd68397c7d5598f22a47eec3bf71ac6f512070feecda53a8943f7756ee0838ba99badd419164b7ade2c149ef8d71652d7a92d93a794b3dd29f4143775d1a8239b0d438f7c4fbd671cb781d50de62493d38362c7713f1c8c28b23f9bd419b87263c232780f3541c804f2a67f893807a597ef56f9494eea142b53c1f1b57e88d6938f0a689404d21cb8d56ed2a6f1bead4ca54b45e84decf7186265189e7862fb09af530801f7229c586ee26338fe007dfb7c0892634453020cd126da8d16fafe33bba7dd88030669dd7d6f1a934d82cf36cd3044b3a978f1dcd52a0f4b4330ca23295a9ade09ef3a65d97bcd907d0ad83c1ed7cc10dee2856f626ad0cfabbf586a89a8ee5c50bb94d28083770e8b4c093433c0ed1de8b6653c772bc384210a19d032e7d0eb2f8f9cc76a1ab30e694d9e8de8151012a076bc4c7e9cd37a01c020933514fc49ce06221b0d8bfbb6c95247be2ddd5cade821fa955f0dad2de88a23fd9cd9ca53a6a1d0eca13d6e834d3240d3c659a264d5e568cede8dac77fa387ec520d4470d23ba0769df1fd1aee33aad30e6ef451fab4d761a310d690fca8f35a231b51cb725d5ec95a73476f74bd7c7740b50060b76dc620f0a4cbb83e18b99e500dbe2a14cb408bc7260f894fd1214f3359faf968e0394929f2712e00a637bcf5db58d31febcdd3a7233d5fcb821597961c37bd9850cd3264911cee7264b4a4f425ba301338ee1e590b61009bed0f2fa7bcb836b9834dec70885f32ac29d14283c053d30846bed848762ca4b38a42a67c612ec0c3105cc81407e6be0f25ad8d4159d0c26a352adb36329f8e6d4d837148f6ed2f8b02add99035e6e7fa4164f83f9b63def576c2503dc23cc34db5ed2a7f42d69c18119a2dec83e8d2ed6d9d6dea2149f22761331a866c650acf522760811052c5cba0f23085fddf5556f1dbe5fcc692b21e8aac52bd87e6388d90d1a8661a64f746e55f892fbd64863573e05a49f331de4e9232ffc375333293593adaca2ec81365912347d9c740990585dbe99f7fa0acb14049cf05070d6ae62b39177383ffdf9c06cbb4f5a77099637d94aa3a87a00c3ec2e9148d3ff7549c01ca4b097dfcf2ce747f4d2acd4fabd694a022cb26b02888071549ed22951020f550b6f1cbefda1d470896e35506851b0c425d23370bcfbc0a8f04acd51d34b37cd42626f3a5fbeee5a26bf51241bbb0e5a5a328b00a78018b8050f99cc4a0b261ae0b84f02655e610f9f47d70d987351d3326628e803806b90d391f5747d64e4f9ee3b99a866b9f6902b8753c82e6274ff9806e7fcd4f28dbaa665cc1fbb85b9d08fad66a98e4e45961245b2c896c8288b3b9943b544d91ccd8f25d5420861407a2da17b2980fc7ae26a1f95b630bb8486690dd81ddc4d04731e5120063e2b7e94003b132eafec64b098f9d3eb5e2d21a004c7df7565cef6d45da5e61f62ee040b7cf8b34621ee43cc3762bd32ffb2722a16ac760093c09cc8fc478883490b3ab09a42553bb71e2e76a70390d206e732b23f979caefef9536091dec4eaed16f9a679b7455edd49ab8d6967c485739651e8525a50960102fe1e75ab84707ffc71daafeb9403317b687657748a2067599054e9bfdf6e93dd9118c0e699b4cda2b4167796184089381366e8fd065007b24659eb9292ce81e8a476dc10247b78833a29dbab508987b3c9caa8720b5f8fca5313164ad0d6658a25026edd27c71a05b6e4f939fa23242dfd8d946336fbb74c2b79586160dab499a7fb9b1fd66b5c2e2f5e133589dee4db26b8a6922b74a530247c2150e9bb5e9c912c0bf140ec187e3246727fdc24843b30c6b20c9a6e952a4682922abd11fd262765e332a3f5dfc03a4364f85976f6d7e38a8f4a6b5a596ee72f8c44545ed90b8a9311d4ef7e36b94da753572f05f817dcc71b6a589df7cd873903b47443ac67f037c4141ca895c505ff626ad5c15233249f93db607f14dd45627baf85daafa0eea1893ea2c2b7a9b40eeb24c1e9a9f039993390d7efff5d5e7da9cf6ac2c88bf2e0ca1d8a71317cd0264f9481e69b3b3d9342ce711a29bfe3d54dab1f42e51c3e734be292951edd9f34363d2421ca01b0115caf4319f7dcc532e7b7b43895928be93a594d67b79ac6519265174105c86ec96a5f0440516ed7943f093ad6b90b2705ab8ecebdc76c9ef4b4c9135bbc0ccce5862a8ba06e8b7568f82ee568fa7b9d9a86b891e2f28276d16373303e1a775e86526e5ed251184593f33f95447947b066a093e6b65bcc6b939f34ba84884a88767c5cdbcac03d5732d918bb4e34ed44936ec246b9af6a2ce7d2fb737c84ade9b3d7fa11031a86aa17954d652d8e4e628fef3c2ae5afc7864ab4ca4b2b31f370fb08a2fcb9f6674ef4fef532ebab19e8147e6a220daa721163fb71f08e0c512eeeea22b98722a74fbb41fbb1b408664b95447b47594f7676f15d51e04dbffe56ea37758b618b8e59eb3e1ec64c9ff99485847aa0cdbcc79d357e1b78ac90fe1b4875d16fba2202f09e15d3d89bad568f50042c3259f4a8e90ab16a5092e6fc12b9b8c554c68a9c7162b14ff8e3f2be346dc55fb11e1b19aee69cae5a821cd635fc373e26cbdcfb6cd51b47ae184274983456b8e23182b42d712fa8f6bb2722cf741ff93d82f10163d7014f854135ef0d860f8879f35a64f445ed8083daa2d6f9fb8993a768decae1d1d86cbdf2ed58a3e56f543383ab3ffb514cdad2c2c1babfc5f5e18d862d8e558220d590dadd2303bf5b8a3cf681708cad4219b35555362b0003cce4ae0563111356d5cec8f5d08cd230da7790550d22454f094857884ff09675b2f08db150939f0302a2b9e5ae792696701552456e8e25caa1967167f7351732313f5cd14c7cd9a5b189be60b11a34bf0a447ca46767dc3f6d90cad425354f604399e0170d743372d9e903ba7cef3c6e20a64ee88b424d846e5056b36ee5fa806da3febe9eaac1bbc19f03cf80c590c4340f91e00529864ec0d396c059ed31e7bad4bf5ef4bae481c0ddf1bf8faabf421702957ff329d4cef1aba1ce2d8b540bc7175a23c66ce4b0fb7a6b19aa65a2b93028aae1ac777e89b60e49affdc0d18e1eda8800c1d01f1d035ab52937ef103016b160146545fadb493c55ee97f6531e6f6874e6962b92f0e9ecc4cb622bc130de90892ae73fa5de10635d71e1182dcb8bb4a5bae72eba8cf9f5cec14346da7059dccf5e73bfbc555e661f91f0431cf4fc9418d37a40765bddee061561b64c3a38a042ff11b04f39bae70a2f74f139abcb43f5c2f0b1cf12ebf24841a42cbfdaebfcfcc8535475f4fc073f0652d7201c10398b70bce726e59593b8d5c51abe00b019e964fb463a021ccfd59a54674efb46eb0a7a3d0d0805f4cfbdf5fb3ce3e354927ff3919c0730a3d42275126064956775fac22905fe6bd22dfd1ed08e4c3fc950cfea5939b85c7810a4af0d802f511cf58290644007e69ba0d9f27945ecee3437038de9feb70f21473882b718ef4f6794dd5925c2d916ab0b7dfc6c2510462c2a501c839efd7f4570690b4afc0f0d6dbbde6049f44114f93dc5f0f18fc7fc23bbed047bcd0ac2cfc3f55b7cda0e23e80590d1eae535f5368185430d496c0057cd4871c20ef060626d896a153d9134a7117c96bb380a5df359d384a981bfc23be5f2f58b07dffbc9d1700b455562a0f6a3a97edc211f707c183e4a4f0544a454f90f37d47f73994ae9a826cf70a7a10f5be4a217ac4cca07c6edbe8df3d3c99080d5986407a11d667c2d97cc31118e8701ae2cfecd88f4dcfa264036dd65df2c25e08dd651a2da121073aad3f0b6b5abd7c774b5d2df55145f4c5c6129db05c54498f29c588e5abcf9608440ea1511e25baac1f027eabc6bd2a839918d326532f6b047cf2560cf12f4ee7fb5ba2a3d5a42c89057cd876d355cb146cb1357ee8cd9010f6c0cbbfa0a05e8dc4dd094901595b1fa6b600e107a67e92fb8b78b4ed48285c4209bc0151926308a43d81e8f22afbb39278ce6b51bef98507f356b18de659f050f8a9ee8694439189a0254c77452c9abc52da0f59f0463314b8c1cff1161f44e4cf9c62ebc4a90436a03a79c3f4c550eb9e3fef2b0a7d239e555e46372ac78025e9cc21778e4982e231b94ba8e67cf0549f224bf03f9619a59d85f872755ce60ce66eb376fc1bce572ce0e30f5c3aeba9bee26b5f99b06e42f20b866f1b0497e6a80fa82af66e62303a35b005f75d62e69d7cb821f9e35d45870a9959a779caa68c88289d43c1b3216b6bde996b9fc178a6594a8e38671b6ec2ab2d1b0f606601ac8a36119686b8f878de0f7ca437f14c8ee178588049218c4d593d335cd05731bbb936ae4bef4e4de25f9818e91cbc2b8805109885b9a5b04cc03668b59e300972ed4688f33a7088153eb0df2c9049d33072b44b7ce9d2861aaf308fbad91f479e869ec147f7e7f22be1f7a6fbb898021a86af07c526b694b0c7cd8e021016241c2fa54c30371424f9efeb1ee95715c63277ecd81ae01558a6a3c28580d301b848fa3249aefed94b9ae8cf90fdb26e5b4b7dc7c868c2e5d31d05dfec3065d2204a42f5ac988911ef3c347e3a2fbdaed56a61d2f65e104d2772ed6f46fb33f59b10010ec7b82e86d92d9941cc754c4c455cc0cf465d859a9b019f471f5eef3c0b476a490e17cfbdca9348863882502feb72d35b234151f404c8f00568473df07691a6cacdcf3271303df3664de26fc392af0fdb3929a6b8c35b7f1c5640c13b0d3013e13728380a5918dc244428b873a163a6febe98c7d2fe7588f356fc06edec4d608c6e21831f0d1659003f382ec80c8be9c13ed7f04871440bfb1b91810a2116f04f5fa5bbd6d0fb3b8ab1bd77b7289bdede9b6941e906ebf5ec61a2e80f33ece578497183f0e773d9195cb9f6f19b60930bd30b5548237b78aa49acca468a61ea713e044a2292d736df449bec2c99d2629f4a8f16615bdbb3e47039483580a0acad88db56eae71a831cd23fe18d9cf82e888f7e9d820196a575cd0b62e42f3571551dc5adfcae2f3a1e7be3400438e59d9cf439852ea0aa39110db4205c3be1427f7bbac7e54b0078c268fcbe93076991247dd694985d29784231eb9d0048e4c3eba1a03c27d2fcc6d40c43f70a6d1a51da651a87bb1811a2fb71b73fa966d52d7096e436aa6fa05084f9fdb7d9e56ef9666c7b717076b71b0f0b0a0d1c727ae356b575579daec08f0b2b493752a274069f0f1fcdb260f012e08352e46f8c5f0182b97545d8ab37a6c405fa2492e2666bdd6a63bcedc4ab72872890379f22326a32cefb9a9350cedc6f92c565b58e9adbbe680e8fd04f361d14187664555b28c98d2f1c8fdd6009ed220b4176960d133d8e18a41489192f5747fc25a763780ee28544a57947c96cf3f29c6e3353ad145f40b212629d5dadc290d3b6201e2d7db72d505d08ca7d2f8c3e6622a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
