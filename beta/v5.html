<!DOCTYPE html>
<html class="staticrypt-html">
<head>
  <meta charset="utf-8" />
  <title>Know Your Worth - Beta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="pragma" content="no-cache" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    .staticrypt-html, .staticrypt-body { height: 100%; }
    .staticrypt-body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e4e6eb;
    }
    .hidden { display: none !important; }
    .orb { position: fixed; border-radius: 50%; filter: blur(100px); mix-blend-mode: screen; pointer-events: none; }
    .orb-1 { width: 300px; height: 300px; background: radial-gradient(circle, #604de4 0%, transparent 70%); top: -150px; right: -80px; opacity: 0.15; }
    .orb-2 { width: 250px; height: 250px; background: radial-gradient(circle, #4c6ef5 0%, transparent 70%); bottom: -80px; left: -80px; opacity: 0.1; }
    .staticrypt-container { display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 16px; position: relative; z-index: 10; }
    .staticrypt-card { background: rgba(26, 29, 41, 0.9); border: 1px solid #2d3142; border-radius: 16px; padding: 32px 20px; max-width: 440px; width: 100%; text-align: center; backdrop-filter: blur(20px); }
    .staticrypt-brand { font-size: 1.25rem; font-weight: 900; letter-spacing: -0.025em; margin-bottom: 8px; background: linear-gradient(135deg, #604de4, #4c6ef5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .staticrypt-badge { display: inline-block; background: rgba(96, 77, 228, 0.15); color: #604de4; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; padding: 4px 12px; border-radius: 999px; margin-bottom: 16px; }
    .staticrypt-subtitle { color: #9ca3af; font-size: 0.875rem; margin-bottom: 24px; line-height: 1.5; }
    .staticrypt-password-container { position: relative; margin-bottom: 16px; }
    .staticrypt-password-container input[type="password"],
    .staticrypt-password-container input[type="text"] {
      width: 100%; padding: 12px 44px 12px 14px; background: #0f1117; border: 1px solid #2d3142; border-radius: 10px; color: #e4e6eb; font-size: 16px; font-family: inherit; outline: none; transition: border-color 0.2s;
    }
    .staticrypt-password-container input:focus { border-color: #604de4; }
    .staticrypt-password-container input::placeholder { color: #6b7280; }
    .staticrypt-toggle-password-visibility { cursor: pointer; height: 20px; opacity: 60%; padding: 13px; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 20px; }
    .staticrypt-decrypt-button { width: 100%; padding: 14px; background: #604de4; color: white; border: none; border-radius: 10px; font-size: 1rem; font-weight: 600; font-family: inherit; cursor: pointer; transition: background 0.2s; text-transform: uppercase; }
    .staticrypt-decrypt-button:hover { background: #7c6ef0; }
    label.staticrypt-remember { display: flex; align-items: center; justify-content: center; gap: 8px; margin: 16px 0 16px; color: #9ca3af; font-size: 0.85rem; }
    .staticrypt-remember input[type="checkbox"] { accent-color: #604de4; transform: scale(1.3); }
    .staticrypt-back-link { display: inline-block; margin-top: 20px; color: #6b7280; font-size: 0.85rem; text-decoration: none; transition: color 0.2s; }
    .staticrypt-back-link:hover { color: #604de4; }
    .staticrypt-spinner-container { height: 100%; display: flex; align-items: center; justify-content: center; }
    .staticrypt-spinner { display: inline-block; width: 2rem; height: 2rem; border: 0.25em solid #604de4; border-right-color: transparent; border-radius: 50%; animation: spinner-border 0.75s linear infinite; }
    @keyframes spinner-border { 100% { transform: rotate(360deg); } }

    /* Tablet and up */
    @media (min-width: 768px) {
      .orb-1 { width: 500px; height: 500px; top: -200px; right: -100px; opacity: 0.2; }
      .orb-2 { width: 400px; height: 400px; bottom: -100px; left: -100px; opacity: 0.15; }
      .staticrypt-container { padding: 20px; }
      .staticrypt-card { padding: 48px 40px; }
      .staticrypt-brand { font-size: 1.5rem; }
      .staticrypt-badge { font-size: 0.75rem; margin-bottom: 24px; }
      .staticrypt-subtitle { font-size: 0.95rem; margin-bottom: 32px; }
      .staticrypt-password-container input[type="password"],
      .staticrypt-password-container input[type="text"] { padding: 14px 44px 14px 16px; }
      .staticrypt-back-link { margin-top: 24px; }
    }
  </style>
</head>
<body class="staticrypt-body">
  <div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
  </div>

  <div id="staticrypt_content" class="hidden">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <div class="staticrypt-container">
      <div class="staticrypt-card">
        <div class="staticrypt-brand">KNOW YOUR WORTH</div>
        <div class="staticrypt-badge">Beta Preview</div>
        <p class="staticrypt-subtitle">This is an early preview of the KYW platform website. Enter the password to continue.</p>

        <form id="staticrypt-form" action="#" method="post">
          <div class="staticrypt-password-container">
            <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />
            <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==" />
          </div>

          <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
            <input id="staticrypt-remember" type="checkbox" name="remember" />
            Remember me
          </label>

          <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
        </form>

        <a href="/" class="staticrypt-back-link">&larr; Back to main site</a>
      </div>
    </div>
  </div>

  <script>
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Bad password!",
          templateToggleAltShow = "Show password",
          templateToggleAltHide = "Hide password",
          isRememberEnabled = true,
          staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7dd8c3c632f81f7a3f9fb0fa2e5518deccc6fac4b020233f9b8468f47ad53c0c0c6f34aa8a5ba761553dfc708478564f9e1fe8e0804e1782e86af8974bd420ce135744a0be74c8ee9c406feb396a10a0b0a0abf5bf18b0e39c5219ad927b4c00feca1b6923ef93e10aa19b3dfac300915b2afcade454dcacc8af67230c5102c211ec9aababcd89b6466d6c89b1bd864cc0deb36382d0330d2d7e231f7da8e18e0fb9e2f3daacca75e8d47a44e433da9e36bde48fd8e26a8b91d9ee7730d4612d66d37f27a8f4a760fa967ef1d7073d33c6bfac688a0b02e2891878379cd33ac7f854c99cc93359b78c302bb963a90e9d385dc9922af3981830b5ffbb96b697745dbf35b619e1884ce2bde1f70401eca8c5a5a34e5407489332808dc90d438731257c61098f2c23b8b3c50440000bccecf9e8244fbf2cc9e4142b711ae614edd2ac5c705dd9bc9620099c3e846f38fd5114a64aacb8cb947aaa684630a765d593f378181c987edece778675dd45ab4660ff1f5ea595ef74ae91e7e61b67ef2194333414bdcd547a4e7854c9e08f8a55d5b3246dd102556e8d45263667867556eda667848d4a1dba5b00ac74743729a6b2e0f42fea8b904a4b7d83a9fc72ebca96944a510af0508906813b627f730b6f29c7139d09f9d0f91f092d8f0c87b23ea785375301c6a18be0cd42f4278cee0d766a75e864f2019c75a551dbade20784a110f1f2d838b5ca4017f8a0049a6ccb2eac6c51c54828e2a5efe9a9bdb73f228fda523741f96c911820206b0300ddf2de45a98cba2ef3d9efc5a6363bdd10160477f3f8efacc9b197d0ecab34d0171d4279a18b46eec5ecf83e5de831f4658ff6d7cfe010243a4f3c8e63a0da5c36de9a8beb00ab4552261077157c66155364a9c725d1f148e81e3b56a2f7cea725aa1d9b51a38394e94c7f4ad8eb697294b5a04955e1e3d4c3b1615faa36fb4a1611bf0430c947a3979fa0aab4a66148a589a33feb63979a4f9cc35c28cd71c3488a806dc4580a60b1699681954307defd14e7e8e92b436842f1e4474e2d8c8ce792dab5f2da0da0548b0e728f92ebf10704a743bfb8fc4e78fe47317ff8cb7a374a32b4eb8cf234717d1d3fdb353160020251e1f418c9a08200856d42ce2bf244bce1d5ef9df2c427a41b4aaf7fc7b4d652788186fd12cfb63cb9c703e5847b72e1993f04c5725e069accaea824584c7d43ca30686c1d1bb2cc09472b3fead2e460a8d8ff56561ece2cefc9151099f093d187a06c27513b87ea58d367fdcf907f0d085e9269f5bf21d31b3f83380e4f75bc41e00e7fda57012c23ce447bfad1d7cf70e9936382001702fcca23e3677561100c494e5ef9300d70d1adbfc8275cc20993b348246a34d0967594aa08fc402f884420079e7392c3ce6873c3111434f2d5ad8ebda55f0f1d80abd17848d31d6cb3deb989d4a9f074c75ea0d0896738b023269194066934b1619d729bbb4acadbc51d7580e4f0f3e42be2093f068c025c33e2e534e91097d9f799978e6789717c979181b2b073e365bea4e703b6c5f2dc0f89d5e8a9d6c5453b5bed6323f51c3daaedfcdbbda9a817ad7b4e40e17a60a95c5447d7ce06795348c54518db7a5ac6fafdf728643a571f818089f4294f25ba8408931751c7259d19475149f1178dc10e10d03e1b13f5214f229063bbc85ff466f8742c5aaa647df9b47042ca3b44a00733f974374c4314ce6eb441e53f9a9b2ce5f5feb217af399a3e0eabe52ca58fe41c48ba98a7bfd4043c1cf7602bea38a2c73df20177d9fde1f526818e538c7b358009f9f33aee43a3f0237d6e31cc44c56989844e56a5bf985e094940bfd0a47613a1401905be735213dceb2fab6a87eabafb898f9233bc3447c4bf2b38ed81d5829907229a25e76bd91f65f3f75a7bd302d6f2d1b42e7ee863246697a42a16a594aec3d1b033407397618a63b320e39b1313889da48903babcb64f1d2cc0a469dbda12eba45eb2f0d6ff270c605ef3fc56eda232267f5f9a7b0a228a42c4971998d256658cfa150eb2e93e5f44eabd9c2f719d57f12c972e4a8ac09392f2d6f485ec7d5c52fe1f38768956dbdd7129bf492a74037dc5adaa95e9bd2ec259b0158d1bc881218c91b496c96da96e9b4ca860cd503e6dfa12d09ff6eddbee11e95cc52c13f63e100bda5b0cfcba073d68fc1eb63cf6af368b97d94a1be7ddbb987425060fc0947ced56b9b74dbedc95a9b94421644284e062065caf6559c5f11a39b0bc389491e804047b1fc13228e33039606483adc6a96209e3d9f1496f7bcf76558670d948db0eb2ae526d776244d32cc0c52c991d10ffee459b66833799997d9f51baba75b4f668886743edf4a57477f0bcd664a734a3a45c0b41ca96d4ed5132ab274fe54a5b170a0855d4e81bacfef76d79d57a1b11a4be145f66c027cc269cdb6f6072f5111ca9c4ad2b0a7c596ad07a4c745627914aecf38ffa966a2cd498fa9a55e15317ee60f70c64e8b8d744be4804a137054e27b237f5e861711a4f51df904749eb8598ed7c2b3711a0fe1709a39f36c3931bcfac9eeff777d59dbdcc2075ed3e832166038a84a02dcefe2c9163191148a5e328aea6896b90fec5d421c25f4aafd3c402aae26efa3b55d8ccd33dc0c45caef189a18583b81154cb930a04e6fb15d792e562c600a9b7a91115589e2098d02dd251dd07f7a99c38093a816f52650a5ac5865091d0527fdbc60f44ccf134a9990113da5ee5be26c3a9965d558211fe347579cd24613eb85d6726837e1b45c144bf3e541f8d814b3ecc65dc203acac3f15ce4ac30ae509ff6d1786deb15e95b56c189f2381f7000ed4cd7b375caeba271dcb591f4bd29f6b0490771748fb4a474dc355a264768a20f19dd9bd3b60457ac9867baccf3c965e0cb8f2f94b0e6a5c92892916b49dfa546fd7afefc2e504f64290afaaa0abea6cb8e034922e2892e01b2f7cbfb116cd6a4027d74e67833b377589491b56e8bb92c026c4840f1b8e3cf37a1b127d1a634097d6f173ccd23ae2f5a0ebb36a948820ad36f582ef767a325614160a0dd17cbc51a8af9245278ee8c65cad579ef724492998b185a5d4cf83e5deb890a2b17be40f0da4316a5ea0f7cce8b1e89ee4c253b4d0c31086b4ea27f1fb4f7a391e256a4e640baf228554297a15a7abc921aabcd455c184411cb2814a2acf9df11434db6ec0fc7c2eb55373dd9b4b60a563663999f8d39149ee4489b696b55afeb9de0e0223f364e3a36dd66275ce60e05a9b8e9357bb9a1ff5a7cbebda989d9003f1e8545f3c55dddce9fa4e6cbd940a7bb0293ce89902ea49d32eadd5fe5fbf1aba813f76831bcc7158172d75521cff08b9550f6ad76e71fb625a2322395dc7c14aac393a9ed7b85112206af939f575751a55c2b948743c5f27109f2e88ed76311e8edda4976c1f3de7d13982e364c51894b1b677dd5c9e254c2d1eed45d2a2bb7edb08b4291adb3059ce8187176512836b66c73386a8c0017bb6e97158c6124d8fabe2f0bbc812f82be5ec24089d68166e729051325ae1d65f819541f77bd9d98974321ef0a4d759cbab4a22035467a0ae0d414f53ecb513a387fa92280980381f27dd3679740853a90442e5ce49424c514c40b3c57e5dbe89a2bc0fb00d9e6ad53c8bcae49f5a563256a747ad7a09f90cdb1df190c110b374e09877e198399416078ab3fa7519fc1f7dae59c09833bcba1ee286db0ad5ade8f23b895476f3b80244ec2751d090eb287c502418a7dee2306c8d777800c38a54cbf7ca88b3a50b9f930652a3d2e7c1273a9024b7a4a5134170261a557b3303bfe9582c03cd2bd9a4fbc91cc0a4861be3b2fac61363a89267416b1bc6554395d03d325712a4bcbfbe38a10b7e7f2a0e8d3c443a7eeb67bba448751c45d90af4fdef2320689657fd60db7b60b39fa9ae62ac5e553aeed2ebee5ed7e91827a93f3bcc4fe3c157d34e083ebc4898ff8768e863704938a9d171d43620a639185c1399c2ef815280dbda4109dcfc2b57f87704f9df86bfdf73c7273a9ed087a5bb7eacc33a8b1551cfd9459c18c3fa05ba0b9c0188709bccfa3138d668b283703237be22347f0fe6d3f5525755d2714de88ff5eb2aa7d93e32a750092b05ec6c02ba054e9b631728b29527d6d6f583a94daa908d28e890bbd7558b0bba6f052c1873eeb4b6e8d9a10c91a96c409645d906d2629e9b46e0ca4f53e5f7102768e781aac11bbc0335075175e37fa365d515e55b368afa06222e2991eeaddb1dd8709f9848118d3bc39d91471d0cd11d6e76ff7e869902fbe37e763e297d3c1511c47e7e4901c29b81f855a401076962f79ede81f6de75a2ac6e9c12498b2f014bcded0e8f35f45a39f4f3c0f8fa65b9e3f490418c4d14a88fb6240dd4b2afe2d393efdc1afdee6ed3a53a6b92bcae770c8dda7aa8ee628788d7f58e8ff931f1f1795f4493f26b365835543da6c73b696c7addd48968df85dea9dd654bea3feb3446552d5ada7a682e430ee0c3538900435980b4249d3721da336d925d0ccdba4b385784df31661fc30db4fd12d6f219c53a8c0562cabaf2ff2c3bb55c4b799fe15245bd2ab1959c32be68c3911ab16d5f0dbb81f600fcae12e13e64d21c6277e47ee79a6f3f7c1981dc8004f7ad7418cd77fb4c34520e657dc7ca99094d4c87c159a3e89b703ad0ea7efc756a3d8de506fda6cbb932243665514c0c6a92304914e766454da657f831c52516c645e8ffc699b8dd6ce7521b2652dd5ff866db806d4a2812f1adbf80129507c7d8d2b2242234840c02ef130ccd25c67a5081961f0c0e38aeca943bffd985db50cbe28c181f704ee7a8b614baf1f30a09b478299b42171775a7af057b09eaea10fccddf47c2e234f0f529dabf3f0f40e469b38000367c8fd4294fcc84503b4664663d04fdb9114dcf4739fa124c4b507730af84826857d0e50b4be58718e27ebef3e2dde811083ae7deb3b968fd341e976c51cef261b18867d7acd180ccc23b0ecf19f51948dd072896c06d3bd78a13ce7d41f0c27d2a54448aceda1dba2c6b6c8374c22388e9856e5b4e33cb4986ccdc2362db826b4444b21a40bd86925a8e373dfae5d780b53997e0edbe3287f404429c72df3dcf5265425856723dd749a69bdbd7e49e6bf31b8764ca45d8a19413dc124eca66c225073cb0c70d3b2a71871c205866333df3b14014f039078c6f1fd76420c292a1296a8d1f5386560a4d34ed9c880a26d333507b3ba07bcddba0ad22264d4e3abab45240c0fe4ef26b8d97d490b861f330ca15102527a99b06417b9600677321a496b6d0d7352491da0990903b12ba5d4cc8ab5f5119992513eaf0d2cb214df83f9c8419fa960c9467e0bec5b6febe115f9503f57a5ec4dbe4555d535b5c18e1022b590d549e5a78eea898be67ae00c5bc07ee832a83533768a61ca12b6eae2a97ec7b5002d930e890ae9db78f4bc635479ee7e0bb66500363d67d3a8d71602ca4518db249d4e6a30c8da9bb181ab067a36ab9f9c3341976b44a4e7a42797a6b63edcec5ea9dc1d6f8c8b6767775e2493c09d059b320242b00e3fa5bd08d257b6d53989155a902ae36f86faf896786e805643e5c586bad58d0a85c4a682f16d65f699f84cded2560e30f2f1a95a2643c0b1f1e16a3205ed5b066109648041ffa6bb86f0c5f84703079b305421c8b29a3ff4efa2a36369c260f898abf33bc857196aa2070e3298291a52096b513e4a1c3e1aa01e561b88ed31405be2f9ec2db5d3e275ea46a4f7c010e08bf995ff3e6c302864885a357b5a4725f02ee1562c86684c5e9370297741e4a95961ee75c76a7452902fad3a2da14ada090c519396ce1ddebbad54a34d1e92f8cb7e48dc9ffb99d1062bb583e4a3c12868fbfc7acbb53199a3464c329ee70a549984845bae43fa592e0b1d95ebb81efe09cfaa77927561a7bc06c79d1cfa46a250c1be2b05ab1b198508e1e83a54d801b87790ad4e0920c38ef86fc10f820f596ab36a6d61cd2a2024e7d073d2f03fcd550f0dd9d758fd4f0078839b6ef5b7fd533d7e7d961d494eae6721507d7af07ef2458223b83e4f65c2b7cfd47afa8bf3eeed0890691bb8626e5bbde3002d3aee6640973fab063c85a1ec8d5a1aef5d62c7268b949c1c38ea61fcab63b390fadc9f1bdacedfb62579acbe09cae581d30dda7e4acf1b030d35af6b7f4f189e9a9b3d9900598e88c25a5aa1d719f9fee9626fb97adf6a69ade9572c89b8f50f09cba721c955dd6e5abf69bd0411d5fdad2ffecde68c1bdd1d5aba103bd131591d6907e65b6b87111a655a14c854a566cb49375b502843e9e156ce541451af995e86f80a8c8bb45e783387f2dc5d49cb38164b6bdc15727aa201316c3dd7e0948b086191de702bf7979338ba15bbe84811b43adfc3352bf1923de6eb4014fff84725bcafd170db30db24b365cbc9ae83a38f500030d32d521262df0c73e5f1fa57b43c1daf4cb5232ace32670d90ea0fd8d2b9357e7dad69d2f6fa2aa370aa59c8a5906fd61a47f006eaaf7ccf5368c76447e7885d2dac2290991c4990a838558e60b8692d39170fc635058072b74c5fd0f08b570a288fce18310fddf41cb1f5314444c80a8f80d37d0f43420bbc6ee7907267f384f592c1f6378675c13a7c67098f15b4d0b3bec6a304bacecc5306bb6d4d21d20d6057635bc1b0936ab57ca740fc36e712f119689f9434bc46c6a844b7d542a63bd7d2b5c783a94f2343f6b3bfa4d9e6c410ba7064ed60184cc1058679892eebb5df4daf77682f9e8d57d5240da65485d5df5d72cfaa40ad634d2426673aa1089a7ca3b8ab5e24d94578108b8a68a917bccd11a2f6a43a51ac9d45b148713d4826ad26e7e9c9b69becb1132fbc960897149e0828072408dd1a4f9cc45f95cb8187e79d88303de474dbc55e2ac882eb4ac3648bb9b5228d6460f02bc9d9f512f3d5cc7ae1b4cfc8783d28ba589eab9d19eff0f33814a2f514a3b235c82820bc8a260034c53849235f7106a094d85ebdf7fcfb8fc2cc0bce4cdf730e5a97b18967fd032a0ea37789067c59ebda4b88b3bfb28c91b72d5528e5fb1d25c2e5b5b500dc10e43eb083aa42d73e30d38a02dd06b0da2c05351371822b45dab19b50ca76e9753fb6dff180a2422f7bf4fe03e61a90892d061e9004acd3707c21ed47bb74a013774d5ce9d244818f1da2e55124ebe195ce1e125c808f0c09d395d94f9f0fabcf7f58df5649e96c6fccff13d2d2b2b0c04c214ca09b0ca401c95aa6a7ee61da98a2d5d983e62bbfebda800207cc7f6c000b70d6dcd2fd64af72b092a0d8b9c267e9723b0738494eeba3ee8588799c32381d7fa1590655f40b2b44abd4656c1606622a06192441bc55be790212e37bf00ca042c5801cb69d77f6d424ca880491c44249904358a3593865fd980fbea3da42e53955bf24f8f18e2b001fb916c8b820672cd63534dd45b3a4b9e46dbefc5b0c08c2be846f674cebc21593251e62e2833ac80427aec9eab57399e4428e92693c26ebe11333ef2bfa00ba09db23af60c69d9dc5e276f9b27e5cbe34663a09b2c165d99e8f408fb44053196121c6515c8a5ca8d520e78c4781294e6b29fc19f7db33793db0515815c015e22213a77c7513766dbc20ee59f192aceb1dce1e738db8d514133303a74de87d8179df29f3e581a655ca2dc0283485bcd659f856a07f6a3d8c77d5ca74280f338c90a11b579d9a7feb7f90e52952ba6fa60a689f6185a9f5db3db224271fa611808f9d1857c23987eb93ea4478c0058ce9805a5ca73acd4876d963a4dd3d4a041f62cc8d080a0da91da70a6630a73946311bcbf477e64152c03f9ff9f81471507ffd11af3fd9ec2b44951d363b8fa19e5f6a4619eabba3229454d19e79712e50e47ceea9ed29f68ace0d97f4409b831cb0fe8255c6e25b855e4432544d39e45a892489c7f587a4f86edeacaba6e08b9f9d308911198f229eb7d81377b96a831a81217b0174efe84e5785c9feb881c2fad62cccd151520bc5890eb780fc81a1c37ed69b18e5b053f8430086ddf44a498254fdebb92b76c8c4832b5b32d81e72edceb7b248bf8bab331149ba256217bae7643dab268940e2dae725d59867322275fb7fff38eeac01ea8bb4846b15c7aee07b63ee009ffe61c1ba78e326a5a2f1a57e3dbafa2e6fa8b6e6520208db5edcf6fb2a132207d66f270a279a5d8e957f7b89c5c7351ff0a2c49350e5d1e2c33080ef31a26a7593f17c1b9d5af2f271496ee0b0f80553b53e430ee1374b26a9ffe0fc96593c932fd96cb59f50935d374fa3e11250522e4464362ba9660c77d8a998e098b632e55247eeee666b0326809fe87d1285fca356eaea9d79af442b61687444ad7f61e47df58cdf83f2f2dc1163643236b95cdeb82688c926aa515599a626e787cef39db50a94712443c91e891364479aba5c7af10181c3e29e83c2eac4993347598afb4dab5d667630e95d2e7aa7bacc30b21f0c68053ea24faa5221bd448ec912fdd4776aecbca2c15721742b983ea4fb507b640715ff7ecc858cc14c81bd777994d01346a01e2b20e1b2a94898931a1d4ed8cc9fd5510c1eaa2f9ca595d569a74749cfadabbb0afc341febdaee7fb2c14735dc438eb128ee22e66b3b0b6c32e9973b6aad987512d3075c99470e1de11ae64cd2a58a0bf9ee41db649438c922f93b8f5e9bf16baa985586c8c9a023c6634d0e5efa43f5a5624f29e84b6982c9c78a82ef1384d8c29b5feccf51c75b48bb797e46715ab0f5c87f3f168d6968bfb6c3610a68f66d416319afdf931fd709cc96ff3de0ad7c21fdb1aa34d6c9ed0575a0d29df728118c896f994aa4a59c6c0b7e5c54d56bb71bd6ba02346a229e3fcf215394957b3a2077ed8bbb4482c57b239207801b53e451c57a1f71925ef209920772f5881c151741e9203cde783a5b286221dc165a35a51aad6d49b8e80a01dd80426113075584681f1cb3773e4616679df759a8b591bda6c98dc039386816cc1daa419119f2720b66cccef72147162d24728268a8af07dcd11a26a12f0af5a1f1a10dbd3657f2661a17ffb17f673a8d4488bfc18532070f544128e71145800ce22a32686cd397b5e99445f267a9ffbebc61079dd31659119fbd231899e897f5f3636a7ce50f884e4666296de26033581cd6b8d75a9b51fef837f286eb9542bf57aef750055c23fed4cce8dc6653cf55d877409fc3406e35b796bfd59c0a61e06720ad4b62197c529f5405843695a7b96484eccbb663db30db3e721f46f16a9cc073293f3a325a7fa761883c1fb667b90e4fdfcabceabf421f0577d76820feabcf553838078059b2522d5cb5016028d6eb022fe93862d10df076628fcdfdb609775acf126a2808c529ed98386041341f4dcacdfc2ec02dbcd238885ae93e05e9f9ffdc60dc4a66f1e6b483f228bddc181cf66cb3a62b82da1e0920c93b14dd5921aaeee7da12cae47df412c8ffeef11360f1c6f2a2265e4636940d85404080a980978ae000ba28a0d0494d3d5387a34dd49663254560ca6d8fd20f0da6103f81f18394c7340ac6d27aef23b87d98eea9cf476590ec585710b4e29fc496cc14126f48df832f8ec4c21632dd3b474383ccfc797c8c82eb213ecc774cfa258a157464475a27fa9d21817c38df3e0ec6eae1ab4e2990c795d8d328fabc24a8530a3b0ec1b2a1023167254fe6c5427f4a10a2b845d24d2f6c482064feb1afaf75025342f52b4e6c4182b6b7ce4a3cef21f2c0a13ff265eb2168c8b718a5c9f055f8c1ae2cec47a0205c3aed3a34be5a4823cf02f917d3b9cae22d6126dda75923ce97ab57e91f52c4dee88cb451e976d13c9b226ebf473fc66c3aff83b929ccff553c5c04264abec61f02770acdbc336345c77f14936e9cfa247fc3ed09865025bf6d7981222e885bd78ef768261c8595ed20abeabfe0326d0f8107665f1c0b1f32cab801e6ac5c2a2cd5de1edda8814bcb181dd4c8692f2fdc87abd76b786478f722af64ed8cf530d1270915d2e109638780b610d321b55daeea84ebb35483bde18bccfaed2125771d4293b253031362029008e2278b5b69ddc9d18efa3821ec6599972a5594473189642a518aa61e3712f6cefeecfae9119bb0132da0bcacc256cefdd7749529d7a68ba3f7f2de42a29d1004ec521da02cd23ba93f99218a577095b177568ec216f99f2613eade680450ac1b187ca5dffdab282148e847bd2ff69efa1ea602e8a64562511008127d502bd9a46aabe3351ca0a498f859216dd82591b09b786bf999c41c9caaa2b36c93ac6e109dafd9a8914c82005611022580c7ae443838d965e2a8faa85522f5570613f5c8235b927f679263c68eb44d39be9b3e98af498065bcf9aba063c897c84180470f7d353336ad896522585a7a67b55d741d11e1cc17919d3c5cdb4ec8d28c3716fd2343f0deb191c4b642694b21df80ae09198774db7c425eb24291ea00f630e67901fc76ad6e884f6bc683e6af70e7217272883c155b8e2a621f3221e2bdb977eb2ad950d252290273c58d004ad3cdb2f25533a4d0dd346ba6e673f2c6b2099945f20682e65a871862c88a55f0d44a1c9592cae55e66237c7162f0c379676262a8650107136dc774b56aae8b81593a51d38e5282dc66af5ec6dc0a30b4010bf350f090928a96a0041b9f658989e780920ed315ba908a82b8fc9125d37faafc6ad56cc34a45d0f999a547fcd58088f02ea1c32b2fe1d8dc2b302490afbd07f1a8318ebcb5089003931dde7639f3bc6ffa750ee0fe7a4e172e7a2110fc6e232eed866e43058bd14768ada2bd604e44db5c19c0ca4e1f53356375fc5c5afffc6421e829f178b22aa83cafa1ebc9783486b71e879f23be9a5de46077a22a4453c529de5b3be3b876b26008b44f5b021d80928fce9bf09b29b0af95ccbfa84c57bce7000db59b31148eb645c80af07c00064ceedf11480a6bf9e2c1724ef01fa46f773e15f73a847f83b3a2f316be4953fc091219c28b7081147c2a7d540ead23e14a947f0002f31242a929f4009da79629576dd36fb20b66143ff48f9d06e8dc4a40ff7a64ea9edb45efd57bb060f72ede68ef0bcd64bb39f1f3adcd3f7af4ef8c3fa330f20b2ca78e68729d6d2ae17a3bfbad5690baf3868133738cb1732871e2f7b37d76d367556c273a6afb13eff13300d66a728217dd56b141e24f5c17d6ef462ea8a1942444196dbb6b70e97f00dc876144ee0f755837e6c6d6f5a679d01753b7a699422523e744766bccc3e401f648d888589abf58df96c2f1cce5fccab296dca8800f9870493f5665691e7960c77ecf09d102387fb234b601e11cf31b959a0f06b7b20074cf4e58860b6c3ea37224ac890d083309d5e6e42e117192b5339ef712513c9c2f789d496543d2f4defb83d2e79bbb9d4c1029bf78de1dce0914ef67d105d4a71bbe0f3aafe4b2728bdb4af6e18604fd8c84e2545eb54cc883aacbc06a78f868e84e78bc9599354a506c98a861209015a01b655cdf239f079f73eb2265c01266ab9f5bb732c1c92218adee7f0ddd5c655653403a320c615a3109ca946fc311af0f9e18ae620fd995f86836ee346c27894d8b937112984151bd0a996ab3a1f8070959f600584948e1e09ca4e4de0406fdbd52aca3341651d5d7e606eed492edb5efd01336d9773b9aff38e42ade645791b1721b6203e02ae216e332e19cf72a2b252bd08a9b20e1490b784b25b6f35040e78dacc50fdea82b367321e9cae012a2fd9f1188b3d4c9fd1b22d9dc7302563be3633abc11857f3c759261945c158a35112a1f4608d4860efbec2759a0b7ed5c05bea53e36d6243d2c2bfc4eb2b7fe8cc7261423963457cf22eb884afb24a311f5d3abec34e362cda4578219fe8ccbe320e513549b3cc1d20d09e735b287b0a02d96854476ad85727fd635656003d775c28509a62dada30f568eb0f41d1bb56c9e1162785813a98ad3c44c62941660ef41e0b104fecd444b079c6d337894d3f2fd7d02785dd8ecfea1bcc1927624eb6e9dab50bb47fa1d538fa71e672646971fed3786282de9d6bd30c93c24d1e9fa8eceb3ba5a71de9647331f687f18b565640e175a614df91ebf8efb1246cfc742a2efba9b5fbb26bc000f38dcaeb996fda5396de14dc7b035334d962d9629c6157f9ebe5ad3968cb29138d36d882979ad11e4694c0e6e628fda06c0cee303dc84390c554cd409df6ce081669ba86760ef7e39e25bed0bd6435688d3f9172f01f97addba247dacf7fa760bb9520b9ee0609c6a9f93dad85a6b5fd00d85a12212610e67ebddc76b65fdc9a0f73218bf9b9ca08bf4baa01ebb7d7ebacf3d2d62df82a2f1e7c7146929788cf27da59a2f3160c3207cc09c4ef76b634d0f2c3d696858bbbcb0ca563fbb8f09cf32558a826a89626e67106c9b209487dd3f22edb120a40bc4ed683a309b8c4de06057bcc7c9c069f0e632961fedbbfab13fa4826a79f7900e55454e109460efb9cf3d2b629775ba4c142ed94d9326eb8a2735f672564d5cfd888943cd13cc546ab0eb4d04fbde8013c7fdcf20e10b095814cd3e701a5297ea44853fe5c1ec451954dc47e641d01f758f6804bb582e0704714d295e55b017b3eb7ac2a275e79054bdd72e1665d71ff9bca8529ad350f7008eca5da21a0e63e04e1b1f134487d27b8e3a3391aef73f387a14305ed6aec2cd1839e3ccf887ee428268242792fdd5206cda1172e51d28b5f2fb82e8d5d7a76b1ca0c766b468094eb6009b4f59f35b9e86a951b8d806da6a6721df05edffc12736a4d10aac4dddc4335d5497b2f93543d71175953bd796ed8ed2e95976d053942cfa275ec3089faa375a4ff70c628250e484bc31c3ec738f3b32051c0c3892ab4c10d8bffccba37ce06a9b3959abfa9c5ab8968138b38db1e82ceae63d6272261eea1d317553d1ad3950b86f3c8122814e6b6ea7f1e0cadab4a403f712e133110e398361cc6865e5a94746cb58fdda0a3fb26fe51b7553c25831ba535b0095edd951ff2e74bba17f033fd6b4c248cfe08851795f20d9701f63a57df67ecc3b510c30621a8f7ee882b86d99d523b497105a6c95eda380e5287bb34ab4089780e94afc20a8d6953aed862b9f95f40434f7268d2e5986f70451e39a311ccef501aff7d06573a9cd77fd60a284ed0dd438c6503c82dd69b17016f17b8457b9fc90466b8c45696052f09b5a698a6e97eb116d4bd8db0f2855d44f84290ea608ed92f64589e0d617f779aa8b7dc38380bd85e9cdf213a0773c39ba433e4c1c32eaa549cbf44dcfee2d16d47820ce0e2d2b0e7b52d3e4f628f51865bb5b8a15725c1ef28f938c6487f0ccad215a15e7b6028d61eb2fe1f6e50558d7dde3bbf74cd24c3222ae7b62f358d9adcf56a5c6b1474ad636cde33a6f03ac161fbae185ff24e41b9584ef9d20cc93f0a07043448c00cca804d3ad3bf9f303ab2a7787249683a77005c1205fa00d1aa50a3c3afe7ad70911b742ac12e65c737d51fa1e63ec7d67c89f1561008b5c95ae892021783be55850c56bc5ee483386434aebbf66cff54ad77b60cb779a245dd75f49698ff57501a4712db5ade5036d2239207914844c3883cff281b9dd49f0ce8f588c5087d7617dee2f9fd464fab04e804f6b057887b40a5bda41040f65e175cce39793ad3d898d236bdc7158a72928f6983e6104b56c7f34448116ff4cfb61ceff8b2a0753f7440bf267bf8001ce8e498f3f6d842d5dddf984dcf9675bdce20d7367d48bb102e9850eb5a2045808165274479f4716a97d8efd693c92a3fec74dae378bc57ce285e140977bd9280de447e931e062aebb4a42362ecb0fbcc507378b4b052e64121ce1cccca8c7a5a7963521effffb889da3545e0b9959cccbb7e173f6b0d046c34c2abb01e3b8596590d3424056054fc1309e9c387079832a580f1f80bdad020a5be60cf028d4566498d0a5aa41eaad7e4b4e2c95b4b3364198177deab91037fbaf1a7d14c75aa4b16ff8b25a0ab3b1c8272f436ecd306a159363228f779d3fedc91140cd1b747138ad4f9f4cb498583dedfde7086310e73ae9216847c7ac55aa907ac1f4dc1d18b9c2907a75e53ce4cb85ba1368e33a070ce89913e54ad09995dcc26c7c7c10d8094070b3ad7d6596a94961a05d9afc2cb94a95d219ca620b639899fe86d6565c37cd6cf662e83a9ad45bafae0ea2ad96f83c673b9327abe22f8aeaff2fafbda8ca60bfa28346cc7c921b38c3a54adbc0ad920cbc2d759451cc7af15344ed8b52cde7b96f20f1a600152bc8be8368834d6304cafb7a563b5dd97a0bf59705c0ede1f55fe66b36988e1f96c8c13e83a9e696d3504f1b107cc94138a2d67c83c1d65b5eb721943a03954791b980f6e192a74f79b1449e4fe472490457e3b1ca5dae049dcad957cfee4b96d453680191574b7d712768392f36ab7ed361be76327282dd3a1f4a81730883723ef8d38ef6ba33bb247250334929f9d77266e17e0d20e2914bc183cccf708af9c55791457631add506542fbcd9a0cd5cb735484580603eaf61a20756ed6c81e644c5a2b8e414d1a9b9ae9f4967972ca2b9dbc1598553323d2e44213e7c982c2978155c0e27b3ce9829979bf7aa225649a7426d6a7664f75d8a404acea2f0d320f07fd4a6af3933d6c57d53086100058a4ea6a2b4613bb1080d100c31b108b1072425626b1593b211c7c8decfcfb51fabd249788fe8a4b8230339859797d39350b19fa84c181526c5ee5bf29d8528e5eaa5cec4421e741ac1cd1c96f92d3440aad3905e144462e25d75c6547c122df060e58d1f597f9e84edfdeb7576064f010fd005420e7ec796bf03f74d1681b6c2cdf91f843b073125703e46513328d85cc4e3d7dd343f09d550e9208b98ef89f4bef7e4c972815218a07a068e91a59da83b81b254463b4e5d153b206672c6649ff7325508026334564718da7da93e4f86395fa02b1ddaea42e42a54eab20ee0682240551bc9c3698b1e1562c4013ad842cf38c8af685b8337f8a2d2ded49a229991964feeddad3e236ca49b6051beb325f3811e9c9c8aec640ac8e5f163a3c8468b5c1cb5c86425980a1c1ba17a23a9172c170a36f59288bb5a83ba2e2f8cec5a5260ca928e4654ef8f723b40a72ec375b920dc67bcb163aa534df266e9ed51f59dea44d9fc30ad54a02748294319c41eafd862e899dd52617e488e4ac9bfd6223d575b02e81b09ce8aa72c5f94aaee51b8d01d004fce8a5fdacf0c817bb6a34209a4a11b380544a42075e29e0511cf2cb5319fed1f03fe3675bd291c8f263666a4df0bef8af7fb1a975dd208787c2562641f8e72e45afe08d9a1007cbe15c490f33e667600a5b36995b8ea31cf16d4205ba4888eaa06128c0d6cf24d90ff18e1542962388576c939296c7a80f46b4a6790f51f69bbdec8e290ad9a7de48642a675c2744dd0c10a5c8c71c96fb5784f8899020e7a320ec8887a5ec1f1255a2b47204994e8f9fb16f25d2cbe53cfdfc4bee3e638c17ad04447402550becf476d1305521e7bc8c6bd28e19824da061cfeac04e112b521cda5bbd5784dfb57aeef297e6ca057825359013b641f59a9062bbe3b46e5100d787cd1563ee164cc2cc9fd8350b55028994f6fe60cdfba5b8faa9504ef6394f2017f3520b120edba7c2992ebcf0ca141af81d4be4620a1aac58e869fff0751452d22df3b2005891de4e25cf9408fcbfeab63429727c7e23d765c176f762cfbbf9e5fe1b45301501ce1a22ff439514bf188d261d225c7ec2d096df307b8ec6dc6d55a6185d4492f2f64ab88fbd270f6c5e87646f1875cab57dea44736b8c3947f74955b883421b01055d6f9296e2782e7795c00a4abfc78407c00085e3a28f9ce27fa928fc74746882187fbe932e693c91d139f786e19f48853ee310c71fcb983543285782396f23ce6ad52096224503123ecfd035b4a14ee77736d0fbac86e3b74989bcfcc62392b28cc7b8283be9b8537618afd09b51887273f837e5ab25e2d31395dc5bec812abdb50e0565de734705cbc1bee624a4cd13f07879267efb7d517780754ed98d4c626c0d5fcfc03ca4c5d3ec4619ba4b58c8b0873e91dff92c6d626756d879ef2d4d4137b66ada4c9f40034ac29d00f8b4a37b0b0a1f0efa2e5849b6d7947e4499cb04adcae5585ad344b866782b43a3106b8dc6253910966e3f0d68250e72b0c3a00dafeba726b814f2dde150e58a94eb13fa58ff78eb635a9a5d0f9acc141c568191947620bc1b73cfe74636b4804fd13cb2d16dd5841fdd36eca26a5c570bbf48cf7f2dc4699415b84433bf0e998704c49f14d098f5414a85e4720c501d2a7186e2a7ff1f35e94612d0412829fadf5edd69205e5a1cc612bde14d165889b0e4fb5a7cd7d445e914dc3a36674fb0ebd2fa6f9e2468be5706066e83f46da58ac95da8de6a48aff1ea82bd943b3ee1d62ec50bac49d434943f56722e6ad7deec454a03ac39377c1780fb4b3f9c9a051eface10e004c8184e4e9ee3315c9922e3e7e8b349f232df6b6495f532d534950366cb83eeb0ac764e5fa43af466a1237f006d0f4535904988b017726276913a773ca22b5ac02836d3f747099f8caadd1e51e660268355e3bbe5b4b257511ed0287018b57b46e1ebc53a28a3946dce9b0dd571b506b4309f9f27743994b6ad4ecbb84cac0062633b012c80db76e581f089262c6764b6445e4fa31ec5cb29f90cf9e7fbff9a708135f93b6b8dd391ccda57ed3e55917276e9f2dc8cedbf7ac0627a814d7db662a683f1757c186a4eeca2bd776988ebbfc371eb1c7928cc7e46d560071892496e150963ccbd719fb4435e2073ac154c37fe5cbdfd89ec5611b42339d7521650ad72a974c00aba6eb22696c56b7d08aef45dff535355a91a6bb1cd72cb095a0d296d60966f779e3194e38c21533b5cbe29897536c5622bdc3a21439df8f32899711d16d8995218083f99cdf895cd09797099a2e4f061d3dfd88950676d4116bd35cf16afc051dc679218fddde29e887dbc504523d379be8e466e1d117db2917ac04b363b56a861fe32e7bc678100de04689cbf8938b2172d20fdc428371126dd8ec1753a21ef5a4fea8cd5f6b409c6b343139d758f37dbc4ab82fc244e499cb9fca97395de902b878a78b6032b2657f163721d2287875067c02d1bf9ea1fcb0411f8cb1914f19226e6a08f5c93a1a42e80a1b07da05d1767b5169a60e75b97c24c7925a823e8d294fd59406853ce4c4a08c28b272537951f71be40c434798c6c332a91dcf843e725ffd65731eefcd3c34b36eda9c51ef2b21f41922592c29c344492bce83d996137a98df3ac26c3cc7529d13efc5e1514c8596e66390fb3d64543045aa8edcf3ab06dca408df456e75b27cc21bff9cbf087efc2d0441f307b3d0e69c1893a5d609ad704b4b00ad49764e6142e6ba7ec6341033b09cbad56e1a9a9d1c5830138526b3da30d206771a00e56ea095af2d1f7e71bf307209000f85297220ec6565bcd7bb7f78e646c70fc639fc8aeba70153e0f3e8a0ccc181fc4699e992f23aa46eee5b667b1163479e0416905b97c9df6094869231f0eea6aff6ad3127f92a1a35be49dd046ae3b772981bc077e5468804707ffb267a2b942a5e0bf7017595f197ae0046f46878a0475ee8c5b1043209944f86fd8008e2a9a7447ec2c9c1e502188654f0cf0ac9eac27aa5a08ac3ac7be654f4ffdf681db688fa452b050dec807f6ea39b1e1aa745307b7f7d6636ee2aa9d07813b87c940f4533e3ab86ea83fa93a50c70eb716f517043c6e46832ab9b606b9976aca23e932d91f1edd49db3605d8a2655bf7afde7f36d7b36b0c51d0be2d569096f789367e5592f5b485c129b0cc8ec497a4c74ded3606d88dc392dc32de11ba047dfa6226d3084042309909e4877d130f10fa3ae762cf1356a612a937c7d536185d70431b3035c73d96bb1c29d165757d8f7b31c5098cc672dfac82b77645be8a701e191b09972bb9774382c9b901b8bc335d167256ac21cca57a4eca9fbdfa63fadfcdabbdca0def313e871faf3bcfb8f53b28ad5bcf4e05bbd21290c4b7f2885d3c6eeb566c68be933003409d42a1f98bd081b31255413342280695b99b567a89333991802de115d0c630e90f57645e2c878a10e0b000e8f870d7e0acecb7c4a22f235393569da4a9834718b1c710381f4609571d1ae284c6759f5aaa60650698c96139d9281da759c4e1f24e12a4b33f55f9bf813c783cd95479d531de080fdbfc80afa97f2ce62908d24c110c6ae6d422423acf75a31894d07a1e20516caa448787346c669b99d41fa4b638a5d417705a94479de7ef377602c68bbdd0f29ef43b61b088a638040e7d8be65d5950507798db3207b18f84e43c64730f541928dce07169f212c9881206c386c75fed52d9138f079275940180d43725cc1b609933da68d716586185dd989bc1f0faaa994db6bdd4014fc3bd35b249205b7a473bea9fbd5bf5d33cb37bc5dbfe63e635a906d01e9a7a4ef530c584399a1573b85f73f60d254e555bfceb819c22a6daf1c07033de1dc9291d7866c6ca766e4a34040a589c72ff29b7ddea9e0fb801d8f92eb224eb97de9910ab0609a2bc8f288b7fadc97cb34618b7d2eb0d721a15c81faa34e42ecdca074ecf514a149c00e7987174db707b4c26a55725674432ab07f78d18b2e5e7d5322065218dc238607325c510a8dededa6ece69766e01ffa432346df83f7e6106f1b4613aa9e3581cbe16b9a765","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3cea59ffc9b41f4240050a62b56ef5b6"};

    const templateConfig = {
      rememberExpirationKey: "staticrypt_expiration",
      rememberPassphraseKey: "staticrypt_passphrase",
      replaceHtmlCallback: null,
      clearLocalStorageCallback: null,
    };

    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    window.onload = async function () {
      const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
      if (!isSuccessful) {
        document.getElementById("staticrypt_loading").classList.add("hidden");
        document.getElementById("staticrypt_content").classList.remove("hidden");
        document.getElementById("staticrypt-password").focus();
        if (isRememberEnabled) {
          document.getElementById("staticrypt-remember-label").classList.remove("hidden");
        }
      }
    };

    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
      const passwordInput = document.getElementById("staticrypt-password");
      if (passwordInput.type === "password") {
        passwordInput.type = "text";
        toggleIcon.src = imgSrcEyeOpened;
        toggleIcon.alt = templateToggleAltHide;
        toggleIcon.title = templateToggleAltHide;
      } else {
        passwordInput.type = "password";
        toggleIcon.src = imgSrcEyeClosed;
        toggleIcon.alt = templateToggleAltShow;
        toggleIcon.title = templateToggleAltShow;
      }
    });

    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
      e.preventDefault();
      const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;
      const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
      if (!isSuccessful) {
        alert(templateError);
      }
    });
  </script>
</body>
</html>
